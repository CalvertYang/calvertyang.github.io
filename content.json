{"meta":{"title":"Calvert's murmur","subtitle":null,"description":null,"author":"Calvert","url":"https://calvertyang.github.io","root":"/"},"pages":[{"title":"About","date":"2019-11-15T08:50:11.890Z","updated":"2019-11-15T08:50:11.889Z","comments":true,"path":"about/index.html","permalink":"https://calvertyang.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2019-11-15T08:50:11.892Z","updated":"2019-11-15T08:50:11.892Z","comments":true,"path":"categories/index.html","permalink":"https://calvertyang.github.io/categories/index.html","excerpt":"","text":""},{"title":"Project","date":"2019-11-15T08:50:11.891Z","updated":"2019-11-15T08:50:11.891Z","comments":true,"path":"project/index.html","permalink":"https://calvertyang.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-11-15T08:50:11.891Z","updated":"2019-11-15T08:50:11.890Z","comments":true,"path":"tags/index.html","permalink":"https://calvertyang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"在 Golang 與指標共舞","slug":"playing-with-pointers-in-golang","date":"2019-11-15T08:16:08.000Z","updated":"2019-11-15T08:50:11.861Z","comments":true,"path":"2019/11/15/playing-with-pointers-in-golang/","link":"","permalink":"https://calvertyang.github.io/2019/11/15/playing-with-pointers-in-golang/","excerpt":"原文：CalliCoder — Playing with Pointers in Golang 指標是一個變數，用來儲存另一個變數的記憶體位址。疑惑嗎？讓我來解釋一下。 首先讓我們來了解什麼是變數。當我們在撰寫任何程式時，我們需要在記憶體中儲存一些資料。資料儲存在記憶體中的特定位址。記憶體位址看起來會像 0xAFFFF（這是以十六進制來表示記憶體位址）。","text":"原文：CalliCoder — Playing with Pointers in Golang 指標是一個變數，用來儲存另一個變數的記憶體位址。疑惑嗎？讓我來解釋一下。 首先讓我們來了解什麼是變數。當我們在撰寫任何程式時，我們需要在記憶體中儲存一些資料。資料儲存在記憶體中的特定位址。記憶體位址看起來會像 0xAFFFF（這是以十六進制來表示記憶體位址）。 現在，要存取資料的話，我們需要知道資料的儲存位址。我們可以追蹤所有與我們的程式相關的儲存資料的記憶體位址。但是，想像一下要記住所有記憶體位址並使用它們存取資料有多麼困難。 這就是為什麼我們有變數的概念。變數只是為儲存資料的記憶體位置所取的一個方便的名稱。 指標也是一個變數。但它是一種特殊的變數，因為它儲存的資料不是一般的數值，如簡單的整數或字串，它是另一個變數的記憶體位址。 在上面的例子中，指標 p 含有數值 0x0001，它是變數 a 的位址。 宣告指標使用以下語法宣告一個型別為 T 的指標： 12// A pointer of type Tvar p *T 型別 T 是指標指向的變數的型別。舉例來說，以下是型別為 int 的指標： 12// A pointer of type intvar p *int 上面的指標只能儲存 int 變數的記憶體位址。 指標的零值為 nil。也就是說，任何未初始化的指標都會是 nil。讓我們來看一個完整範例： 12345678package mainimport \"fmt\"func main() &#123; var p *int fmt.Println(\"p = \", p)&#125; 12# Outputp = &lt;nil&gt; 初始化指標你可以使用另一個變數的記憶體位址來初始化指標。可以使用 &amp; 運算子取得變數的位址： 12var x = 100var p *int = &amp;x 注意我們如何使用 &amp; 運算子與變數 x 來取得它的位址，然後將位址指派給指標 p。 與 Golang 中的其他變數一樣，編譯器也可以推斷出指標變數的型別。因此，你可以省略上面範例中指標 p 的型別宣告，並像這樣撰寫它： 1var p = &amp;a 讓我們看一個完整範例來更清楚的了解： 123456789101112package mainimport \"fmt\"func main() &#123; var a = 5.67 var p = &amp;a fmt.Println(\"Value stored in variable a = \", a) fmt.Println(\"Address of variable a = \", &amp;a) fmt.Println(\"Value stored in variable p = \", p)&#125; 1234# OutputValue stored in variable a = 5.67Address of variable a = 0xc4200120a8Value stored in variable p = 0xc4200120a8 解參考指標你可以對指標使用 * 運算子來存取儲存在指標所指向的變數中的值。這稱為_解參考或間接取值_： 123456789101112package mainimport \"fmt\"func main() &#123; var a = 100 var p = &amp;a fmt.Println(\"a = \", a) fmt.Println(\"p = \", p) fmt.Println(\"*p = \", *p)&#125; 1234# Outputa = 100p = 0xc4200120a8*p = 100 你不僅可以使用 * 運算子來存取所指向變數的值，還可以對其進行修改。以下範例透過指標 p 來設定儲存在變數 a 中的值： 123456789101112131415package mainimport \"fmt\"func main() &#123; var a = 1000 var p = &amp;a fmt.Println(\"a (before) = \", a) // Changing the value stored in the pointed variable through the pointer *p = 2000 fmt.Println(\"a (after) = \", a)&#125; 123# Outputa (before) = 1000a (after) = 2000 使用內建的 new() 函數建立指標你也可以使用內建的 new() 函數建立指標。new() 函數將型別當作參數，分配足夠的記憶體來容納該型別的值，然後回傳指向該型別的指標。 這有一個範例： 12345678910package mainimport \"fmt\"func main() &#123; ptr := new(int) // Pointer to an `int` type *ptr = 100 fmt.Printf(\"Ptr = %#x, Ptr value = %d\\n\", ptr, *ptr)&#125; 12# OutputPtr = 0xc420014058, Ptr value = 100 指標的指標指標可以指向任何型別的變數。它也可以指向另一個指標。下面的範例展示了如何建立指向另一個指標的指標： 123456789101112131415161718192021package mainimport \"fmt\"func main() &#123; var a = 7.98 var p = &amp;a var pp = &amp;p fmt.Println(\"a = \", a) fmt.Println(\"address of a = \", &amp;a) fmt.Println(\"p = \", p) fmt.Println(\"address of p = \", &amp;p) fmt.Println(\"pp = \", pp) // Dereferencing a pointer to pointer fmt.Println(\"*pp = \", *pp) fmt.Println(\"**pp = \", **pp)&#125; 12345678# Outputa = 7.98address of a = 0xc4200120a8p = 0xc4200120a8address of p = 0xc42000c028pp = 0xc42000c028*pp = 0xc4200120a8**pp = 7.98 Go 沒有指標運算如果你使用過 C/C++，那麼你必須知道這些語言支援指標運算。舉例來說，你可以遞增/遞減指標來移動到下一個/上一個記憶體位址。你可以對指標增加或減去一個整數值，你也可以使用關係運算子 ==、&lt;、&gt; 等比較兩個指標。 但是 Go 不支援對指標進行此類算術運算。任何此類運算都會導致編譯時期錯誤： 12345678package mainfunc main() &#123; var x = 67 var p = &amp;x var p1 = p + 1 // Compiler Error: invalid operation&#125; 但是，你可以使用 == 運算子比較兩個相同型別的指標是否相等。 12345678910111213package mainimport \"fmt\"func main() &#123; var a = 75 var p1 = &amp;a var p2 = &amp;a if p1 == p2 &#123; fmt.Println(\"Both pointers p1 and p2 point to the same variable.\") &#125;&#125; 結論我希望你了解什麼是指標、如何宣告和初始化指標，以及如何解參考指標。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://calvertyang.github.io/tags/Golang/"},{"name":"Pointer","slug":"Pointer","permalink":"https://calvertyang.github.io/tags/Pointer/"}]},{"title":"Golang map 介紹","slug":"golang-maps-by-example","date":"2019-11-14T08:12:13.000Z","updated":"2019-11-15T08:50:11.851Z","comments":true,"path":"2019/11/14/golang-maps-by-example/","link":"","permalink":"https://calvertyang.github.io/2019/11/14/golang-maps-by-example/","excerpt":"原文：CalliCoder — Golang Maps by Example map 是沒有順序的鍵-值對集合。它將鍵對應到值。鍵在 map 是唯一的，而值可能不是。 map 資料結構用於基於鍵的快速尋找、取得和刪除資料。它是電腦科學中最常用的資料結構之一。 Go 提供了內建的 map 型別。在本文中，我們將學習如何使用 Golang 內建的 map 型別。","text":"原文：CalliCoder — Golang Maps by Example map 是沒有順序的鍵-值對集合。它將鍵對應到值。鍵在 map 是唯一的，而值可能不是。 map 資料結構用於基於鍵的快速尋找、取得和刪除資料。它是電腦科學中最常用的資料結構之一。 Go 提供了內建的 map 型別。在本文中，我們將學習如何使用 Golang 內建的 map 型別。 宣告 map使用以下語法宣告 map： 1var m map[KeyType]ValueType 舉例來說，這是你如何宣告一個 string 鍵對應到 int 值的 map： 1var m map[string]int map 的零值是 nil。nil 的 map 沒有鍵。此外，任何嘗試將鍵加到 nil 的 map 的行為將導致執行時期錯誤。 我們來看一個範例： 12345678910111213141516package mainimport \"fmt\"func main() &#123; var m map[string]int fmt.Println(m) if m == nil &#123; fmt.Println(\"m is nil\") &#125; // Attempting to add keys to a nil map will result in a runtime error // m[\"one hundred\"] = 100&#125; 123# Outputmap[]m is nil 如果你取消陳述式 m[&quot;one hundred&quot;] = 100 的註解，程式將產生以下錯誤： 1panic: assignment to entry in nil map 因此，必需在加入項目之前初始化 map。 初始化 map1. 使用內建的 make() 函數初始化 map你可以使用內建的 make() 函數初始化 map。你只需要像下面的範例將 map 型別傳遞給 make() 函數即可。該函數將返回已初始化及可以使用的 map： 12// Initializing a map using the built-in make() functionvar m = make(map[string]int) 讓我們來看一個完整範例： 1234567891011121314151617181920package mainimport \"fmt\"func main() &#123; var m = make(map[string]int) fmt.Println(m) if m == nil &#123; fmt.Println(\"m is nil\") &#125; else &#123; fmt.Println(\"m is not nil\") &#125; // make() function returns an initialized and ready to use map. // Since it is initialized, you can add new keys to it. m[\"one hundred\"] = 100 fmt.Println(m)&#125; 1234# Outputmap[]m is not nilmap[one hundred:100] 2. 使用 map 定數初始化 mapmap 定數是使用某些資料初始化 map 的一種非常方便的方法。你只需要像這樣在大括號內傳遞以冒號分隔的鍵-值對： 12345var m = map[string]int&#123; \"one\": 1, \"two\": 2, \"three\": 3,&#125; 注意，最後一個逗號是必要的，否則將出現編譯器錯誤。 讓我們來看一個完整範例： 123456789101112131415package mainimport \"fmt\"func main() &#123; var m = map[string]int&#123; \"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5, // Comma is necessary &#125; fmt.Println(m)&#125; 12# Outputmap[one:1 two:2 three:3 four:4 five:5] 你也可以透過將大括號留空，使用 map 定數來建立一個空 map： 12// Initialize an empty mapvar m = map[string]int&#123;&#125; 上面的陳述式在功能上與使用 make() 函數相同。 加入項目（鍵-值對）到 map你可以使用以下語法將新項目加入到已初始化的 map： 1m[key] = value 以下的範例使用 make() 函數初始化 map，並對它加入一些新項目： 12345678910111213141516171819202122package mainimport \"fmt\"func main() &#123; // Initializing a map var tinderMatch = make(map[string]string) // Adding keys to a map tinderMatch[\"Rajeev\"] = \"Angelina\" // Assigns the value \"Angelina\" to the key \"Rajeev\" tinderMatch[\"James\"] = \"Sophia\" tinderMatch[\"David\"] = \"Emma\" fmt.Println(tinderMatch) /* Adding a key that already exists will simply override the existing key with the new value */ tinderMatch[\"Rajeev\"] = \"Jennifer\" fmt.Println(tinderMatch)&#125; 123# Outputmap[Rajeev:Angelina James:Sophia David:Emma]map[Rajeev:Jennifer James:Sophia David:Emma] 如果你嘗試加入一個已經存在於 map 中的鍵，那麼它將被新的值覆蓋。 取得 map 中特定鍵所關聯的值你可以使用語法 m[key] 來取得分派給 map 中的鍵的值。如果鍵已經存在於 map，則將取得分派的值。否則，你將取得 map 的值型別的零值。 讓我們看個範例來了解這一點： 123456789101112131415161718package mainimport \"fmt\"func main() &#123; var personMobileNo = map[string]string&#123; \"John\": \"+33-8273658526\", \"Steve\": \"+1-8579822345\", \"David\": \"+44-9462834443\", &#125; var mobileNo = personMobileNo[\"Steve\"] fmt.Println(\"Steve's Mobile No : \", mobileNo) // If a key doesn't exist in the map, we get the zero value of the value type mobileNo = personMobileNo[\"Jack\"] fmt.Println(\"Jack's Mobile No : \", mobileNo)&#125; 123# OutputSteve&apos;s Mobile No : +1-8579822345Jack&apos;s Mobile No : 在上面的範例中，由於鍵 &quot;Jack&quot; 不存在於 map 中，我們得到 map 的值型別的零值。由於 map 的值型別是 string，因此我們得到 &quot;&quot;。 與其他語言不同，如果鍵不存在於 map 中，不會在 Golang 中出現執行時期錯誤。 但是，如果你要檢查 key 是否存在怎麼辦？ 在上面的範例中，即使鍵 &quot;Jack&quot; 具有值為 &quot;&quot;，map 也將返回 &quot;&quot;。那麼，如何區別鍵的值與型別的零值相同和鍵不存在的情況？ 嗯，讓我們來找出答案吧。 檢查鍵是否存在於 map當你使用語法 map[key] 取得分派給特定鍵的值時，它也會返回一個額外的布林值，如果鍵存在於 map 中，則返回 true，否則返回 false。 因此，你可以使用以下雙值分派來檢查鍵是否存在於 map 中： 1value, ok := m[key] 如果鍵存在，則布林變數 ok 將為 true，否則為 false。 留意以下 map 範例。它將 employeeIds 對應到名稱： 12345var employees = map[int]string&#123; 1001: \"Rajeev\", 1002: \"Sachin\", 1003: \"James\",&#125; 由於鍵 1001 存在於 map 中，因此存取鍵 1001 會返回 &quot;Rajeev&quot; 和 true： 1name, ok := employees[1001] // \"Rajeev\", true 但是，如果你嘗試存取不存在的鍵，map 會返回一個空字串 &quot;&quot;（字串的零值）和 false： 1name, ok := employees[1010] // \"\", false 如果你只是想檢查某個鍵是否存在而無需取得與該鍵關聯的值，那麼你可以使用 _（底線）代替第一個值： 1_, ok := employees[1005] 現在，讓我們看一個完整範例： 12345678910111213141516171819202122232425262728293031package mainimport \"fmt\"func main() &#123; var employees = map[int]string&#123; 1001: \"John\", 1002: \"Steve\", 1003: \"Maria\", &#125; printEmployee(employees, 1001) printEmployee(employees, 1010) if isEmployeeExists(employees, 1002) &#123; fmt.Println(\"EmployeeId 1002 found\") &#125;&#125;func printEmployee(employees map[int]string, employeeId int) &#123; if name, ok := employees[employeeId]; ok &#123; fmt.Printf(\"name = %s, ok = %v\\n\", name, ok) &#125; else &#123; fmt.Printf(\"EmployeeId %d not found\\n\", employeeId) &#125;&#125;func isEmployeeExists(employees map[int]string, employeeId int) bool &#123; _, ok := employees[employeeId] return ok&#125; 1234# Outputname = Rajeev, ok = trueEmployeeId 1010 not foundEmployeeId 1002 found 在上面的範例中，我在 if 陳述式中使用了簡短宣告來初始化 name 和 ok 值，然後測試布林值 ok。它使程式碼更加簡潔。 從 map 中刪除鍵你可以使用內建的 delete() 函數從 map 中刪除鍵。語法如下： 12// Delete the `key` from the `map`delete(map, key) delete() 函數不會返回任何值。另外，如果該鍵不存在於 map，它也不會執行任何操作。 這是一個完整範例： 12345678910111213141516171819202122package mainimport \"fmt\"func main() &#123; var fileExtensions = map[string]string&#123; \"Python\": \".py\", \"C++\": \".cpp\", \"Java\": \".java\", \"Golang\": \".go\", \"Kotlin\": \".kt\", &#125; fmt.Println(fileExtensions) delete(fileExtensions, \"Kotlin\") // delete function doesn't do anything if the key doesn't exist delete(fileExtensions, \"Javascript\") fmt.Println(fileExtensions)&#125; 123# Outputmap[Python:.py C++:.cpp Java:.java Golang:.go Kotlin:.kt]map[Python:.py C++:.cpp Java:.java Golang:.go] map 是參考型別map 是參考型別。當你將 map 分派給新變數時，它們都參考相同的底層資料結構。因此，一個變數完成的更改另一個變數將會看到。 123456789101112131415161718192021package mainimport \"fmt\"func main() &#123; var m1 = map[string]int&#123; \"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5, &#125; var m2 = m1 fmt.Println(\"m1 = \", m1) fmt.Println(\"m2 = \", m2) m2[\"ten\"] = 10 fmt.Println(\"\\nm1 = \", m1) fmt.Println(\"m2 = \", m2)&#125; 123456# Outputm1 = map[one:1 two:2 three:3 four:4 five:5]m2 = map[one:1 two:2 three:3 four:4 five:5]m1 = map[one:1 two:2 three:3 four:4 five:5 ten:10]m2 = map[one:1 two:2 three:3 four:4 five:5 ten:10] 將 map 傳遞給函數時，會套用相同概念。函數內部對 map 所做的任何更改，呼叫者也看得到。 迭代 map你可以使用 range 格式的 for 迴圈迭代 map。它在每次迭代中會給你 key, value： 12345678910111213141516package mainimport \"fmt\"func main() &#123; var personAge = map[string]int&#123; \"Rajeev\": 25, \"James\": 32, \"Sarah\": 29, &#125; for name, age := range personAge &#123; fmt.Println(name, age) &#125;&#125; 1234# OutputJames 32Sarah 29Rajeev 25 注意，map 是沒有順序的集合，因此每次迭代時，不能保證 map 的迭代順序都相同。 因此，如果多次執行上面的程式，你將得到不同順序的結果。 結論在本文中，你學習了如何宣告和初始化 map、如何將鍵加到 map、如何取得 map 中特定鍵所關聯的值、如何檢查鍵是否存在於 map 中、如何從 map 中刪除鍵，以及如何迭代 map。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://calvertyang.github.io/tags/Golang/"}]},{"title":"Golang Slice 介紹","slug":"introduction-to-slices-in-golang","date":"2019-11-13T01:57:11.000Z","updated":"2019-11-15T08:50:11.862Z","comments":true,"path":"2019/11/13/introduction-to-slices-in-golang/","link":"","permalink":"https://calvertyang.github.io/2019/11/13/introduction-to-slices-in-golang/","excerpt":"原文：CalliCoder — Introduction to Slices in Golang Slice 是陣列的一部分。Slice 建構在陣列之上，與陣列相比提供了更多功能、靈活性和便利性。 如同陣列一樣，Slice 是可索引的且具有長度。但與陣列不同的是，它們可以調整長度。 在內部，Slice 只是對底層陣列的參考。在本文中，我們將學習如何建立和使用 Slice，並了解它們背後的運作方式。","text":"原文：CalliCoder — Introduction to Slices in Golang Slice 是陣列的一部分。Slice 建構在陣列之上，與陣列相比提供了更多功能、靈活性和便利性。 如同陣列一樣，Slice 是可索引的且具有長度。但與陣列不同的是，它們可以調整長度。 在內部，Slice 只是對底層陣列的參考。在本文中，我們將學習如何建立和使用 Slice，並了解它們背後的運作方式。 宣告 Slice使用 []T 宣告型別為 T 的 Slice。舉例來說，以下是宣告 int 型別的 Slice 的方法： 12// Slice of type `int`var s []int Slice 的宣告就像陣列一樣，只不過我們在中括號 [] 中未指定任何長度。 建立和初始化 Slice1. 使用 Slice 定數建立 Slice你可以像這樣使用 Slice 定數來建立 Slice： 12// Creating a slice using a slice literalvar s = []int&#123;3, 5, 7, 9, 11, 13, 17&#125; 上述陳述式右側的表達式是 Slice 定數。Slice 定數的宣告與陣列定數一樣，不同之處在於沒有在中括號 [] 中指定任何長度。 當你使用 Slice 定數建立 Slice 時，它會先建立一個陣列，然後返回參考它的 Slice。 讓我們看一個完整範例： 1234567891011121314package mainimport \"fmt\"func main() &#123; // Creating a slice using a slice literal var s = []int&#123;3, 5, 7, 9, 11, 13, 17&#125; // Short hand declaration t := []int&#123;2, 4, 8, 16, 32, 64&#125; fmt.Println(\"s = \", s) fmt.Println(\"t = \", t)&#125; 123# Outputs = [3 5 7 9 11 13 17]t = [2 4 8 16 32 64] 2. 從陣列建立 Slice由於 Slice 是陣列的一部分，因此我們可以從陣列建立 Slice。 要從陣列 a 建立 Slice，我們指定兩個由冒號分隔的索引 low（下限）和 high（上限）： 12// Obtaining a slice from an array `a`a[low:high] 上面的表達式從陣列 a 選擇一個 Slice。Slice 的結果包含從索引 low 到 high 的所有元素，但不包括索引 high 的元素。 讓我們來看一個範例，讓事情更清晰明瞭： 12345678910111213package mainimport \"fmt\"func main() &#123; var a = [5]string&#123;\"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\"&#125; // Creating a slice from the array var s []string = a[1:4] fmt.Println(\"Array a = \", a) fmt.Println(\"Slice s = \", s)&#125; 12Array a = [Alpha Beta Gamma Delta Epsilon]Slice s = [Beta Gamma Delta] Slice 表達式中的 low 和 high 索引是非必要的。low 的預設值為 0，而 high 的預設值為 Slice 的長度。 123456789101112131415161718package mainimport \"fmt\"func main() &#123; a := [5]string&#123;\"C\", \"C++\", \"Java\", \"Python\", \"Go\"&#125; slice1 := a[1:4] slice2 := a[:3] slice3 := a[2:] slice4 := a[:] fmt.Println(\"Array a = \", a) fmt.Println(\"slice1 = \", slice1) fmt.Println(\"slice2 = \", slice2) fmt.Println(\"slice3 = \", slice3) fmt.Println(\"slice4 = \", slice4)&#125; 123456# OutputArray a = [C C++ Java Python Go]slice1 = [C++ Java Python]slice2 = [C C++ Java]slice3 = [Java Python Go]slice4 = [C C++ Java Python Go] 3. 從一個 Slice 建立另一個 Slice也可以透過劃分現有的 Slice 來建立 Slice。 1234567891011121314package mainimport \"fmt\"func main() &#123; cities := []string&#123;\"New York\", \"London\", \"Chicago\", \"Beijing\", \"Delhi\", \"Mumbai\", \"Bangalore\", \"Hyderabad\", \"Hong Kong\"&#125; asianCities := cities[3:] indianCities := asianCities[1:5] fmt.Println(\"cities = \", cities) fmt.Println(\"asianCities = \", asianCities) fmt.Println(\"indianCities = \", indianCities)&#125; 1234# Outputcities = [New York London Chicago Beijing Delhi Mumbai Bangalore Hyderabad Hong Kong]asianCities = [Beijing Delhi Mumbai Bangalore Hyderabad Hong Kong]indianCities = [Delhi Mumbai Bangalore Hyderabad] 修改 SliceSlice 是參考型別。它們參考到底層陣列。修改 Slice 的元素將會修改參考陣列中的相應元素。引用相同陣列的其他 Slice 也會看到這些修改。 1234567891011121314151617181920212223242526package mainimport \"fmt\"func main() &#123; a := [7]string&#123;\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"&#125; slice1 := a[1:] slice2 := a[3:] fmt.Println(\"------- Before Modifications -------\") fmt.Println(\"a = \", a) fmt.Println(\"slice1 = \", slice1) fmt.Println(\"slice2 = \", slice2) slice1[0] = \"TUE\" slice1[1] = \"WED\" slice1[2] = \"THU\" slice2[1] = \"FRIDAY\" fmt.Println(\"\\n-------- After Modifications --------\") fmt.Println(\"a = \", a) fmt.Println(\"slice1 = \", slice1) fmt.Println(\"slice2 = \", slice2)&#125; 12345678910# Output------- Before Modifications -------a = [Mon Tue Wed Thu Fri Sat Sun]slice1 = [Tue Wed Thu Fri Sat Sun]slice2 = [Thu Fri Sat Sun]-------- After Modifications --------a = [Mon TUE WED THU FRIDAY Sat Sun]slice1 = [TUE WED THU FRIDAY Sat Sun]slice2 = [THU FRIDAY Sat Sun] Slice 的長度和容量Slice 由三樣東西組成： 指向底層陣列的指標（參考）。 Slice 包含的陣列部分的長度。 容量（該部分可以增加到的最大大小） 讓我們用以下陣列和從中得到的 Slice 作為範例： 12var a = [6]int&#123;10, 20, 30, 40, 50, 60&#125;var s = [1:4] 這是上面範例中的 Slice s 的表示方式： Slice 的長度是 Slice 中元素的數量，在上面的範例中為 3。 容量是從 Slice 中第一個元素開始的底層陣列中的元素數量，在上面的範例中為 5。 你可以使用內建函數 len() 和 cap() 找到 Slice 的長度和容量： 12345678910package mainimport \"fmt\"func main() &#123; a := [6]int&#123;10, 20, 30, 40, 50, 60&#125; s := a[1:4] fmt.Printf(\"s = %v, len = %d, cap = %d\\n\", s, len(s), cap(s))&#125; 12# Outputs = [20 30 40], len = 3, cap = 5 透過重新劃分，可以將 Slice 的長度擴充到其容量。任何嘗試將其長度擴充到可用容量之外的行為將導致執行時期錯誤。 查看以下範例來了解如何重新劃分指定 Slice 來更改其長度和容量： 123456789101112131415161718192021package mainimport \"fmt\"func main() &#123; s := []int&#123;10, 20, 30, 40, 50, 60, 70, 80, 90, 100&#125; fmt.Println(\"Original Slice\") fmt.Printf(\"s = %v, len = %d, cap = %d\\n\", s, len(s), cap(s)) s = s[1:5] fmt.Println(\"\\nAfter slicing from index 1 to 5\") fmt.Printf(\"s = %v, len = %d, cap = %d\\n\", s, len(s), cap(s)) s = s[:8] fmt.Println(\"\\nAfter extending the length\") fmt.Printf(\"s = %v, len = %d, cap = %d\\n\", s, len(s), cap(s)) s = s[2:] fmt.Println(\"\\nAfter dropping the first two elements\") fmt.Printf(\"s = %v, len = %d, cap = %d\\n\", s, len(s), cap(s))&#125; 123456789101112# OutputOriginal Slices = [10 20 30 40 50 60 70 80 90 100], len = 10, cap = 10After slicing from index 1 to 5s = [20 30 40 50], len = 4, cap = 9After extending the lengths = [20 30 40 50 60 70 80 90], len = 8, cap = 9After dropping the first two elementss = [40 50 60 70 80 90], len = 6, cap = 7 使用內建 make() 函數建立 Slice現在我們知道了 Slice 的長度和容量。讓我們來看看建立 Slice 的另一種方法。 Golang 提供了一個名為 make() 的函數來建立 Slice。以下是 make() 函數的簽名： 1func make([]T, len, cap) []T make 函數需要型別、長度和容量（非必要）。它分配了長度與給定容量相同的底層陣列，並返回參考該陣列的 Slice。 123456789package mainimport \"fmt\"func main() &#123; // Creates an array of size 10, slices it till index 5, and returns the slice reference s := make([]int, 5, 10) fmt.Printf(\"s = %v, len = %d, cap = %d\\n\", s, len(s), cap(s))&#125; 12# Outputs = [0 0 0 0 0], len = 5, cap = 10 make() 函數中的容量參數是非必要的。如果省略，則預設為指定的長度： 123456789package mainimport \"fmt\"func main() &#123; // Creates an array of size 5, and returns a slice reference to it s := make([]int, 5) fmt.Printf(\"s = %v, len = %d, cap = %d\\n\", s, len(s), cap(s))&#125; 12# Outputs = [0 0 0 0 0], len = 5, cap = 5 Slice 的零值Slice 的零值是 nil。具有零值的 Slice 沒有任何底層陣列，且長度和容量為 0： 123456789101112package mainimport \"fmt\"func main() &#123; var s []int fmt.Printf(\"s = %v, len = %d, cap = %d\\n\", s, len(s), cap(s)) if s == nil &#123; fmt.Println(\"s is nil\") &#125;&#125; 123# Outputs = [], len = 0, cap = 0s is nil Slice 函數1. copy() 函數：複製 Slicecopy() 函數將元素從一個 Slice 複製到另一個 Slice。它的簽名看起來像樣這樣： 1func copy(dst, src []T) int 它需要兩個 Slice：來源 Slice 和目的 Slice。然後它會將元素從來源複製到目的，並返回複製的元素數量。 複製的元素數量將是 len(src) 和 len(dst) 的最小值。 1234567891011121314package mainimport \"fmt\"func main() &#123; src := []string&#123;\"Sublime\", \"VSCode\", \"IntelliJ\", \"Eclipse\"&#125; dest := make([]string, 2) numElementsCopied := copy(dest, src) fmt.Println(\"src = \", src) fmt.Println(\"dest = \", dest) fmt.Println(\"Number of elements copied from src to dest = \", numElementsCopied)&#125; 1234# Outputsrc = [Sublime VSCode IntelliJ Eclipse]dest = [Sublime VSCode]Number of elements copied from src to dest = 2 2. append() 函數：附加到 Sliceappend() 函數在給定的 Slice 結尾附加新元素。以下是 append 函數的簽名。 1func append(s []T, x ...T) []T 它需要一個 Slice 和可變數量的參數 x …T。然後，它返回一個新的 Slice ，其中包含給定 Slice 中的所有元素及新元素。 如果給定的 Slice 沒有足夠的容量來容納新元素，則將分配具有更大容量的新底層陣列。現有 Slice 的底層陣列中的所有元素都將複製到新陣列，然後附加新元素。 但是，如果 Slice 具有足夠的容量來容納新元素，則 append() 函數將再使用其底層陣列並將新元素附加到同一陣列中。 讓我們來看一個範例，以更好地理解： 123456789101112131415package mainimport \"fmt\"func main() &#123; slice1 := []string&#123;\"C\", \"C++\", \"Java\"&#125; slice2 := append(slice1, \"Python\", \"Ruby\", \"Go\") fmt.Printf(\"slice1 = %v, len = %d, cap = %d\\n\", slice1, len(slice1), cap(slice1)) fmt.Printf(\"slice2 = %v, len = %d, cap = %d\\n\", slice2, len(slice2), cap(slice2)) slice1[0] = \"C#\" fmt.Println(\"\\nslice1 = \", slice1) fmt.Println(\"slice2 = \", slice2)&#125; 123456# Outputslice1 = [C C++ Java], len = 3, cap = 3slice2 = [C C++ Java Python Ruby Go], len = 6, cap = 6slice1 = [C# C++ Java]slice2 = [C C++ Java Python Ruby Go] 在上面的範例中，由於 slice1 的容量為 3，它無法容納更多的元素。因此，當我們對它附加更多元素時，新的底層陣列分配了更大的容量。 所以，如果你修改 slice1，slice2 將不會看到這些更改，因為它參考了另一個陣列。 但是，如果 slice1 具有足夠的容量來容納新元素呢？ 嗯，在那種情況下，將不會分配新的陣列，並且會將元素附加到同一底層陣列中。 同樣地，在這種情況下，對 slice1 的更改也會影響 slice2，因為兩者都參考相同的底層陣列。 在以下範例中對此進行了示範： 1234567891011121314151617package mainimport \"fmt\"func main() &#123; slice1 := make([]string, 3, 10) copy(slice1, []string&#123;\"C\", \"C++\", \"Java\"&#125;) slice2 := append(slice1, \"Python\", \"Ruby\", \"Go\") fmt.Printf(\"slice1 = %v, len = %d, cap = %d\\n\", slice1, len(slice1), cap(slice1)) fmt.Printf(\"slice2 = %v, len = %d, cap = %d\\n\", slice2, len(slice2), cap(slice2)) slice1[0] = \"C#\" fmt.Println(\"\\nslice1 = \", slice1) fmt.Println(\"slice2 = \", slice2)&#125; 123456# Outputslice1 = [C C++ Java], len = 3, cap = 10slice2 = [C C++ Java Python Ruby Go], len = 6, cap = 10slice1 = [C# C++ Java]slice2 = [C# C++ Java Python Ruby Go] 附加到具有零值的 Slice當你將值附加到 nil 的 Slice，它分配一個新的 Slice，並返回新 Slice 的參考。 123456789101112package mainimport \"fmt\"func main() &#123; var s []string // Appending to a nil slice s = append(s, \"Cat\", \"Dog\", \"Lion\", \"Tiger\") fmt.Printf(\"s = %v, len = %d, cap = %d\\n\", s, len(s), cap(s))&#125; 12# Outputs = [Cat Dog Lion Tiger], len = 4, cap = 4 將一個 Slice 附加到另一個 Slice你可以使用 ... 運算子將一個 Slice 直接附加到另一個 Slice。該運算元將 Slice 展開為參數列表。以下的範例示範了其用法： 1234567891011121314package mainimport \"fmt\"func main() &#123; slice1 := []string&#123;\"Jack\", \"John\", \"Peter\"&#125; slice2 := []string&#123;\"Bill\", \"Mark\", \"Steve\"&#125; slice3 := append(slice1, slice2...) fmt.Println(\"slice1 = \", slice1) fmt.Println(\"slice2 = \", slice2) fmt.Println(\"After appending slice1 &amp; slice2 = \", slice3)&#125; 1234# Outputslice1 = [Jack John Peter]slice2 = [Bill Mark Steve]After appending slice1 &amp; slice2 = [Jack John Peter Bill Mark Steve] Slice 中的 SliceSlice 可以是任何型別。它們還可以包含其他 Slice。以下範例建立了 Slice 中的 Slice： 123456789101112131415package mainimport \"fmt\"func main() &#123; s := [][]string&#123; &#123;\"India\", \"China\"&#125;, &#123;\"USA\", \"Canada\"&#125;, &#123;\"Switzerland\", \"Germany\"&#125;, &#125; fmt.Println(\"Slice s = \", s) fmt.Println(\"length = \", len(s)) fmt.Println(\"capacity = \", cap(s))&#125; 1234# OutputSlice s = [[India China] [USA Canada] [Switzerland Germany]]length = 3capacity = 3 迭代 Slice你可以用與迭代陣列相同的方式迭代 Slice。以下是迭代 Slice 的兩種方法： 1. 使用 for 迴圈迭代 Slice1234567891011package mainimport \"fmt\"func main() &#123; countries := []string&#123;\"India\", \"America\", \"Russia\", \"England\"&#125; for i := 0; i &lt; len(countries); i++ &#123; fmt.Println(countries[i]) &#125;&#125; 12345# OutputIndiaAmericaRussiaEngland 2. 使用 range 形式的 for 迴圈迭代 Slice1234567891011package mainimport \"fmt\"func main() &#123; primeNumbers := []int&#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29&#125; for index, number := range primeNumbers &#123; fmt.Printf(\"PrimeNumber(%d) = %d\\n\", index+1, number) &#125;&#125; 1234567891011# OutputPrimeNumber(1) = 2PrimeNumber(2) = 3PrimeNumber(3) = 5PrimeNumber(4) = 7PrimeNumber(5) = 11PrimeNumber(6) = 13PrimeNumber(7) = 17PrimeNumber(8) = 19PrimeNumber(9) = 23PrimeNumber(10) = 29 使用空白識別符號從 range 形式的 for 迴圈中忽略 indexrange 形式的 for 迴圈在每次迭代中為你提供 index 和該索引處的 value。如果你不想使用 index，可以使用底線 _ 將其丟棄。 底線（_）稱為空白識別字元。它用於告訴編譯器我們不需要此數值。 1234567891011121314package mainimport \"fmt\"func main() &#123; numbers := []float64&#123;3.5, 7.4, 9.2, 5.4&#125; sum := 0.0 for _, number := range numbers &#123; sum += number &#125; fmt.Printf(\"Total Sum = %.2f\\n\", sum)&#125; 12# OutputTotal Sum = 25.50 結論在本文中，你學習了如何建立 Slice、Slice 內部如何運作，以及如何使用內建函數 copy() 和 append() 來增加 Slice。 在下一篇文章中，我們將學習另一個非常有用的資料結構：map。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://calvertyang.github.io/tags/Golang/"}]},{"title":"在 Golang 中使用陣列","slug":"working-with-arrays-in-golang","date":"2019-11-12T07:46:25.000Z","updated":"2019-11-15T08:50:11.881Z","comments":true,"path":"2019/11/12/working-with-arrays-in-golang/","link":"","permalink":"https://calvertyang.github.io/2019/11/12/working-with-arrays-in-golang/","excerpt":"原文：CalliCoder — Working with Arrays in Golang 陣列是固定長度的相同型別元素的集合。陣列的元素按順序儲存，並且可以使用它們的 index 來存取。","text":"原文：CalliCoder — Working with Arrays in Golang 陣列是固定長度的相同型別元素的集合。陣列的元素按順序儲存，並且可以使用它們的 index 來存取。 在 Golang 中宣告陣列你可以像這樣宣告一個長度為 n 且型別為 T 的陣列： 1var a[n]T 舉例來說，以下是如何宣告一個長度為 10 的整數陣列： 12// An array of 10 integersvar a[10]int 現在，讓我們看一個完整範例： 1234567891011121314package mainimport \"fmt\"func main() &#123; var x [5]int // An array of 5 integers fmt.Println(x) var y [8]string // An array of 8 strings fmt.Println(y) var z [3]complex128 // An array of 3 complex numbers fmt.Println(z)&#125; 1234# Output[0 0 0 0 0][ ][(0+0i) (0+0i) (0+0i)] 預設情況下，所有陣列元素皆使用與陣列型別一致的零值初始化。 舉例來說，如果我們宣告一個整數陣列，則所有元素都將以 0 初始化。如果我們宣告一個字串陣列，則所有元素都將以空字串 &quot;&quot; 初始化，依此類推。 透過索引存取陣列元素陣列的元素按順序儲存，可以透過它們的 index 存取。index 從零開始，結束於 length - 1。 123456789101112131415package mainimport \"fmt\"func main() &#123; var x [5]int // An array of 5 integers x[0] = 100 x[1] = 101 x[3] = 103 x[4] = 105 fmt.Printf(\"x[0] = %d, x[1] = %d, x[2] = %d\\n\", x[0], x[1], x[2]) fmt.Println(\"x = \", x)&#125; 123# Outputx[0] = 100, x[1] = 101, x[2] = 0x = [100 101 0 103 105] 在上面的範例中，由於我們沒有分派 x[2] 任何值，因此它的值為 0（整數的零值）。 使用陣列定數初始化陣列你可以像這樣同時宣告並初始化陣列： 12// Declaring and initializing an array at the same timevar a = [5]int&#123;2, 4, 6, 8, 10&#125; 上面表達式右側的陳述式稱為陣列定數。 注意，我們不需要像 var a [5]int 中那樣指定變數 a 的型別，因為編譯器可以從右側的表達式自動推斷型別。 你也可以使用 Golang 的簡短變數宣告來宣告和初始化陣列。上面的陣列宣告也可以在任何函數內撰寫如下： 12// Short hand declarationa := [5]int&#123;2, 4, 6, 8, 10&#125; 這是一個完整範例： 123456789101112131415161718package mainimport \"fmt\"func main() &#123; // Declaring and initializing an array at the same time var a = [5]int&#123;2, 4, 6, 8, 10&#125; fmt.Println(a) // Short declaration for declaring and initializing an array b := [5]int&#123;2, 4, 6, 8, 10&#125; fmt.Println(b) // You don't need to initialize all the elements of the array. // The un-initialized elements will be assigned the zero value of the corresponding array type c := [5]int&#123;2&#125; fmt.Println(c)&#125; 1234# Output[2 4 6 8 10][2 4 6 8 10][2 0 0 0 0] 讓 Go 編譯器推斷陣列的長度你還可以從陣列的初始化表達式中省略長度宣告，並讓編譯器為你計算元素的數量： 123456789package mainimport \"fmt\"func main() &#123; // Letting Go compiler infer the length of the array a := [...]int&#123;3, 5, 7, 9, 11, 13, 17&#125; fmt.Println(a)&#125; 12# Output[3 5 7 9 11 13 17] 探索有關 Golang 陣列的更多資訊 陣列的長度是其型別的一部分 陣列的長度是其型別的一部分。因此陣列 a[5]int 和 a[10]int 是完全不同的型別，且你不能將一個分派給另一個。 也就是說你無法調整陣列長度，因為調整陣列的長度將意味著更改其型別，而你無法在 Golang 中更改變數的型別。 123456package mainfunc main() &#123; var a = [5]int&#123;3, 5, 7, 9, 11&#125; var b [10]int = a // Error, a and b are distinct types&#125; Golang 中的陣列是數值型別 Golang 中的陣列是數值型別，不像其他語言，如 C、C++ 和 Java 的陣列是參考型別。 這意味著當你將陣列賦值給新變數或將陣列傳遞給函數時，將複製整個陣列。因此，如果你對此複製的陣列進行任何更改，原始陣列將不會受到影響且保持不變。 這有一個範例： 12345678910111213package mainimport \"fmt\"func main() &#123; a1 := [5]string&#123;\"English\", \"Japanese\", \"Spanish\", \"French\", \"Hindi\"&#125; a2 := a1 // A copy of the array `a1` is assigned to `a2` a2[1] = \"German\" fmt.Println(\"a1 = \", a1) // The array `a1` remains unchanged fmt.Println(\"a2 = \", a2)&#125; 123# Outputa1 = [English Japanese Spanish French Hindi]a2 = [English German Spanish French Hindi] 在 Golang 中迭代陣列你可以像這樣使用 for 迴圈迭代陣列： 1234567891011package mainimport \"fmt\"func main() &#123; names := [3]string&#123;\"Mark Zuckerberg\", \"Bill Gates\", \"Larry Page\"&#125; for i := 0; i &lt; len(names); i++ &#123; fmt.Println(names[i]) &#125;&#125; 1234# OutputMark ZuckerbergBill GatesLarry Page 上面的範例中，len() 函數用於找出陣列的長度。 讓我們來看另一個範例。在下面的範例中，我們透過迭代陣列，將元素逐一加到變數 sum 中，找出陣列所有元素的總和： 1234567891011121314package mainimport \"fmt\"func main() &#123; a := [4]float64&#123;3.5, 7.2, 4.8, 9.5&#125; sum := float64(0) for i := 0; i &lt; len(a); i++ &#123; sum = sum + a[i] &#125; fmt.Printf(\"Sum of all the elements in array %v = %f\\n\", a, sum)&#125; 12# OutputSum of all the elements in array [3.5 7.2 4.8 9.5] = 25.000000 使用 range 迭代陣列Golang 使用 range 運算子提供了一種更強大的 for 迴圈形式。以下是如何將 range 運算子與 for 迴圈一起使用來迭代陣列： 1234567891011package mainimport \"fmt\"func main() &#123; daysOfWeek := [7]string&#123;\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"&#125; for index, value := range daysOfWeek &#123; fmt.Printf(\"Day %d of week = %s\\n\", index, value) &#125;&#125; 12345678# OutputDay 0 of week = MonDay 1 of week = TueDay 2 of week = WedDay 3 of week = ThuDay 4 of week = FriDay 5 of week = SatDay 6 of week = Sun 現在，讓我們使用 range 形式的 for 迴圈來撰寫一個與普通 for 迴圈相同的 sum 範例： 1234567891011121314package mainimport \"fmt\"func main() &#123; a := [4]float64&#123;3.5, 7.2, 4.8, 9.5&#125; sum := float64(0) for index, value := range a &#123; sum = sum + value &#125; fmt.Printf(\"Sum of all the elements in array %v = %f\", a, sum)&#125; 當你執行上面的程式時，它會產生以下錯誤： 12# Output./array_iteration_range.go:9:13: index declared and not used Go 編譯器不允許建立從未使用過的變數。你可以透過使用 _（底線） 代替 index 來解決此問題： 1234567891011121314package mainimport \"fmt\"func main() &#123; a := [4]float64&#123;3.5, 7.2, 4.8, 9.5&#125; sum := float64(0) for _, value := range a &#123; sum = sum + value &#125; fmt.Printf(\"Sum of all the elements in array %v = %f\", a, sum)&#125; 底線（_）用於告訴編譯器我們不需要此變數。上面的程式現在可以成功執行並輸出陣列的總和： 12# OutputSum of all the elements in array [3.5 7.2 4.8 9.5] = 25.000000 Golang 中的多維陣列到目前為止，我們在本文中建立的所有陣列都是一維的。你也可以在 Golang 中建立多維陣列。 以下範例示範如何建立多維陣列： 1234567891011121314151617181920package mainimport \"fmt\"func main() &#123; a := [2][2]int&#123; &#123;3, 5&#125;, &#123;7, 9&#125;, // This trailing comma is mandatory &#125; fmt.Println(a) // Just like 1D arrays, you don't need to initialize all the elements in a multi-dimensional array. // Un-initialized array elements will be assigned the zero value of the array type. b := [3][4]float64&#123; &#123;1, 3&#125;, &#123;4.5, -3, 7.4, 2&#125;, &#123;6, 2, 11&#125;, &#125; fmt.Println(b)&#125; 123# Output[[3 5] [7 9]][[1 3 0 0] [4.5 -3 7.4 2] [6 2 11 0]] 結論陣列很有用，但由於其固定長度而造成的限制而有些不靈活。這就是為什麼 Go 提供了另一個名為 Slice 的資料結構，該資料結構建構在陣列之上，並提供了我們所需的所有靈活性。在下一篇文章中，我們將學習 Slice。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://calvertyang.github.io/tags/Golang/"}]},{"title":"Golang 函數介紹","slug":"introduction-to-functions-in-golang","date":"2019-11-11T08:31:05.000Z","updated":"2019-11-15T08:50:11.860Z","comments":true,"path":"2019/11/11/introduction-to-functions-in-golang/","link":"","permalink":"https://calvertyang.github.io/2019/11/11/introduction-to-functions-in-golang/","excerpt":"原文：CalliCoder — Introduction to Functions in Golang 函數是一個程式碼區塊，它接受一些輸入，對該輸入進行一些處理，並產生一些輸出。 函數可以協助你將程式劃分為可重複使用的小段程式碼。它們提高了程式的可讀性、可維護性和可測試性。","text":"原文：CalliCoder — Introduction to Functions in Golang 函數是一個程式碼區塊，它接受一些輸入，對該輸入進行一些處理，並產生一些輸出。 函數可以協助你將程式劃分為可重複使用的小段程式碼。它們提高了程式的可讀性、可維護性和可測試性。 在 Golang 宣告和呼叫函數在 Golang 中，我們使用 func 關鍵字宣告函數。函數具有一個名稱、以逗號分隔的輸入參數及其型別的列表、結果型別和主體。 以下是一個簡單函數 avg 的範例，該函數接受兩個型別為 float64 的輸入參數，並返回輸入的平均值。結果也是 float64 型別： 123func avg(x float64, y float64) float64 &#123; return (x + y) / 2&#125; 現在，呼叫函數非常簡單。你只需要像這樣將所需數量的參數傳遞給函數： 1avg(6.56, 13.44) 這是一個完整範例： 12345678910111213141516package mainimport \"fmt\"func avg(x float64, y float64) float64 &#123; return (x + y) / 2&#125;func main() &#123; x := 5.75 y := 6.25 result := avg(x, y) fmt.Printf(\"Average of %.2f and %.2f = %.2f\\n\", x, y, result)&#125; 12# OutputAverage of 5.75 and 6.25 = 6.00 函數參數和返回型別是非必要的輸入參數和返回型別對於函數是非必要的。可以宣告一個沒有任何輸入和輸出的函數。 main() 函數是此類函數的範例： 12func main() &#123;&#125; 這是另一個範例： 123func sayHello() &#123; fmt.Println(\"Hello, World\")&#125; 你只需要為同一型別的多個連續參數指定一次型別 如果一個函數具有兩個或更多個相同型別的連續參數，那麼只需為該型別的最後一個參數指定一次即可。 舉例來說，我們也可以像這樣宣告我們在上一節中看到的 avg 函數： 12func avg(x, y float64) float64 &#123; &#125;// Same as - func avg(x float64, y float64) float64 &#123; &#125; 這是另一個範例： 12func printPersonDetails(firstName, lastName string, age int) &#123; &#125;// Same as - func printPersonDetails(firstName string, lastName string, age int) &#123; &#125; 具有多個返回值的函數Go 函數能夠返回多個值。沒錯！大多數程式語言都不支援此功能。但 Go 是不同的。 假設你要建立一個函數，該函數接受股票的_先前價格和目前價格_，並返回價格變動的金額和百分比。 以下是你如何在 Go 實作這種函數的方法： 12345func getStockPriceChange(prevPrice, currentPrice float64) (float64, float64) &#123; change := currentPrice - prevPrice percentChange := (change / prevPrice) * 100 return change, percentChange&#125; 很間單，對吧？你只需要在括號內用逗號分隔指定的返回型別，然後從函數中返回多個逗號分隔的值即可。 讓我們來看一個具有 main() 函數的完整範例： 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"math\")func getStockPriceChange(prevPrice, currentPrice float64) (float64, float64) &#123; change := currentPrice - prevPrice percentChange := (change / prevPrice) * 100 return change, percentChange&#125;func main() &#123; prevStockPrice := 75000.0 currentStockPrice := 100000.0 change, percentChange := getStockPriceChange(prevStockPrice, currentStockPrice) if change &lt; 0 &#123; fmt.Printf(\"The Stock Price decreased by $%.2f which is %.2f%% of the prev price\\n\", math.Abs(change), math.Abs(percentChange)) &#125; else &#123; fmt.Printf(\"The Stock Price increased by $%.2f which is %.2f%% of the prev price\\n\", change, percentChange) &#125;&#125; 12# OutputThe Stock Price increased by $25000.00 which is 33.33% of the prev price 從函數返回錯誤值Golang 中經常使用多個返回值來從函數返回錯誤與結果。 我們來看一個範例：如果 prevPrice 是 0，則在上一節看到的 getStockPriceChange 函數將返回 ±Inf（無限大）。如果你想返回錯誤，則可以透過增加一個型別為 error 的返回值，並像這樣返回錯誤值： 123456789func getStockPriceChangeWithError(prevPrice, currentPrice float64) (float64, float64, error) &#123; if prevPrice == 0 &#123; err := errors.New(\"Previous price cannot be zero\") return 0, 0, err &#125; change := currentPrice - prevPrice percentChange := (change / prevPrice) * 100 return change, percentChange, nil&#125; error 型別是 Golang 中內建的型別。Go 程式使用 error 值來顯示異常情況。如果你現在不了解 error 請別擔心。你將在以後的文章中了解更多有關錯誤處理的資訊。 以下是使用 main() 函數示範上述觀念的完整範例： 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"errors\" \"fmt\" \"math\")func getStockPriceChangeWithError(prevPrice, currentPrice float64) (float64, float64, error) &#123; if prevPrice == 0 &#123; err := errors.New(\"Previous price cannot be zero\") return 0, 0, err &#125; change := currentPrice - prevPrice percentChange := (change / prevPrice) * 100 return change, percentChange, nil&#125;func main() &#123; prevStockPrice := 0.0 currentStockPrice := 100000.0 change, percentChange, err := getStockPriceChangeWithError(prevStockPrice, currentStockPrice) if err != nil &#123; fmt.Println(\"Sorry! There was an error: \", err) &#125; else &#123; if change &lt; 0 &#123; fmt.Printf(\"The Stock Price decreased by $%.2f which is %.2f%% of the prev price\\n\", math.Abs(change), math.Abs(percentChange)) &#125; else &#123; fmt.Printf(\"The Stock Price increased by $%.2f which is %.2f%% of the prev price\\n\", change, percentChange) &#125; &#125;&#125; 12# OutputSorry! There was an error: Previous price cannot be zero 具有命名返回值的函數在 Golang 中，函數的返回值可以被命名。命名返回值的行為就像你在函數頂部定義它們一樣。 讓我們用命名的返回值重寫在上一節看到的 getStockPriceChange 函數： 123456// Function with named return valuesfunc getNamedStockPriceChange(prevPrice, currentPrice float64) (change, percentChange float64) &#123; change = currentPrice - prevPrice percentChange = (change / prevPrice) * 100 return change, percentChange&#125; 注意我們如何在函數主體中將 :=（簡短宣告）更改為 =（賦值）。這是因為 Go 本身定義了所有命名的返回值，並讓它們可以在函數中使用。由於它們已經定義，因此你無法使用簡短宣告再次定義它們。 命名返回值允許你使用所謂的裸返回（不帶任何參數的 return 陳述式）。當你指定一個不帶任何參數的 return 陳述式時，預設情況下它會返回命名的返回值。因此，你也可以像這樣撰寫以上功能： 123456// Function with named return values and naked returnfunc getNamedStockPriceChange(prevPrice, currentPrice float64) (change, percentChange float64) &#123; change = currentPrice - prevPrice percentChange = (change / prevPrice) * 100 return&#125; 讓我們在帶有 main() 函數的完整範例中使用上述函數，並驗證輸出： 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"math\")func getNamedStockPriceChange(prevPrice, currentPrice float64) (change, percentChange float64) &#123; change = currentPrice - prevPrice percentChange = (change / prevPrice) * 100 return&#125;func main() &#123; prevStockPrice := 100000.0 currentStockPrice := 90000.0 change, percentChange := getNamedStockPriceChange(prevStockPrice, currentStockPrice) if change &lt; 0 &#123; fmt.Printf(\"The Stock Price decreased by $%.2f which is %.2f%% of the prev price\\n\", math.Abs(change), math.Abs(percentChange)) &#125; else &#123; fmt.Printf(\"The Stock Price increased by $%.2f which is %.2f%% of the prev price\\n\", change, percentChange) &#125;&#125; 12# OutputThe Stock Price decreased by $10000.00 which is 10.00% of the prev price 命名返回值提高了函數的可讀性。使用有意義的名稱可讓函數的使用者僅透過查看其簽名即可知道函數將返回什麼。 裸返回陳述式適合較短的函數。但如果你的函數比較長，請不要使用它們。它們可能會損害可讀性。你應該在更長的函數中明確地指定返回值。 空白識別符號有時候你可能想忽略返回多個值的函數的某些結果。 舉例來說，假設你在使用我們上一節定義的 getStockPriceChange 函數，但你只對價格變動感興趣，而不是變動百分比。 現在，你可以像這樣宣告區域變數並儲存從函數返回的所有值： 1change, percentChange := getStockPriceChange(prevStockPrice, currentStockPrice) 但是在那種情況下，你將被迫使用 percentChange 變數，因為 Go 不允許建立你從未使用過的變數。 那有什麼解決方案？嗯，你可以改用_空白識別符號_： 1change, _ := getStockPriceChange(prevStockPrice, currentStockPrice) 空白識別符號用來告訴 Go 你不需要這個值。以下範例示範了此觀念： 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"math\")func getStockPriceChange(prevPrice, currentPrice float64) (float64, float64) &#123; change := currentPrice - prevPrice percentChange := (change / prevPrice) * 100 return change, percentChange&#125;func main() &#123; prevStockPrice := 80000.0 currentStockPrice := 120000.0 change, _ := getStockPriceChange(prevStockPrice, currentStockPrice) if change &lt; 0 &#123; fmt.Printf(\"The Stock Price decreased by $%.2f\\n\", math.Abs(change)) &#125; else &#123; fmt.Printf(\"The Stock Price increased by $%.2f\\n\", change) &#125;&#125; 12# OutputThe Stock Price increased by $40000.00 結論在本文中，你學習了如何在 Golang 中定義和呼叫函數、如何定義具有多個返回值和命名返回值的函數、如何從函數返回錯誤，以及如何使用空白識別符號。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://calvertyang.github.io/tags/Golang/"}]},{"title":"Golang 流程控制陳述式：if、switch 與 for","slug":"golang-control-flow-statements","date":"2019-11-11T00:59:00.000Z","updated":"2019-11-15T08:50:11.882Z","comments":true,"path":"2019/11/11/golang-control-flow-statements/","link":"","permalink":"https://calvertyang.github.io/2019/11/11/golang-control-flow-statements/","excerpt":"原文：CalliCoder — Golang Control Flow Statements: If, Switch and For if 陳述式if 陳述式用於根據給定的條件，決定是否應執行程式碼區塊。 以下是 Golang 中 if 陳述式的語法： 123if(condition) &#123; // Code to be executed if the condition is true.&#125; 這裡有個簡單的範例： 12345678910package mainimport \"fmt\"func main() &#123; var x = 25 if x%5 == 0 &#123; fmt.Printf(\"%d is a multiple of 5\\n\", x) &#125;&#125; 12# Output25 is a multiple of 5","text":"原文：CalliCoder — Golang Control Flow Statements: If, Switch and For if 陳述式if 陳述式用於根據給定的條件，決定是否應執行程式碼區塊。 以下是 Golang 中 if 陳述式的語法： 123if(condition) &#123; // Code to be executed if the condition is true.&#125; 這裡有個簡單的範例： 12345678910package mainimport \"fmt\"func main() &#123; var x = 25 if x%5 == 0 &#123; fmt.Printf(\"%d is a multiple of 5\\n\", x) &#125;&#125; 12# Output25 is a multiple of 5 注意，你可以在 Golang 中的 if 陳述式省略 ()，但大括號 {} 是必需的： 1234var y = -1if y &lt; 0 &#123; fmt.Printf(\"%d is negative\\n\", y)&#125; 如下所示，你可以使用捷徑運算子 &amp;&amp; 和 || 來組合多個條件： 1234var age = 21if age &gt;= 17 &amp;&amp; age &lt;= 30 &#123; fmt.Println(\"My Age is between 17 and 30\")&#125; if-Else 陳述式if 陳述式可以與 else 區塊結合使用。如果 if 陳述式中指定的條件不成立，則執行 else 區塊。 12345if condition &#123; // code to be executed if the condition is true&#125; else &#123; // code to be executed if the condition is false&#125; 這裡有個簡單的範例： 123456789101112package mainimport \"fmt\"func main() &#123; var age = 18 if age &gt;= 18 &#123; fmt.Println(\"You're eligible to vote!\") &#125; else &#123; fmt.Println(\"You're not eligible to vote!\") &#125;&#125; 12# OutputYou&apos;re eligible to vote! if-else-if 鏈if 陳述式也可以包含多個 else if 部分，從而構成一系列條件，例如： 12345678910111213141516package mainimport \"fmt\"func main() &#123; var BMI = 21.0 if BMI &lt; 18.5 &#123; fmt.Println(\"You are underweight\"); &#125; else if BMI &gt;= 18.5 &amp;&amp; BMI &lt; 25.0 &#123; fmt.Println(\"Your weight is normal\"); &#125; else if BMI &gt;= 25.0 &amp;&amp; BMI &lt; 30.0 &#123; fmt.Println(\"You're overweight\") &#125; else &#123; fmt.Println(\"You're obese\") &#125;&#125; 12# OutputYour weight is normal if 搭配簡短宣告Golang 中的 if 陳述式還可以在條件表達式之前包含一個簡短宣告： 123if n := 10; n%2 == 0 &#123; fmt.Printf(\"%d is even\\n\", n)&#125; 在簡短宣告中宣告的變數僅可在 if 區塊及它的 else 或 else-if 分支內使用： 12345if n := 15; n%2 == 0 &#123; fmt.Printf(\"%d is even\\n\", n)&#125; else &#123; fmt.Printf(\"%d is odd\\n\", n)&#125; 注意，如果你使用簡短陳述式，則不能使用括號。因此，以下程式碼將產生語法錯誤： 1234// You can't use parentheses when `if` contains a short statementif (n := 15; n%2 == 0) &#123; // Syntax Error&#125; switch 陳述式Switch 陳述式採用表達式並將其與可能的條件清單匹配。找到匹配項目後，它會執行指定匹配條件區塊內的程式碼。 這裡有個簡單的 switch 陳述式範例： 1234567891011121314151617181920212223package mainimport \"fmt\"func main() &#123; var dayOfWeek = 6 switch dayOfWeek &#123; case 1: fmt.Println(\"Monday\") case 2: fmt.Println(\"Tuesday\") case 3: fmt.Println(\"Wednesday\") case 4: fmt.Println(\"Thursday\") case 5: fmt.Println(\"Friday\") case 6: &#123; fmt.Println(\"Saturday\") fmt.Println(\"Weekend. Yaay!\") &#125; case 7: &#123; fmt.Println(\"Sunday\") fmt.Println(\"Weekend. Yaay!\") &#125; default: fmt.Println(\"Invalid day\") &#125;&#125; 123# OutputSaturdayWeekend. Yaay! Go 會從上到下逐一評估所有 switch 條件，直到條件成功為止。它會執行該指定條件區塊內的程式碼，然後停止（不會再評估其他條件）。 與其他語言如 C、C++ 和 Java 相反的是，你需要明確地在每個條件區塊之後插入一個 break 陳述式，來停止對後續條件的評估。 如果所有條件都不成功，則執行預設條件。 switch 搭配簡短宣告就像 if 一樣，switch 也可以在條件表達式之前包含一個簡短宣告。因此，你也可以像這樣撰寫先前的 switch 範例： 12345678910111213141516switch dayOfWeek := 6; dayOfWeek &#123; case 1: fmt.Println(\"Monday\") case 2: fmt.Println(\"Tuesday\") case 3: fmt.Println(\"Wednesday\") case 4: fmt.Println(\"Thursday\") case 5: fmt.Println(\"Friday\") case 6: &#123; fmt.Println(\"Saturday\") fmt.Println(\"Weekend. Yaay!\") &#125; case 7: &#123; fmt.Println(\"Sunday\") fmt.Println(\"Weekend. Yaay!\") &#125; default: fmt.Println(\"Invalid day\")&#125; 唯一不同的是，簡短陳述式宣告的變數 dayOfWeek 僅可在 switch 區塊內使用。 合併多個 switch 條件你可以像這樣將多個 switch 條件合併成一個： 1234567891011121314package mainimport \"fmt\"func main() &#123; switch dayOfWeek := 5; dayOfWeek &#123; case 1, 2, 3, 4, 5: fmt.Println(\"Weekday\") case 6, 7: fmt.Println(\"Weekend\") default: fmt.Println(\"Invalid Day\") &#125;&#125; 12# OutputWeekday 當你需要針對多種情況執行共同的邏輯時，這非常方便。 不帶表達式的 switch在 Golang 中，我們在 switch 陳述式中指定的表達式是非必要的。不帶表達式的 switch 與 switch true 相同。它逐一評估所有條件，並執行第一個條件成功的區塊： 1234567891011121314151617package mainimport \"fmt\"func main() &#123; var BMI = 21.0 switch &#123; case BMI &lt; 18.5: fmt.Println(\"You're underweight\") case BMI &gt;= 18.5 &amp;&amp; BMI &lt; 25.0: fmt.Println(\"Your weight is normal\") case BMI &gt;= 25.0 &amp;&amp; BMI &lt; 30.0: fmt.Println(\"You're overweight\") default: fmt.Println(\"You're obese\") &#125;&#125; 不帶表達式的 switch 只是一個撰寫 if-else-if 鏈的簡潔方式。 for 迴圈迴圈用於重複執行程式碼區塊。Golang 只有一個迴圈陳述式：for 迴圈。 以下是 Go 中 for 迴圈的一般語法： 123for initialization; condition; increment &#123; // loop body&#125; 初始化陳述式只會在迴圈的第一次迭代前執行一次。在每次迭代時，都會檢查條件。如果條件評估為 true，則執行迴圈的主體，否則就終止迴圈。每次迭代結束時都會執行遞增陳述式。 這裡有個簡單的 for 迴圈範例： 123456789package mainimport \"fmt\"func main() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Printf(\"%d \", i) &#125;&#125; 12# Output0 1 2 3 4 5 6 7 8 9 與 C、C++ 和 Java 等其他語言不同，Go 的 for 迴圈不包含括號，但大括號 {} 是必需的。 注意，for 迴圈的初始化和遞增陳述式都是非必要的，可以省略 省略初始化陳述式 12345678910package mainimport \"fmt\"func main() &#123; i := 2 for ;i &lt;= 10; i += 2 &#123; fmt.Printf(\"%d \", i) &#125;&#125; 12# Output2 4 6 8 10 省略遞增陳述式 1234567891011package mainimport \"fmt\"func main() &#123; i := 2 for ;i &lt;= 20; &#123; fmt.Printf(\"%d \", i) i *= 2 &#125;&#125; 12# Output2 4 8 16 注意，在上面的 for 迴圈範例中，你也可以省略分號，並這樣寫： 1234567891011package mainimport \"fmt\"func main() &#123; i := 2 for i &lt;= 20 &#123; fmt.Printf(\"%d \", i) i *= 2 &#125;&#125; 上面的 for 迴圈與其他語言中的 while 迴圈類似。Go 沒有 while 迴圈，因為我們可以使用 for 輕鬆表示 white 迴圈。 最後，在 Golang 中你也可以省略 for 迴圈的條件。這會給你一個無限迴圈： 1234567package mainfunc main() &#123; // Infinite Loop for &#123; &#125;&#125; break 陳述式你可以使用 break 陳述式在正常終止之前中斷循環。這裡有個範例： 123456789101112package mainimport \"fmt\"func main() &#123; for num := 1; num &lt;= 100; num++ &#123; if num%3 == 0 &amp;&amp; num%5 == 0 &#123; fmt.Printf(\"First positive number divisible by both 3 and 5 is %d\\n\", num) break &#125; &#125;&#125; 12# OutputFirst positive number divisible by both 3 and 5 is 15 continue 陳述式continue 陳述式用於中途停止執行迴圈主體，並繼續執行迴圈的下一個迭代。 123456789101112package mainimport \"fmt\"func main() &#123; for num := 1; num &lt;= 10; num++ &#123; if num%2 == 0 &#123; continue; &#125; fmt.Printf(\"%d \", num) &#125;&#125; 12# Output1 3 5 7 9 結論在本文中，你學習了如何在 Golang 中使用流程控制陳述式，如 if、switch 和 for。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://calvertyang.github.io/tags/Golang/"}]},{"title":"在 Golang 中使用常數","slug":"working-with-constants-in-golang","date":"2019-11-06T03:31:41.000Z","updated":"2019-11-15T08:50:11.862Z","comments":true,"path":"2019/11/06/working-with-constants-in-golang/","link":"","permalink":"https://calvertyang.github.io/2019/11/06/working-with-constants-in-golang/","excerpt":"原文：CalliCoder — Working with Constants in Golang 常數在 Golang 中，我們使用 constant 語法來表示固定（不改變）的值，如 5、1.34、true 和 &quot;Hello&quot; 等。 定數是常數Golang 中的所有定數，如整數 5、1000、浮點數 4.76、1.89、布林值 true、false 或字串 &quot;Hello&quot;、&quot;Jhon&quot; 都是常數。 常數 範例 整數常數 1000、67413 浮點數常數 4.56、128.372 布林常數 true、false 表示字元的常數 &#39;C&#39;、&#39;ä&#39; 複數常數 2.7i、3 + 5i 字串常數 &quot;Hello&quot;、&quot;Rajeev&quot;","text":"原文：CalliCoder — Working with Constants in Golang 常數在 Golang 中，我們使用 constant 語法來表示固定（不改變）的值，如 5、1.34、true 和 &quot;Hello&quot; 等。 定數是常數Golang 中的所有定數，如整數 5、1000、浮點數 4.76、1.89、布林值 true、false 或字串 &quot;Hello&quot;、&quot;Jhon&quot; 都是常數。 常數 範例 整數常數 1000、67413 浮點數常數 4.56、128.372 布林常數 true、false 表示字元的常數 &#39;C&#39;、&#39;ä&#39; 複數常數 2.7i、3 + 5i 字串常數 &quot;Hello&quot;、&quot;Rajeev&quot; 宣告常數定數是沒有名稱的常數。你可以使用 const 關鍵字來要宣告一個常數並幫它命名： 12const myFavLanguage = \"Python\"const sunRisesInTheEast = true 你也可以像這樣在宣告時指定型別： 12const a int = 1234const b string = \"Hi\" 在單一陳述式中也可以有多個宣告： 123456const country, code = \"India\", 91const ( employeeId string = \"E101\" salary float64 = 50000.0) 正如你所期望的，常數無法更改。也就是說，你無法在初始化常數後重新分派給它： 12const a = 123a = 321 // Compiler Error (Cannot assign to constant) 已型別化和未型別化常數Golang 中的常數很特別。它們的運作方式與其他語言的運作方式不同。要了解它們為何如此特別以及它們如何正常運作，我們需要關於 Go 型別系統的背景知識。讓我們直接進入正題吧！ 背景知識Go 是一種靜態型別的程式語言。也就是說編譯器在編譯時期就知道或推斷了每個變數的型別。 但是它的型別系統更進一步的不允許你執行混合數字型別的操作。舉例來說，你不能將 float64 變數加到 int，也不能將 int64 變數加到 int： 123456var myFloat float64 = 21.54var myInt int = 562var myInt64 int64 = 120var res1 = myFloat + myInt // Not Allowed (Compiler Error)var res2 = myInt + myInt64 // Not Allowed (Compiler Error) 要使上述操作正常運作，你需要明確地轉換變數，讓它們都屬於相同型別： 12var res1 = myFloat + float64(myInt) // Worksvar res2 = myInt + int(myInt64) // Works 如果你使用過其他靜態型別的語言，如 C、C++ 或 Java，那麼你必須知道，只要在任何操作中將它們混合使用，它們會自動將較小的型別轉換為較大的型別。舉例來說，int 可以自動轉換為 long、float 或 double。 所以顯而易見的問題是：為什麼 Go 不會做同樣的事？它為什麼不像 C、C++ 或 Java 一樣執行隱式型別轉換？ 以下是 Go 設計師所說的（節錄自 Golang 的官方文件）： C 語言籠罩在數字型別間便利的自動轉換所引起的混亂中。表達式什麼時候是無號數？可容納多大數值範圍？它會溢位嗎？結果是否可移植、不受執行它的機器影響？這也使得編譯器複雜化；「一般算術轉換」不容易實作且跨架構不一致。出於可移植性的原因，我們決定以程式碼中明確地型別轉換作為代價，讓事情變得清晰明瞭。 好吧！因此 Go 不提供隱式型別轉換，它要求我們在混合操作多個型別的變數時，必須使用明確地型別轉換。 但是 Go 的型別系統如何與常數一起使用？以下所有陳述式在 Golang 中皆有效： 1234var myInt32 int32 = 10 var myInt int = 10var myFloat64 float64 = 10var myComplex complex64 = 10 在以上範例中，常數值 10 的型別是什麼？此外，如果 Golang 中沒有隱式型別轉換，那麼我們就不需要像這樣寫上面的陳述式： 123var myInt32 int32 = int32(10)var myFloat64 float64 = float64(10)// etc.. 好吧！所有這些問題的答案都在於 Golang 處理常數的方式。因此，讓我們找出它們的處理方式。 未型別化常數除非明確地給定型別，否則 Golang 中任何已命名或未命名的常數都是未型別化的。舉例來說，以下所有常數都是未型別化的： 12341 // untyped integer constant4.5 // untyped floating-point constanttrue // untyped boolean constant\"Hello\" // untyped string constant 即使你給它們名字，它們還是未型別化： 1234const a = 1const f = 4.5const b = trueconst s = \"Hello\" 現在，你可能會想說我使用的是如 integer 常數、string 常數之類的語法，而我還說它們是未型別化。 是的，1 是整數、4.5 是浮點數以及 &quot;Hello&quot; 是字串。但它們只是數值，還沒有給它們如 int32、float64 或 string 的固定型別，這會迫使它們遵守 Go 的嚴格型別規則。 事實上，1 是未型別化的，這讓我們可以將其分派給型別與整數相容的任何變數： 123var myInt int = 1var myFloat float64 = 1var myComplex complex64 = 1 要注意的是，雖然 1 未型別化，但它是未型別化的整數。因此，它只能在允許整數的地方使用。舉例來說，你不能將它分派給 string 或 boolean 變數。 同樣地，可以在任何允許使用浮點數的地方使用如 4.5 之類的未型別化浮點數常數： 12var myFloat32 float32 = 4.5var myComplex64 complex64 = 4.5 現在來看一個未型別化字串常數的範例： 在 Golang 中，你可以使用 type 關鍵字來建立型別別名： 1type RichString string // Type alias of `string` 鑑於 Golang 的強型別特性，你不能將 string 變數分派給 RichString 變數： 12var myString string = \"Hello\"var myRichString RichString = myString // Won't work. 但是，你可以將一個未型別化的字串常數分派給 RichString 變數，因為它與字串相容： 12const myUntypedString = \"Hello\"var myRichString RichString = myUntypedString // Works 常數和型別推斷：預設型別Go 支援型別推斷。也就是說，它可以從初始化變數的值推斷出變數的型別。因此，你可以宣告一個具有初始值但沒有任何型別資訊的變數，而 Go 會自動決定型別： 1var a = 5 // Go compiler automatically infers the type of the variable `a` 但是它是如何運作的呢？鑑於 Golang 中的常數是未型別化的，在上面的範例中，變數 a 的型別是什麼？是 int8、int16、int32、int64 還是 int？ 好吧，事實證明，Golang 中每個未型別化的常數都有一個預設型別。當我們將常數分派給沒有任何明確型別的變數時，將使用預設型別。 以下是 Golang 中各種常數的預設型別： 常數 預設型別 整數（10、76) int 浮點數（3.14、7.92） float64 複數（3 + 5i） complex128 字元（&#39;a&#39;、&#39;♠&#39;） rune 布林值（true, false） bool 字串（”Hello”） string 因此，在陳述式 var a = 5 中，由於沒有明確地型別資訊，整數常數的預設型別將決定 a 的型別，即 int。 已型別化常數在 Golang 中，當你像這樣在宣告常數時明確地指定型別，常數是已型別化的： 1const typedInt int = 1 // Typed constant 就像變數一樣，Go 型別系統的所有規則都適用於已型別化的常數。舉例來說，你不能分派已型別化的整數常數到浮點數變數： 1var myFloat64 float64 = typedInt // Compiler Error 使用已型別化常數，你將失去未型別化常數帶來的所有靈活性，例如將它們分派給相容型別的任何變數，或將它們混合在算術運算中。因此，僅在絕對必要時，才應該為常數宣告型別。否則，只宣告沒有型別的常數。 常數表達式常數是未型別化的（除非明確地給定型別），這讓你可以在任何表達式中自由混合它們。 因此，你可以擁有一個混合各種未型別化常數的表達式，只要這些未型別化的常數彼此相容： 12345const a = 5 + 7.5 // Validconst b = 12 / 5 // Validconst c = 'z' + 1 // Validconst d = \"Hey\" + true // Invalid (untyped string constant and untyped boolean constant are not compatible with each other) 對常數表達式及其結果的評估遵循某些規則。讓我們看看這些規則： 常數表達式的規則 比較兩個未型別化的常數，會輸出未型別化的布林值常數。 12const a = 7.5 &gt; 5 // true (untyped boolean constant)const b = \"xyz\" &lt; \"uvw\" // false (untyped boolean constant) 對於其他運算（除了位移）： 如果兩個運算元型別相同（例如，皆為未型別化的整數常數），則結果也是相同型別。舉例來說，表達式 25 / 2 的結果是 12，不是 12.5。由於兩個運算元均為未型別化整數，因此結果將被截斷為整數。 如果兩個運算元型別不同，則結果是該運算元的型別且根據規則取較大的：integer &lt; rune &lt; floating-point &lt; complex。 12const a = 25 / 2 // 12 (untyped integer constant)const b = (6 + 8i) / 2 // (3 + 4i) (untyped complex constant) 位移運算規則有點複雜。首先，有一些必要條件： 位移表達式右側的運算元必須是未型別化的整數型別，或是可以表示 uint 型別的未型別化常數。 左側的運算元必須是整數型別，或是可以表示 int 型別的未型別化常數。 規則：如果位移表達式左側的運算元是未型別化常數，則結果是未型別化的整數常數；否則結果與左側運算元的型別相同。 1234567const a = 1 &lt;&lt; 5 // 32 (untyped integer constant)const b = int32(1) &lt;&lt; 4 // 16 (int32)const c = 16.0 &gt;&gt; 2 // 4 (untyped integer constant) - 16.0 can represent a value of type `int`const d = 32 &gt;&gt; 3.0 // 4 (untyped integer constant) - 3.0 can represent a value of type `uint`const e = 10.50 &lt;&lt; 2 // ILLEGAL (10.50 can't represent a value of type `int`)const f = 64 &gt;&gt; -2 // ILLEGAL (The right operand must be an unsigned int or an untyped constant compatible with `uint`) 常數表達式範例讓我們來看一些常數表達式的範例： 12345678package mainimport \"fmt\"func main() &#123; var result = 25 / 2 fmt.Printf(\"result is %v which is of type %T\\n\", result, result)&#125; 12# Outputresult is 12 which is of type int 由於 25 和 2 都是未型別化的整數常數，因此結果會被截斷為未型別化的整數 12。 若要得到正確的結果，你可以執行以下任一操作： 12// Use a float value in numerator or denominatorvar result = 25.0 / 2 12// Explicitly cast the numerator or the denominatorvar result = float64(25) / 2 讓我們來看另一個範例： 12345678package mainimport \"fmt\"func main() &#123; var result = 4.5 + (10-5)*(3+2)/2 fmt.Println(result)&#125; 以上程式會產生什麼結果？ 嗯，不是 17。以上程式的實際結果是 16.5。我們來看一下表達式的求值順序，以了解為什麼結果是 16.5。 12345678910114.5 + (10 - 5) * (3 + 2)/2 ↓ 4.5 + (5) * (3 + 2)/2 ↓ 4.5 + (5) * (5)/2 ↓ 4.5 + (25)/2 ↓ 4.5 + 12 ↓ 16.5 了解了嗎？結果是錯誤的，因為表達式 25/2 的計算結果是 12。 要得到正確的結果，可以執行以下任一操作： 12// Use a float value in the numerator or denominatorvar result = 4.5 + (10-5)*(3+2)/2.0 12// Explicitly cast numerator or the denominatorvar result = 4.5 + float64((10-5)*(3+2))/2 結論未型別化常數是 Go 創造者做出的驚人設計決策。儘管 Go 有強大的型別系統，但你可以使用未型別化的常數來擺脫 Go 的型別系統，並在處理任何表達式中的混合資料型別時具有更強大的靈活性。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://calvertyang.github.io/tags/Golang/"}]},{"title":"Golang 基本型別、運算子和型別轉換","slug":"golang-basic-types-operators-type-conversion","date":"2019-11-05T09:04:41.000Z","updated":"2019-11-15T08:50:11.852Z","comments":true,"path":"2019/11/05/golang-basic-types-operators-type-conversion/","link":"","permalink":"https://calvertyang.github.io/2019/11/05/golang-basic-types-operators-type-conversion/","excerpt":"原文：CalliCoder — Golang Basic Types, Operators and Type Conversion Go 是靜態型別的程式語言。Golang 中的每個變數都有關聯的型別。 資料型別會對一組相關的資料集進行分類。它們定義了資料如何儲存在記憶體中、特定資料型別的變數可能儲存的值以及可以對其執行的運算。 Golang 具有多種內建的資料型別，用於表示常見的值，如數字、布林值、字串等。在本文中，我們將逐一介紹這些基本資料型別，並了解它們的工作原理。","text":"原文：CalliCoder — Golang Basic Types, Operators and Type Conversion Go 是靜態型別的程式語言。Golang 中的每個變數都有關聯的型別。 資料型別會對一組相關的資料集進行分類。它們定義了資料如何儲存在記憶體中、特定資料型別的變數可能儲存的值以及可以對其執行的運算。 Golang 具有多種內建的資料型別，用於表示常見的值，如數字、布林值、字串等。在本文中，我們將逐一介紹這些基本資料型別，並了解它們的工作原理。 數字型別數字型別用於表示數字。可以分為整數和浮點數型別： 1. 整數整數用於儲存整數。Go 具有多種大小不一的內建整數型別，用於儲存有號數和無號數： 有號數 型別 大小 範圍 int8 8 bits -128 到 127 int16 16 bits -215 到 215 -1 int32 32 bits -231 到 231 -1 int64 64 bits -263 到 263 -1 int 取決於平台 取決於平台 泛型 int 型別的大小取決於平台。在 32 位元系統上，它的大小為 32 位元，在 64 位元系統上，它的大小為 64 位元。 無號數 型別 大小 範圍 uint8 8 bits 0 到 255 uint16 16 bits 0 到 216 -1 uint32 32 bits 0 到 232 -1 uint64 64 bits 0 到 264 -1 uint 取決於平台 取決於平台 uint 型別的大小取決於平台。在 32 位元系統上，它的大小為 32 位元，在 64 位元系統上，它的大小為 64 位元。 使用整數值時，除非有充分的理由使用有號數或無號數，否則應該始終使用 int 資料型別。 在 Golang 中，你可以使用前綴 0 來宣告八進制數字，以及使用前綴 0x 或 0X 來宣告十六進制數字。以下是整數型別的完整範例： 1234567891011121314151617181920package mainimport \"fmt\"func main() &#123; var myInt8 int8 = 97 /* When you don't declare any type explicitly, the type inferred is `int` (The default type for integers) */ var myInt = 1200 var myUint uint = 500 var myHexNumber = 0xFF // Use prefix '0x' or '0X' for declaring hexadecimal numbers var myOctalNumber = 034 // Use prefix '0' for declaring octal numbers fmt.Printf(\"%d, %d, %d, %#x, %#o\\n\", myInt8, myInt, myUint, myHexNumber, myOctalNumber)&#125; 12# Output97, 1200, 500, 0xff, 034 整數型別別名Golang 還有另外兩個稱為 byte 和 rune 的整數型別，分別是 uint8 和 int32 資料型別的別名。 別名 型別 byte uint8 rune int32 在 Go 語言中，byte 和 rune 資料型別用於區分字元和整數值。 Golang 沒有 char 資料型別。它使用 byte 和 rune 來表示字元值。byte 資料型別用於表示 ASCII 字元，以及 rune 資料型別用於表示以 UTF-8 格式編碼的一組更廣泛的 Unicode 字元。 要在 Golang 中表示字元可以像這樣透過單引號將它們括起來：&#39;A&#39;。 字元值的預設型別是 rune。也就是說，當宣告帶有字元值的變數而未明確指定型別時，則 Go 會將型別推斷為 rune： 1var firstLetter = 'A' // Type inferred as `rune` (Default type for character values) 你可以透過明確地指定型別來建立 byte 變數： 1var lastLetter byte = 'Z' byte 和 rune 資料型別本質上都是整數。舉例來說，具有值 &#39;a&#39; 的 byte 變數會轉換為整數 97。 相同的，具有 Unicode 值 &#39;♥&#39; 的 rune 變數會轉換為相應的 Unicode 代碼點 U + 2665，其中 U+ 代表 Unicode，且數字是十六進制，本質上是整數。 12345678910package mainimport \"fmt\"func main() &#123; var myByte byte = 'a' var myRune rune = '♥' fmt.Printf(\"%c = %d and %c = %U\\n\", myByte, myByte, myRune, myRune)&#125; 12# Outputa = 97 and ♥ = U+2665 在上面的範例中，我以字元和十進制格式印出變數 myByte，並以字元和 Unicode 格式印出變數 myRune。 2. 浮點數型別浮點數型別用於儲存帶小數部分的數字（如：1.24、4.50000）。Go 有兩種浮點數型別：float32 和 float64。 float32 在記憶體中佔用 32 位元，並以單精度浮點數格式儲存數值。 float64 在記憶體中佔用 64 位元，並以雙精度浮點數格式儲存數值。 浮點數的預設型別是 float64。因此，當你使用初始值初始化浮點數變數而未明確指定型別時，編譯器會將型別推斷為 float64： 1var a = 9715.635 // Type inferred as `float64` (the default type for floating-point numbers) 數字型別的運算Go 提供了多種用於對數字型別執行運算的運算子： 算術運算子：+, -, *, /, % 比較運算子：==, !=, &lt;, &gt;, &lt;=, &gt;= 位元運算子：&amp;, |, ^, &lt;&lt;, &gt;&gt; 遞增和遞減運算子：++, -- 賦值運算子：+=, -=, *=, /=, %=, &lt;&lt;=, &gt;&gt;=, &amp;=, |=, ^= 以下是上述一些運算子的範例： 12345678910111213141516171819202122package mainimport ( \"fmt\" \"math\")func main() &#123; var a, b = 4, 5 var res1 = (a + b) * (a + b) / 2 // Arithmetic operations a++ // Increment a by 1 b += 10 // Increment b by 10 var res2 = a ^ b // Bitwise XOR var r = 3.5 var res3 = math.Pi * r * r // Operations on floating-point type fmt.Printf(\"res1 : %v, res2 : %v, res3 : %v\\n\", res1, res2, res3)&#125; 12# Outputres1 : 40, res2 : 10, res3 : 38.48451000647496 布林值Go 提供了一種稱為 bool 的資料型別來儲存布林值。它有兩個可能的值：true 和 false。 12var myBoolean = truevar anotherBoolean bool = false 布林值型別的運算你可以對布林值使用以下運算子： 邏輯運算子： &amp;&amp;（與，and） ||（或，or） ! （否定） 相等和不相等： ==, != 運算子 &amp;&amp; 和 || 遵循短路規則。也就是說，在表達式 E1 &amp;&amp; E2 中，如果 E1 的評估結果為 false，則不會評估 E2。相同的，在表達式 E1 || E2 中，如果 E1 的評估結果為 true，則不會評估 E2。 以下是布林值型別的範例： 1234567891011121314package mainimport \"fmt\"func main() &#123; var truth = 3 &lt;= 5 var falsehood = 10 != 10 // Short Circuiting var res1 = 10 &gt; 20 &amp;&amp; 5 == 5 // Second operand is not evaluated since first evaluates to false var res2 = 2*2 == 4 || 10%3 == 0 // Second operand is not evaluated since first evaluates to true fmt.Println(truth, falsehood, res1, res2)&#125; 12# Outputtrue false false true 複數複數是 Golang 中的基本型別之一。Go 有兩種不同大小的複數型別： complex64：實部和虛部都是 float32 型別。 complex128：實部和虛部都是 float64 型別。 Golang 中複數的預設型別是 complex128。你可以像這樣建立一個複數： 1var x = 5 + 7i // Type inferred as `complex128` Go 還提供了一個名為 complex 的內建函數，用於建立複數。如果你要使用變數而不是文字來建立複數，則需要使用 complex 函數： 12345var a = 3.57var b = 6.23// var c = a + bi won't work. Create the complex number like this -var c = complex(a, b) 要注意的是，複數的實部和虛部都必須是相同的浮點數型別。如果你嘗試建立具有不同實部和虛部型別的複數，則編譯器將拋出錯誤： 12345678var a float32 = 4.92var b float64 = 7.38/* The Following statement Won't compile. (Both real and imaginary parts must be of the same floating-point type)*/var c = complex(a, b) // Compiler Error 複數型別的運算你可以對複數執行算術運算，如加、減、乘和除： 123456789101112131415package mainimport \"fmt\"func main() &#123; var a = 3 + 5i var b = 2 + 4i var res1 = a + b var res2 = a - b var res3 = a * b var res4 = a / b fmt.Println(res1, res2, res3, res4)&#125; 12# Output(5+9i) (1+1i) (-14+22i) (1.3-0.1i) 字串在 Go 中，字串是字元組序列。 Golang 中的字串可以使用如 &quot;Hello World&quot; 中的雙引號宣告，也可以使用如 `Hello World` 中的反引號宣告。 123456// Normal String (Can not contain newlines, and can have escape characters like `\\n`, `\\t` etc)var name = \"Steve Jobs\"// Raw String (Can span multiple lines. Escape characters are not interpreted)var bio = `Steve Jobs was an American entrepreneur and inventor. He was the CEO and co-founder of Apple Inc.` 用雙引號括起來的字串不能包含換行，但可以包含跳脫字元，如 \\n、\\t 等。在雙引號字串中，會用換行字元替換 \\n 字元，並用 tab 空格替換 \\t 字元，依此類推。 反引號內包含的字串是原始字串。它們可以跨越多行。此外，跳脫字元在原始字串中沒有任何特殊含義。 12345678910111213package mainimport \"fmt\"func main() &#123; var website = \"\\thttps://www.callicoder.com\\t\\n\" var siteDescription = `\\t\\tCalliCoder is a programming blog where you can find practical guides and tutorials on programming languages, web development, and desktop app development.\\t\\n` fmt.Println(website, siteDescription)&#125; 12345# Output https://www.callicoder.com \\t\\tCalliCoder is a programming blog where you can find practical guides and tutorials on programming languages, web development, and desktop app development.\\t\\n 以上就是本文關於字串的全部內容。但還有很多關於字串的知識要了解，包括字串索引、處理 Unicode 字元以及執行各種操作如字串連接、分離等。我們將在以後的文章中了解它們。 型別轉換Golang 有個強型別系統。它不允許你在表達式中混合數字型別。舉例來說，你不能將 int 變數加到 float64 變數中，也不能將 int 變數加到 int64 變數中。你甚至無法在混合型別之間執行分派： 123456var a int64 = 4var b int = a // Compiler Error (Cannot use a (type in64) as type int in assignment)var c int = 500var result = a + c // Compiler Error (Invalid Operation: mismatched types int64 and int) 與 C、C++ 和 Java 等其他靜態型別語言不同，Go 不提供任何隱式型別轉換。要了解為何採用這種方式設計 Go，請查看下一篇文章：在 Golang 中使用常數。 好吧！即使它們是數字型別，我們也不能對兩種不同型別進行加、減、比較或任何類型的運算。但如果我們需要執行這樣的運算該怎麼辦？ 嗯，你需要將變數明確地轉換為目標型別： 1234567var a int64 = 4var b int = int(a) // Explicit Type Conversionvar c float64 = 6.5// Explicit Type Conversionvar result = float64(b) + c // Works 一般將值 v 轉換為型別 T 的語法是 T(v)。這裡有幾個範例： 123var myInt int = 65var myUint uint = uint(myInt)var myFloat float64 = float64(myInt) 結論在本文中，你了解了 Golang 提供的各種基本資料型別、可以對這些型別執行的操作，以及如何將一種型別轉換為另一種型別。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://calvertyang.github.io/tags/Golang/"}]},{"title":"Golang 變數、零值和型別推斷","slug":"golang-variables-zero-values-type-inference","date":"2019-11-05T02:58:20.000Z","updated":"2019-11-15T08:50:11.877Z","comments":true,"path":"2019/11/05/golang-variables-zero-values-type-inference/","link":"","permalink":"https://calvertyang.github.io/2019/11/05/golang-variables-zero-values-type-inference/","excerpt":"原文：CalliCoder — Golang Variables, Zero Values, and Type inference 變數和資料型別入門每個程式都需要在記憶體中儲存一些資料。資料被儲存在特定的記憶體位置。 變數只是為儲存資料的記憶體位置所取的一個方便的名稱。除了名稱外，每個變數還有關聯的型別。","text":"原文：CalliCoder — Golang Variables, Zero Values, and Type inference 變數和資料型別入門每個程式都需要在記憶體中儲存一些資料。資料被儲存在特定的記憶體位置。 變數只是為儲存資料的記憶體位置所取的一個方便的名稱。除了名稱外，每個變數還有關聯的型別。 資料型別或簡易型別會對相關的資料集進行分類，定義它們的儲存方式、可以儲存的值的範圍以及可以對其執行的運算。 舉例來說，Golang 有個資料型別為 int8。它表示 8 位元整數值的範圍可以從 -128 到 127。它也定義了可以對 int8 資料型別執行的運算，如加、減、乘、除等。 我們在 Golang 中也有一個 int 資料型別，其大小取決於平台。在 32 位元系統上，它的大小為 32 位元，在 64 位元系統上，它的大小為 64 位元。 Golang 中的其他資料型別範例有 bool、string、float32、float64等。在下一個教學中，你將了解關於這些資料型別的更多資訊。我在這簡要介紹了資料型別，因為在深入研究 Golang 變數之前有必要了解它們。 深入 Golang 變數宣告變數在 Golang 中，我們使用 var 關鍵字來宣告變數： 123var firstName stringvar lastName string var age int 如下所示，你也可以一次宣告多個變數： 12345var ( firstName string lastName string age int) 你甚至可以使用逗號組合多個相同型別的變數宣告： 1234var ( firstName, lastName string age int) 零值任何沒有初始值的變數宣告都會有零值，具體取決於變數的型別： 型別 零值 bool false string “” int、int8、int16 等 0 float32、float64 0.0 下面的範例展示了零值的概念： 123456789101112131415package mainimport \"fmt\"func main() &#123; var ( firstName, lastName string age int salary float64 isConfirmed bool ) fmt.Printf(\"firstName: %s, lastName: %s, age: %d, salary: %f, isConfirmed: %t\\n\", firstName, lastName, age, salary, isConfirmed)&#125; 12# OutputfirstName: , lastName: , age: 0, salary: 0.000000, isConfirmed: false 用初始值宣告變數以下是如何在宣告時初始化變數的方法： 123var firstName string = \"Satoshi\"var lastName string = \"Nakamoto\"var age int = 35 你也可以像這樣使用多個宣告： 12345var ( firstName string = \"Satoshi\" lastName string = \"Nakamoto\" age int = 35) 甚至使用逗號組合多個相同型別的變數宣告，並像這樣初始化它們： 1234var ( firstName, lastName string = \"Satoshi\", \"Nakamoto\" age int = 35) 型別推斷儘管 Go 是一種靜態型別的程式語言，但它不需要你明確指定宣告的每個變數的型別。 當你宣告具有初始值的變數時，Golang 會自動從右側的值推斷出變數的型別。因此，在宣告時初始化變數不需要指定型別： 12345678package mainimport \"fmt\"func main() &#123; var name = \"Rajeev Singh\" // Type declaration is optional here. fmt.Printf(\"Variable 'name' is of type %T\\n\", name)&#125; 12# OutputVariable &apos;name&apos; is of type string 在上面的範例中，Golang 自動從右側的值推斷出變數的型別為 string。如果你嘗試重新分派其他型別的值給變數，則編譯器將拋出錯誤： 12var name = \"Rajeev Singh\" // Type inferred as `string`name = 1234 // Compiler Error 如下所示，型別推斷讓我們可以在同一行中宣告和初始化不同資料型別的多個變數： 1234567891011package mainimport \"fmt\"func main() &#123; // Multiple variable declarations with inferred types var firstName, lastName, age, salary = \"John\", \"Maxwell\", 28, 50000.0 fmt.Printf(\"firstName: %T, lastName: %T, age: %T, salary: %T\\n\", firstName, lastName, age, salary)&#125; 12# OutputfirstName: string, lastName: string, age: int, salary: float64 簡短宣告Go 使用 := 運算子提供了簡短的變數宣告語法。這是宣告和初始化變數的簡寫（包含型別推斷）。 舉例來說，var name = &quot;Rajeev&quot; 的簡寫是 name := &quot;Rajeev&quot;。以下是完整範例： 1234567891011package mainimport \"fmt\"func main() &#123; // Short variable declaration syntax name := \"Rajeev Singh\" age, salary, isProgrammer := 35, 50000.0, true fmt.Println(name, age, salary, isProgrammer)&#125; 12# OutputRajeev Singh 35 50000 true 要注意的是，簡短的變數宣告只能在函數內使用。在函數外，每個陳述式都需要以 var、func 等關鍵字開頭，因此，不可使用 := 運算子。 結論變數是任何程式語言中的基本概念之一。在本文中，你學習了如何在 Golang 宣告變數、型別推斷如何運作，以及如何使用複合式宣告和簡短宣告。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://calvertyang.github.io/tags/Golang/"}]},{"title":"在 Ruby on Rails 使用時區","slug":"working-with-time-zones-in-ruby-on-rails","date":"2018-09-18T06:42:46.000Z","updated":"2019-11-15T08:50:11.849Z","comments":true,"path":"2018/09/18/working-with-time-zones-in-ruby-on-rails/","link":"","permalink":"https://calvertyang.github.io/2018/09/18/working-with-time-zones-in-ruby-on-rails/","excerpt":"原文：VARVET BLOG — WORKING WITH TIME ZONES IN RUBY ON RAILS Rails 提供了很好的工具來處理時區，但仍有很多事情可能會出錯。這篇文章會點出這些問題並提供解決方案。 讓我被欺騙最多次的應該是，Rails 會愚弄你，讓你誤以為它替你處理好了所有和時間有關的部分。別誤會我的意思，我希望 Rails 盡可能的為我做更多事情，但在學習的過程中由於不夠熟悉 Rails 為我做了些什麼，因此碰到了許多困難。另外需要注意的是，在處理時區上，有更多是你意想不到需要處理的。需要考慮資料庫、伺服器、開發機器、系統設定、使用者設定和瀏覽器。","text":"原文：VARVET BLOG — WORKING WITH TIME ZONES IN RUBY ON RAILS Rails 提供了很好的工具來處理時區，但仍有很多事情可能會出錯。這篇文章會點出這些問題並提供解決方案。 讓我被欺騙最多次的應該是，Rails 會愚弄你，讓你誤以為它替你處理好了所有和時間有關的部分。別誤會我的意思，我希望 Rails 盡可能的為我做更多事情，但在學習的過程中由於不夠熟悉 Rails 為我做了些什麼，因此碰到了許多困難。另外需要注意的是，在處理時區上，有更多是你意想不到需要處理的。需要考慮資料庫、伺服器、開發機器、系統設定、使用者設定和瀏覽器。 設定你的 Rails 應用程式作為 Rails 開發人員，我們可以使用哪些工具？最重要的一個是 config/application.rb 檔案中的 config.time_zone 設定。Active Record 會協助你轉換 UTC 和你選擇的時區（文件沒有解釋）。也就是，如果你所做的只是要透過表單取得用戶文章發佈時間，並使用 Active Record 來保存它，那麼你可以開始了。 處理時間資訊那麼在保存時間資訊前要做些什麼呢？ 解析重要的是永遠不要在沒有指定時區的情況下解析時間資訊。最好的方法是使用 Time.zone.parse（會使用 config.time_zone 指定的時區）而不是使用 Time.parse（會使用電腦的時區）。 使用數字和 Active Record 屬性如果可以，請使用如 2.hours.ago 這樣的方法，它會使用你設定的時區！Active Record 模型的時間屬性也是如此。 123post = Post.firstpost.published_at# =&gt; Fri, 10 Aug 2018 00:00:00 JST +09:00 Active Record 從資料庫取得 UTC 時間，並將其轉換為 config.time_zone 中設定的時區。 Date 與 TimeTime 包含日期和時間資訊，但是 Date 只有日期資訊。即使你認為時間資訊並不重要，但很快地就會意識到它的重要性。安全地使用 Time（或 DateTime，如果你需要支援較遠的時間）。 假設你需要將日期視為時間，至少要確保將它轉換為你設定的時區： 123451.day.from_now# =&gt; Sat, 11 Aug 2018 12:11:11 JST +09:00Date.current.in_time_zone# =&gt; Fri, 10 Aug 2018 00:00:00 JST +09:00 永遠別用： 12Date.today.to_time# =&gt; 2018-08-10 00:00:00 +0800 查詢由於 Rails 知道時間資訊是以 UTC 格式儲存於資料庫中，它會將你給它的任何時間轉換為 UTC。 1Post.where(['posts.published_at &gt; ?', Time.current]) 永遠不要手動建立查詢字串，應使用 Time.current 取得目前時間，以確保時間資訊是正確的。 使用於 APIs提供端建立 Web API 提供其他人使用？請確保始終以 UTC 格式傳送所有時間資料。 12Time.current.utc.iso8601# =&gt; \"2018-08-10T03:11:35Z\" 在此閱讀更多關於為什麼 iso8601 是好的：http://devblog.avdi.org/2009/10/25/iso8601-dates-in-ruby/ 用戶端當你從外部 API 取得時間資訊時，你無法掌控它，只需要確定它傳送給你的格式和時區。因為 Time.zone.parse 可能無法使用在你收到的格式，你可能需要使用： 1Time.strptime(time_string, '%Y-%m-%dT%H:%M:%S%z').in_time_zone 上面的範例假設了 time_string 是 iso8601 格式的字串。當時間字串的格式與格式樣板參數不匹配時，strptime 會拋出一個非常不直覺的錯誤。in_time_zone 預設會使用 Rails 設定的時區。 目前可以使用 Time.zone.strptime 或 Time.zone.parse 來解析時間資訊。 使用用戶時區許多系統需要支援用戶在各種時區輸入和查看時間資訊。要實現此目的，你需要儲存每個用戶的時區（可能只是一個在 rake time:zones:all 中找到的時區字串名稱）。然後，要實際使用該時區最常見的方式是在 ActionController 中建立一個私有方法，並將其作為 around_action 執行。 12345around_action :user_time_zone, if: :current_userdef user_time_zone(&amp;block) Time.use_zone(current_user.time_zone, &amp;block)end 這與 config.time_zone 做的事完全相同，但是是基於每個請求。我仍然建議將預設的 config.time_zone 更改為用戶的預設時區。 測試以上所有內容都是測試應該涵蓋的範圍。問題是你作為開發伺服器的用戶和電腦恰好位於同一時區。在生產環境中這種情況很少發生。 有一個 Zonebie gem 可以幫助你解決這個問題。我還沒有時間試試看，但看起來很有希望。如果你覺得這有點矯枉過正，至少要確保你的測試執行時將 Time.zone 設定為另一時區，而不是開發機所在的時區！ 速查表可以做12345678910111213141516171819202122232.hours.ago# =&gt; Fri, 10 Aug 2018 10:12:02 JST +09:001.day.from_now# =&gt; Sat, 11 Aug 2018 12:12:15 JST +09:00Time.zone.parse('2018-08-08T12:34:56Z')# =&gt; Wed, 08 Aug 2018 21:34:56 JST +09:00Time.current# =&gt; Fri, 10 Aug 2018 12:12:40 JST +09:00Time.current.utc.iso8601# 當提供 API 時（\"2018-08-10T03:12:47Z\"）Time.strptime('2018-08-08T12:34:56Z', '%Y-%m-%dT%H:%M:%S%z').in_time_zone# 如果你不能使用 Time.zone.parse（Wed, 08 Aug 2018 21:34:56 JST +09:00）Date.current# 如果由於某種原因你真的不能有 Time 或 DateTime（Fri, 10 Aug 2018）Date.current.in_time_zone# 如果你有日期並希望充分利用它（Fri, 10 Aug 2018 00:00:00 JST +09:00） 不可以做1234567891011Time.now# 返回系統時間並忽略你設定的時區。（2018-08-10 11:13:30 +0800）Time.parse('2015-08-27T12:09:36Z')# 會假設時間字串是在系統的時區。（2015-08-27 12:09:36 UTC）Time.strptime('2015-08-27T12:09:36Z', '%Y-%m-%dT%H:%M:%S%z')# 與 Time.parse 相同的問題。（2015-08-27 12:09:36 UTC）Date.today# 取決於機器的時區，這可能是昨天或明天，更多相關資訊，請參閱 https://github.com/ramhoj/time-zone-article/issues/1。（Fri, 10 Aug 2018）","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://calvertyang.github.io/tags/Ruby-on-Rails/"}]},{"title":"什麼時候應該在類別內使用 self","slug":"when-should-you-use-self-in-your-classes","date":"2018-07-31T04:47:45.000Z","updated":"2019-11-15T08:50:11.860Z","comments":true,"path":"2018/07/31/when-should-you-use-self-in-your-classes/","link":"","permalink":"https://calvertyang.github.io/2018/07/31/when-should-you-use-self-in-your-classes/","excerpt":"在 Ruby 類別內，你不知道什麼時候需要使用 self，而什麼時候又可以省略，本文將透過範例來做簡單的說明。 範例一1234567class Foo attr_writer :bar def do_something bar = 123 endend 在此範例中 bar = 123 會建立一個名稱為 bar 的區域變數，而不是呼叫由 attr_writer 所產生的 bar= 方法，只要加上 self 就可以修正這個問題。 1234567class Foo attr_writer :bar def do_something self.bar = 123 endend self.bar 便會呼叫我們所預期的 bar= 方法。","text":"在 Ruby 類別內，你不知道什麼時候需要使用 self，而什麼時候又可以省略，本文將透過範例來做簡單的說明。 範例一1234567class Foo attr_writer :bar def do_something bar = 123 endend 在此範例中 bar = 123 會建立一個名稱為 bar 的區域變數，而不是呼叫由 attr_writer 所產生的 bar= 方法，只要加上 self 就可以修正這個問題。 1234567class Foo attr_writer :bar def do_something self.bar = 123 endend self.bar 便會呼叫我們所預期的 bar= 方法。 範例二你也可以使用 self 來呼叫與區域變數名稱相同的屬性閱讀器： 12345678class Foo attr_reader :bar def do_something bar = 123 puts self.bar endend 此處的 bar 與 self.bar 分別為區域變數與實例變數，是兩個不同的東西，因此通常為了避免混淆，最好避免區域變數與存取器名稱相同。 範例三1234567891011class People attr_accessor :name def initialize self.name = 'Calvert' end def greeting \"Hello, #&#123;name&#125;\" endend 在這個範例中，可以看到在 greeting 方法中沒有使用 self 來讀取實例變數 name，因為 attr_accessor 會產生以下兩個方法，因此可以省略 self 來讀取 name： 1234567def name @nameenddef name=(new_name) @name = new_nameend 結論當呼叫設值方法時你必須使用 self.foo = 123 而不是 foo = 123，這樣 Ruby 才會知道你不是要嘗試建立一個新的區域變數。 同樣的，如果你有一個與區域變數相同名稱的方法 greeting，則必須使用 self.greeting 來呼叫該方法，因為使用 greeting 會讀取區域變數而不是呼叫該方法。 參考資料 https://stackoverflow.com/questions/5068304/in-ruby-when-should-you-use-self-in-your-classes https://stackoverflow.com/questions/4699687/when-to-use-self-foo-instead-of-foo-in-ruby-methods https://stackoverflow.com/questions/10805136/when-to-use-self-in-model","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://calvertyang.github.io/tags/Ruby/"}]},{"title":"Rails Engine 入門","slug":"getting-started-with-engines","date":"2018-06-11T06:39:07.000Z","updated":"2019-11-15T08:50:11.874Z","comments":true,"path":"2018/06/11/getting-started-with-engines/","link":"","permalink":"https://calvertyang.github.io/2018/06/11/getting-started-with-engines/","excerpt":"原文：Ruby on Rails Guides — Getting Started with Engines Rails::Engine 允許你包裝特定的 Rails 應用程式或功能子集，並與其他應用程式共享或在更大的封裝應用程式中。每個 Rails::Application 都只是一個引擎，它允許簡單的功能及應用程式共享。 任何 Rails::Engine 也是一個 Rails::Railtie，所以在 railties 可用的相同方法（如 rake_tasks 和 generators）和配置選項也可用於引擎。 在本指南中，你將瞭解引擎以及如何透過乾淨且非常易於使用的介面，為主應用程式提供附加功能。","text":"原文：Ruby on Rails Guides — Getting Started with Engines Rails::Engine 允許你包裝特定的 Rails 應用程式或功能子集，並與其他應用程式共享或在更大的封裝應用程式中。每個 Rails::Application 都只是一個引擎，它允許簡單的功能及應用程式共享。 任何 Rails::Engine 也是一個 Rails::Railtie，所以在 railties 可用的相同方法（如 rake_tasks 和 generators）和配置選項也可用於引擎。 在本指南中，你將瞭解引擎以及如何透過乾淨且非常易於使用的介面，為主應用程式提供附加功能。 閱讀本指南後，你將知道： 是什麼構成了引擎。 如何產生引擎。 如何為引擎建立功能。 如何將引擎掛載到應用程式中。 如何在應用程式中覆寫引擎功能。 透過載入和配置 Hook 避免載入 Rails 框架。 1. 什麼是引擎？引擎可以看成是為主應用程式提供功能的微型應用程式。Rails 應用程式實際上只是一個「增壓」引擎，Rails::Application 類別繼承了許多來自 Rails::Engine 的行為。 因此，引擎和應用程式可以被認為是幾乎相同的東西，只有存在細微的差異，你將在本指南中看到。引擎和應用程式也共享一個公用的結構。 引擎也與外掛程式密切相關。兩者共享一個公用的 lib 目錄結構，並且都是使用 rails plugin new 產生器產生的。不同之處在於，引擎被 Rails 視為一個「完整外掛程式」（如傳遞給產生器指令的 --full 選項所示）。我們實際上會在此處使用 --mountable 選項，其中包含 --full 的所有功能，甚至更多。本指南全文將這些「完整外掛程式」簡稱為「引擎」。引擎可以是外掛程式，外掛程式可以是引擎。 將在本指南中建立的引擎稱為「blorgh」。此引擎將為其主應用程式提供部落格功能，允許建立新文章和評論。在本指南的開頭，你將獨自在引擎內工作，但在後面的章節中，你將看到如何將其掛載到應用程式中。 引擎也可以與主應用程式隔離。意思是應用程式可以擁有路由輔助方法提供的路徑，如 articles_path，並使用一個也提供了名為 articles_path 路徑的引擎，而且兩者不會發生衝突。除此之外，控制器、模型和資料表名稱也具有命名空間。本指南稍後將介紹如何執行此操作。 重要的是在任何時候牢記這一點，應用程式應該總是優先於其引擎。應用程式是對其環境中發生的事情有最終決定權的物件。引擎應該只是加強它，而不是徹底改變它。 查看其他引擎的範例，查看 Devise，一個為其父應用程式提供身份驗證的引擎，或 Thredded，一個提供論壇功能的引擎。還有 Spree 提供電子商務平台，以及 Refinery CMS，一個 CMS 引擎。 最後，如果沒有 James Adam、Piotr Sarnacki、Rails 核心團隊和其他一些人的工作，引擎是不可能實現的。如果你見過他們，別忘了說聲謝謝！ 2. 產生一個引擎要產生引擎，你需要執行外掛程式產生器並根據需求將選項傳遞給它。對於「blorgh」範例，你需要建立一個「可掛載的」引擎，在終端機中執行此指令： 1$ rails plugin new blorgh --mountable 輸入以下內容即可看到外掛程式產生器的完整選項清單： 1$ rails plugin --help --mountable 選項告訴產生器你想建立一個「可掛載的」且命名空間隔離的引擎。此產生器將提供與 --full 選項相同的骨架結構。--full 選項告訴產生器你想建立一個引擎，包含提供以下內容的骨架結構： 一個 app 目錄樹 一個 config/routes.rb 檔案： 12Rails.application.routes.draw doend 一個在 lib/blorgh/engine.rb 的檔案，其功能與標準 Rails 應用程式的 config/application.rb 檔案相同： 1234module Blorgh class Engine &lt; ::Rails::Engine endend --mountable 選項會加入 --full 選項： 靜態資源清單檔案（application.js 和 application.css） 一個具有命名空間的 ApplicationController 一個具有命名空間的 ApplicationHelper 引擎的佈局視圖樣板 命名空間隔離的 config/routes.rb： 12Blorgh::Engine.routes.draw doend 命名空間隔離的 lib/blorgh/engine.rb： 12345module Blorgh class Engine &lt; ::Rails::Engine isolate_namespace Blorgh endend 此外，--mountable 選項透過將以下內容加到虛擬應用程式的路由檔案 test/dummy/config/routes.rb，告訴產生器將引擎掛載到位於 test/dummy 的虛擬測試應用程式中： 1mount Blorgh::Engine =&gt; \"/blorgh\" 2.1 引擎內部2.1.1 關鍵檔案在這個全新引擎的根目錄有個 blorgh.gemspec 檔案。當你稍後將引擎掛載到應用程式中時，你將在 Rails 應用程式的 Gemfile 中使用此行進行操作： 1gem 'blorgh', path: 'engines/blorgh' 不要忘記像往常一樣執行 bundle install。透過在 Gemfile 中指定它作為一個 gem，Bundler 將載入它，解析此 blorgh.gemspec 檔案並載入 lib 目錄中的一個名為 lib/blorgh.rb 的檔案。這個檔案載入了 blorgh/engine.rb 檔案（位於 lib/blorgh/engine.rb）並定義了一個名為 Blorgh 的基本模組。 1234require \"blorgh/engine\"module Blorghend 有些引擎選擇使用這個檔案為其引擎提供全域配置選項。這是一個比較好的想法，所以如果你想提供配置選項，那麼定義引擎 module 的檔案就是完美的選擇。把方法放到模組裡面就可以了。 lib/blorgh/engine.rb 是引擎的基底類別： 12345module Blorgh class Engine &lt; ::Rails::Engine isolate_namespace Blorgh endend 透過繼承 Rails::Engine 類別，這個 gem 會通知 Rails 在指定路徑上有一個引擎，並且將引擎正確地掛載到應用程式，執行諸如將引擎的 app 目錄加到模型、Mailer、控制器和視圖的載入路徑。 這裡的 isolate_namespace 方法值得特別注意。這個呼叫負責將控制器、模型、路由和其他東西隔離到自己的命名空間中，使其遠離應用程式內部的類似元件。沒有這個，引擎的元件就有可能「洩漏」到應用程式，造成不必要的中斷，或者重要的引擎元件可能會被應用程式中類似名稱的東西覆蓋。這種衝突的其中一個例子就是輔助方法。在不呼叫 isolate_namespace 的情況下，引擎的輔助方法將被包含在應用程式的控制器中。 高度推薦在 Engine 類別定義中保留 isolate_namespace。如果沒有它，引擎中產生的類別可能 會與應用程式發生衝突。 此命名空間的隔離意思是透過呼叫 bin/rails g model 產生的模型，如 bin/rails g model article，名稱不是 Article，而是具有命名空間的名稱 Blorgh::Article。另外，模型的資料表也具有命名空間，成為 blorgh_articles，而不僅僅是 articles。與模型命名空間類似，一個名為 ArticlesController 的控制器變成了 Blorgh::ArticlesController，並且該控制器的視圖不會在 app/views/articles，而是 app/views/blorgh/articles。Mailer 也具有命名空間。 最後，路由也被隔離在引擎內。這是命名空間中最重要的部分之一，稍後將在本指南的路由部分中進行討論。 2.1.2 app 目錄在 app 目錄中有標準的 assets、controllers、helpers、mailers、models 和 views 目錄，你應該已從應用程式對這些目錄瞭若指掌。helpers、mailers 和 models 目錄是空的，因此在本節中沒有描述它們。當我們編寫引擎時，我們將在未來的章節中更深入地研究模型。 在 app/assets 目錄中，有 images、javascripts 和 stylesheets 目錄，你應該早已熟悉這些目錄，因為它們與應用程式類似。然而，這裡的一個不同之處在於，每個目錄都包含一個帶有引擎名稱的子目錄。因為這個引擎具有命名空間，它的靜態資源也應該如此。 在 app/controllers 目錄中有一個 blorgh 目錄，其中包含了一個名為 application_controller.rb 的檔案。該檔案將為引擎的控制器提供任何公用功能。blorgh 目錄是存放引擎的其它控制器的地方。透過將它們放在這個命名空間的目錄中，可以防止它們與其它引擎甚至是應用程式中的同名控制器發生衝突。 引擎內的 ApplicationController 類別命名就像一個 Rails 應用程式，以便更容易將應用程式轉換為引擎。 因為 Ruby 不斷尋找的方式，你可能會遇到一種狀況，你的控制器繼承自主應用程式控制器，而不是你的引擎應用程式控制器。Ruby 能夠解析 ApplicationController 常數，因此不會觸發自動載入機制。有關更多詳細資訊，請查看自動載入和重新載入常數指南中的常數什麼時候不被忽略章節。預防這種狀況發生最好的方法是使用 require_dependency 來確保引擎的應用程式控制器已被載入。例如： 12345678# app/controllers/blorgh/articles_controller.rb:require_dependency \"blorgh/application_controller\"module Blorgh class ArticlesController &lt; ApplicationController ... endend 不要使用 require，因為它會中斷開發環境中類別的自動重新載入，使用 require_dependency 確保類別以正確的方式載入和卸除。 最後，app/views目錄中有一個 layouts 資料夾，其中包含了一個檔案在 blorgh/application.html.erb。該檔案允許你指定引擎的佈局。如果此引擎要作為獨立引擎使用，那麼你可以在此檔案中加入任何對佈局的客製化，而不是應用程式的 app/views/layouts/application.html.erb 檔案。 如果不希望對引擎的使用者強制佈局，那麼可以刪除此檔案並在引擎的控制器中引用不同的佈局。 2.1.3 bin 目錄這個目錄包含一個 bin/rails 檔案，它讓你能夠像在應用程式中一樣使用 rails 子指令和產生器。也就是說，你可以很容易地透過執行這樣的指令來產生新的控制器和模型： 1$ bin/rails g model 請記住，在 Engine 類別中具有 isolate_namespace 的引擎內部使用這些指令產生的任何東西，都將具有命名空間。 2.1.4 test 目錄test 目錄是用來存放引擎測試的地方。為了測試引擎，在 test/dummy 中嵌入了一個精簡版的 Rails 應用程式。這個應用程式會將引擎掛載到 test/dummy/config/routes.rb 檔案： 123Rails.application.routes.draw do mount Blorgh::Engine =&gt; \"/blorgh\"end 該行將引擎掛載到 /blorgh 路徑上，這將使應用程式僅能透過該路徑存取它。 在測試目錄裡面有 test/integration 目錄，引擎的整合測試應該放在這裡。也可以在 test 目錄中建立其它目錄。例如，你可能希望為模型測試建立一個 test/models 目錄。 3. 提供引擎功能本指南涵蓋的引擎提供了送交文章和評論的功能，遵循與入門指南類似的思路，並伴隨一些新的觀點。 3.1 產生 Article 資源產生部落格引擎的第一件事是 Article 模型和相關的控制器。要快速建立這個，你可以使用 Rails 鷹架產生器。 1$ bin/rails generate scaffold article title:string text:text 該指令會輸出以下資訊： 12345678910111213141516171819202122232425262728293031invoke active_recordcreate db/migrate/[timestamp]_create_blorgh_articles.rbcreate app/models/blorgh/article.rbinvoke test_unitcreate test/models/blorgh/article_test.rbcreate test/fixtures/blorgh/articles.ymlinvoke resource_route route resources :articlesinvoke scaffold_controllercreate app/controllers/blorgh/articles_controller.rbinvoke erbcreate app/views/blorgh/articlescreate app/views/blorgh/articles/index.html.erbcreate app/views/blorgh/articles/edit.html.erbcreate app/views/blorgh/articles/show.html.erbcreate app/views/blorgh/articles/new.html.erbcreate app/views/blorgh/articles/_form.html.erbinvoke test_unitcreate test/controllers/blorgh/articles_controller_test.rbinvoke helpercreate app/helpers/blorgh/articles_helper.rbinvoke test_unitcreate test/application_system_test_case.rbcreate test/system/articles_test.rbinvoke assetsinvoke jscreate app/assets/javascripts/blorgh/articles.jsinvoke csscreate app/assets/stylesheets/blorgh/articles.cssinvoke csscreate app/assets/stylesheets/scaffold.css 鷹架產生器所做的第一件事是呼叫 active_record 產生器，它為資源產生遷移和模型。但是請注意，遷移被命名為 create_blorgh_articles，而不是常見的 create_articles。這是由於 Blorgh::Engine 類別的定義中呼叫 isolate_namespace 方法造成的。這裡的模型也具有命名空間，由於 Engine 類別中呼叫 isolate_namespace，所以放在 app/models/blorgh/article.rb 而不是 app/models/article.rb。 接下來，為此模型呼叫 test_unit 產生器，在 test/models/blorgh/article_test.rb（而不是 test/models/article_test.rb）產生一個模型測試，並在 test/fixtures/blorgh/articles.yml（而不是 test/fixtures/articles.yml）產生測試資料。 然後，插入一行資源路由到引擎的 config/routes.rb 檔案。這一行只是 resources :articles，將引擎的 config/routes.rb 檔案變成這樣： 123Blorgh::Engine.routes.draw do resources :articlesend 這裡請注意，路由是被定義在 Blorgh::Engine 物件上，而不是 YourApp::Application 類別。這是為了使引擎路由被限制在引擎本身，並且如測試目錄部分所示可以掛載在特定點上。它還會使引擎的路由與應用程式內的路由隔離。本指南的路由部分有詳細的說明。 接下來，scaffold_controller 產生器被呼叫，產生一個名為 Blorgh::ArticlesController（在 app/controllers/blorgh/articles_controller.rb）的控制器及其相關視圖在 app/views/blorgh/articles。此產生器還為控制器產生測試（test/controllers/blorgh/articles_controller_test.rb）和輔助方法（app/helpers/blorgh/articles_helper.rb）。 這個產生器建立的所有東西都具有命名空間。控制器的類別被定義在 Blorgh 模組： 12345module Blorgh class ArticlesController &lt; ApplicationController ... endend ArticlesController 類別繼承自 Blorgh::ApplicationController，而不是應用程式的 ApplicationController。 app/helpers/blorgh/articles_helper.rb 中的輔助方法也具有命名空間： 12345module Blorgh module ArticlesHelper ... endend 這有助於防止與任何其它可能具有文章資源的引擎或應用程式發生衝突。 最後，產生了兩個靜態資源檔案：app/assets/javascripts/blorgh/articles.js 和 app/assets/stylesheets/blorgh/articles.css。稍後你會看到如何使用這些東西。 你可以透過在引擎的根目錄執行 bin/rails db:migrate 來執行由鷹架產生器產生的遷移，然後在 test/dummy 中執行 rails server 來查看引擎的內容。當你開啟 http://localhost:3000/blorgh/articles 時，將看到已產生的預設鷹架。點看看吧！你剛剛產生了你的第一個引擎的第一個功能。 如果你更喜歡使用主控台，也可以像 Rails 應用程式一樣使用 rails console。記住：Article 模型是具有命名空間的，因此要引用它，你必須稱呼它為 Blorgh::Article。 12&gt;&gt; Blorgh::Article.find(1)=&gt; #&lt;Blorgh::Article id: 1 ...&gt; 最後一件事是這個引擎的 articles 資源應該是引擎的根。每當有人進入掛載引擎的根路徑時，應該顯示文章列表。如果將此行插入引擎內的 config/routes.rb 檔案中，便可以實現這一點： 1root to: \"articles#index\" 現在人們只需要到引擎的根目錄來查看所有文章，而不是訪問 /articles。意思是現在你只需要去 http://localhost:3000/blorgh，而不是 http://localhost:3000/blorgh/articles。 3.2 產生 Comments 資源現在，引擎可以建立新的文章，那麼加上評論功能也是有意義的。為此，你需要建立評論模型、評論控制器，然後修改文章鷹架以顯示評論並允許人們建立新評論。 從應用程式根目錄執行模型產生器。告訴它產生一個 Comment 模型，資料表有兩欄：integer 型別的 article_id 和 text 型別的 text 欄位。 1$ bin/rails generate model Comment article_id:integer text:text 這將輸出以下內容： 123456invoke active_recordcreate db/migrate/[timestamp]_create_blorgh_comments.rbcreate app/models/blorgh/comment.rbinvoke test_unitcreate test/models/blorgh/comment_test.rbcreate test/fixtures/blorgh/comments.yml 該產生器呼叫將產生它所需的必要模型檔案，將檔案放在命名空間 blorgh 目錄下，並建立一個名為 Blorgh::Comment 的模型類別。現在執行遷移來建立我們的 blorgh_comments 資料表： 1$ bin/rails db:migrate 要在文章上顯示評論，編輯 app/views/blorgh/articles/show.html.erb 並在「編輯」連結前加上此行： 12&lt;h3&gt;Comments&lt;/h3&gt;&lt;%= render @article.comments %&gt; 這一行需要在 Blorgh::Article 模型中定義一個 has_many 關聯的評論，不過現在還沒有。要定義它，開啟 app/models/blorgh/article.rb 並將這一行加到模型中： 1has_many :comments 將模型變成： 12345module Blorgh class Article &lt; ApplicationRecord has_many :comments endend 因為 has_many 是在 Blorgh 模組的一個類別中定義的，Rails 會知道你想為這些物件使用 Blorgh::Comment 模型，所以不需要在這裡指定使用 :class_name 選項。 接下來，需要有一個表單，以便可以在文章上建立評論。要加上它，在 app/views/blorgh/articles/show.html.erb 中呼叫呈現 @article.comments 的下方加上這一行： 1&lt;%= render \"blorgh/comments/form\" %&gt; 接下來，這一行將呈現的部分視圖需要存在。建立一個新目錄在 app/views/blorgh/comments，並且建立一個名為 _form.html.erb 的新檔案，該檔案包含這些內容以便建立所需的部分視圖： 12345678&lt;h3&gt;New comment&lt;/h3&gt;&lt;%= form_with(model: [@article, @article.comments.build], local: true) do |form| %&gt; &lt;p&gt; &lt;%= form.label :text %&gt;&lt;br&gt; &lt;%= form.text_area :text %&gt; &lt;/p&gt; &lt;%= form.submit %&gt;&lt;% end %&gt; 送交此表單時，它將嘗試對引擎內的 /articles/:article_id/comments 路由執行 POST 請求。此路由目前不存在，但是可以透過將 config/routes.rb 中的 resources :articles 更改為以下幾行來建立： 123resources :articles do resources :commentsend 這會為評論建立一個表單所需要的巢狀路由。 路由現在已經存在了，但是此路由所去的控制器還不存在。要建立它，從應用程式根目錄執行這個指令： 1$ bin/rails g controller comments 該指令會輸出以下資訊： 123456789101112create app/controllers/blorgh/comments_controller.rbinvoke erb exist app/views/blorgh/commentsinvoke test_unitcreate test/controllers/blorgh/comments_controller_test.rbinvoke helpercreate app/helpers/blorgh/comments_helper.rbinvoke assetsinvoke jscreate app/assets/javascripts/blorgh/comments.jsinvoke csscreate app/assets/stylesheets/blorgh/comments.css 該表單會向 /articles/:article_id/comments 發出 POST 請求，對應到 Blorgh::CommentsController 中的 create 動作。這個動作需要被建立，可以透過在 app/controllers/blorgh/comments_controller.rb 的類別定義中放入以下幾行來完成： 1234567891011def create @article = Article.find(params[:article_id]) @comment = @article.comments.create(comment_params) flash[:notice] = \"Comment has been created!\" redirect_to articles_pathendprivate def comment_params params.require(:comment).permit(:text) end 這是讓新評論表單運作所需的最後一步。然而，顯示評論還不太正確。如果你現在要建立評論，則會看到此錯誤： 1234Missing partial blorgh/comments/_comment with &#123;:handlers=&gt;[:erb, :builder],:formats=&gt;[:html], :locale=&gt;[:en, :en]&#125;. Searched in: *\"/Users/ryan/Sites/side_projects/blorgh/test/dummy/app/views\" *\"/Users/ryan/Sites/side_projects/blorgh/app/views\" 引擎無法找到呈現評論所需的部分視圖。Rails 會先尋找應用程式的（test/dummy）app/views目錄，然後在引擎的 app/views 目錄中尋找。當找不到它時，便會拋出這個錯誤。引擎知道要尋找 blorgh/comments/_comment，因為它接收的模型物件是來自 Blorgh::Comment 類別。 目前，這個部分視圖僅負責呈現評論文字。在 app/views/blorgh/comments/_comment.html.erb 建立新一個檔案，並將此行放入其中： 1&lt;%= comment_counter + 1 %&gt;. &lt;%= comment.text %&gt; comment_counter 區域變數是由呼叫 &lt;%= render @article.comments %&gt; 給我們的，它會自動定義並在迭代每個評論時遞增計數器。在這個例子中，它用於在每個評論建立時顯示一個小數字。 完成了部落格引擎的評論功能。現在是時候在應用程式中使用它了。 4. 安裝到應用程式在應用程式中使用引擎非常簡單。本節會介紹如何將引擎掛載到應用程式和所需的初始設定，以及將引擎連結到由應用程式提供的 User 類別，以便為引擎中的文章和評論提供所有權。 4.1 掛載引擎首先，需要在應用程式的 Gemfile 中指定引擎。如果沒有應用程式可以方便地進行測試，可以像這樣在引擎目錄外使用 rails new 指令產生一個： 1$ rails new unicorn 通常，可以像一般的 gem 一樣，透過在 Gemfile 內將引擎指定在內來完成。 1gem 'devise' 但是，因為你正在本機上開發 blorgh 引擎，你需要在 Gemfile 指定 :path 選項： 1gem 'blorgh', path: 'engines/blorgh' 然後執行 bundle 來安裝 gem。 如先前所述，透過將 gem 放在 Gemfile 中，它將會在 Rails 載入時被載入。它會先從引擎載入 lib/blorgh.rb，然後是 lib/blorgh/engine.rb，它是定義引擎主要功能的檔案。 要讓引擎的功能可以從應用程式存取，需要將它掛載到應用程式的 config/routes.rb 檔案： 1mount Blorgh::Engine, at: \"/blog\" 這一行會將引擎掛載到應用程式中的 /blog。當應用程式以 rails server 執行時，可以在 http://localhost:3000/blog 上訪問它。 其他引擎，如 Devise，透過讓你在路由中指定自訂輔助方法（例如 devise_for）來處理這一點。這些輔助方法完成相同的事，將引擎的部分功能掛載到預先定義可客製化的路徑上。 4.2 安裝引擎引擎包含需要在應用程式資料庫中建立的 blorgh_articles 和 blorgh_comments 資料表的遷移，以便引擎的模型可以正確查詢它們。要將這些遷移複製到應用程式中，請從 Rails 引擎的 test/dummy 目錄執行以下指令： 1$ bin/rails blorgh:install:migrations 如果你有多個需要複製遷移的引擎，請改用 railties:install:migrations： 1$ bin/rails railties:install:migrations 第一次執行這個指令時，將複製引擎中的所有遷移。下次執行時，它只會複製尚未被複製的遷移。第一次執行指令會輸出以下資訊： 12Copied migration [timestamp_1]_create_blorgh_articles.blorgh.rb from blorghCopied migration [timestamp_2]_create_blorgh_comments.blorgh.rb from blorgh 第一個時間戳記（[timestamp_1]）將是目前時間，第二個時間戳記（[timestamp_2]）將是目前時間加上一秒。之所以這樣做是為了在應用程式中任何現有的遷移之後執行引擎的遷移。 要在應用程式中執行這些遷移，只需執行：bin/rails db:migrate。當透過 http://localhost:3000/blog 訪問引擎時，文章會是空的。這是因為在應用程式建立的資料表與引擎內建立的資料表不同。繼續，玩玩新掛載的引擎吧。你會發現它和只有一個引擎時是相同的。 如果你只想從一個引擎執行遷移，可以透過指定 SCOPE 來完成： 1bin/rails db:migrate SCOPE=blorgh 如果你想在刪除引擎之前還原引擎的遷移，這可能很有用。要還原 blorgh 引擎的所有遷移，你可以執行以下指令： 1bin/rails db:migrate SCOPE=blorgh VERSION=0 4.3 使用應用程式提供的類別4.3.1 使用應用程式提供的模型引擎建立後，可能需要使用應用程式中的特定類別來提供引擎和應用程式之間的連結。以 blorgh 引擎的情況來說，讓文章和評論有作者會很有意義。 一個典型的應用程式可能有一個 User 類別，用於表示文章或評論的作者。但可能會出現這樣的情況，應用程式以不同名稱命名此類別，如 Person。因此，引擎不應該明確的為 User 類別寫死關聯。 為了在這種情況下保持簡單，應用程式將有一個名為 User 的類別，來表示應用程式的使用者（我們將進一步進行配置）。它可以在應用程式中使用這個指令產生： 1$ bin/rails g model user name:string 需要在這裡執行 bin/rails db:migrate 指令，以確保我們的應用程式有 users 資料表供將來使用。 同樣地，為了簡單起見，文章表單會有一個名為 author_name 的新文字欄位，使用者可以選擇放置他們的名字。引擎將使用這個名稱建立一個新的 User 物件或者尋找一個擁有該名稱的物件。引擎會將文章與找到或建立的 User 物件建立關聯。 首先，author_name 文字欄位需要被加到引擎內的 app/views/blorgh/articles/_form.html.erb 部分視圖。可以在 title 欄位上方加入以下程式碼： 1234&lt;div class=\"field\"&gt; &lt;%= form.label :author_name %&gt;&lt;br&gt; &lt;%= form.text_field :author_name %&gt;&lt;/div&gt; 接下來，我們需要更新 Blorgh::ArticleController#article_params 方法來允許新的表單參數： 123def article_params params.require(:article).permit(:title, :text, :author_name)end Blorgh::Article 模型應該有一些程式碼將 author_name 欄位轉換為一個實際的 User 物件，並在儲存文章前將其關聯為該文章的 author。它還需要為此欄位設定一個 attr_accessor，以便為其定義設值（setter）方法和取值（getter）方法。 為此，你需要在 app/models/blorgh/article.rb 為 author_name 加上 attr_accessor、作者的關聯和 before_validation 呼叫。author 關聯會暫時寫死到 User 類別。 123456789attr_accessor :author_namebelongs_to :author, class_name: \"User\"before_validation :set_authorprivate def set_author self.author = User.find_or_create_by(name: author_name) end 透過用 User 類別表示 author 關聯的物件，在引擎和應用程式之間建立了一個連結。需要有一種方法將 blorgh_articles 資料表中的記錄與 users 資料表中的記錄關聯起來。因為該關聯名為 author，所以應該在 blorgh_articles 資料表中加上 author_id 欄位。 要產生這個新欄位，請在引擎中執行這個指令： 1$ bin/rails g migration add_author_id_to_blorgh_articles author_id:integer 由於遷移的名稱和後面的欄位說明，Rails 會自動知道你想要將欄位加到特定資料表，並將其寫入遷移中。因此不用手動編寫遷移。 這個遷移需要在應用程式上執行。為此，首先必須使用這個指令複製它： 1$ bin/rails blorgh:install:migrations 請注意，這裡只複製了一個遷移。這是因為前兩次遷移已經在第一次執行這個指令時被複製了。 123NOTE Migration [timestamp]_create_blorgh_articles.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.NOTE Migration [timestamp]_create_blorgh_comments.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.Copied migration [timestamp]_add_author_id_to_blorgh_articles.blorgh.rb from blorgh 使用以下指令執行遷移： 1$ bin/rails db:migrate 現在，一切都已經到位，我們完成了作者（用 users 資料表中的記錄表示）與文章（用引擎的 blorgh_articles 資料表中的記錄表示）的關聯。 最後，作者的名稱應該會顯示在文章頁面。在 app/views/blorgh/articles/show.html.erb 內的「標題」輸出上方加上以下程式碼： 1234&lt;p&gt; &lt;b&gt;Author:&lt;/b&gt; &lt;%= @article.author.name %&gt;&lt;/p&gt; 4.3.2 使用應用程式提供的控制器預設情況下，由於 Rails 控制器通常會透過繼承 ApplicationController 共享程式碼，例如身份驗證和存取 session 變數。然而，Rails 引擎的作用域與主應用程式是隔離的，因此每個引擎的 ApplicationController 都具有獨立的命名空間。獨立的命名空間可避免程式碼衝突，但是引擎的控制器常常需要存取主應用程式的 ApplicationController 中的方法。提供存取的簡單方法是讓引擎具有命名空間的 ApplicationController 繼承自主應用程式的 ApplicationController。對於我們的 Blorgh 引擎，可以透過以下改變 app/controllers/blorgh/application_controller.rb 來完成： 1234module Blorgh class ApplicationController &lt; ::ApplicationController endend 所以，在做出這個改變之後，他們可以訪問主應用程序的ApplicationController，就好像它們是主應用程序的一部分。預設情況下，引擎的控制器繼承自 Blorgh::ApplicationController。因此透過上述修改，它們將能夠存取主應用程式的 ApplicationController，就好像它們是主應用程式的一部分。 此修改的前提是，引擎需要執行在具有 ApplicationController 的 Rails 應用程式。 4.4 設定引擎本節介紹如何讓 User 類別成為可配置的，然後介紹引擎的基本配置注意事項。 4.4.1 在應用程式中設定配置下一步是讓引擎可以客製化在應用程式中所使用的 User 類別。如先前所述，該類別並非總是 User。為了使這個配置可客製化，引擎將有一個名為 author_class 的配置，它將用於指定哪個類別代表應用程式中的使用者。 要定義此配置，你應該在引擎的 Blorgh 模組中使用 mattr_accessor。將此行加到引擎內的 lib/blorgh.rb 中： 1mattr_accessor :author_class 這個方法的工作原理與 attr_accessor 和 cattr_accessor 類似，會根據指定名稱為模組提供設值（setter）方法和取值（getter）方法。使用時直接呼叫 Blorgh.author_class 即可。 下一步是將 Blorgh::Article 模型切換到這個新設定。修改這個模型（app/models/blorgh/article.rb）的 belongs_to 關聯： 1belongs_to :author, class_name: Blorgh.author_class Blorgh::Article 模型中的 set_author 方法也應該使用此類別： 1self.author = Blorgh.author_class.constantize.find_or_create_by(name: author_name) 為了避免每次都要對 author_class 結果呼叫 constantize，我們可以在 lib/blorgh.rb 檔案中覆寫 Blorgh 模組的 author_class 取值（getter）方法，在回傳結果之前呼叫 constantize： 123def self.author_class @@author_class.constantizeend 此時，上述的 set_author 程式碼將變為： 1self.author = Blorgh.author_class.find_or_create_by(name: author_name) 修改後的結果更為簡短，行為更加明確。author_class 方法應該總是回傳 Class 物件。 因為修改後的 author_class 方法回傳 Class 而不是 String，我們還需要修改 Blorgh::Article 模型中的 belongs_to 定義： 1belongs_to :author, class_name: Blorgh.author_class.to_s 要在應用程式設定此配置，應該使用初始化程式。透過初始化程式，配置會在應用程式啟動且呼叫引擎的模型前完成設定，這可能取決於現有的配置設定。 在安裝 blorgh 引擎的應用程式中，建立一個新的初始化程式在 config/initializers/blorgh.rb，並放入以下內容： 1Blorgh.author_class = \"User\" 重要的是這裡使用字串版本的類別，而不是直接使用類別。如果我們直接使用類別，Rails 會嘗試載入該類別並引用相關資料表。如果資料表不存在，可能會導致問題產生。因此，應該使用字串，然後在引擎中透過 constantize 將其轉換為類別。 接下來嘗試新增一篇文章。你會發現過程和之前相同，不過這次引擎使用的是 config/initializers/blorgh.rb 內配置設定的類別。 現在，不用在意使用者類別到底是什麼，只需要確認使用者類別是否實作所需的 API。引擎只要求使用者類別實作了 find_or_create_by 方法，此方法回傳了使用者類別的物件，以便在建立文章時與其相關聯。當然，這個物件應該有某種可以被引用的識別碼。 4.4.2 引擎基本配置有時候你可能會想在引擎中使用初始化程式、國際化或其它配置選項。這些事情是可以的，因為 Rails 引擎和 Rails 應用程式共享很多相同的功能。事實上，Rails 應用程式的功能實際上是由引擎提供的功能的超集合！ 如果你希望使用初始化程式（載入引擎前應該執行的程式碼），儲存的位置是在它的 config/initializers 資料夾。此目錄的功能在配置指南的初始化程式章節有說明，並且與應用程式中的 config/initializers 目錄完全相同。如果你想使用標準的初始化程式，也是一樣的。 對於語系設定，只需將語系檔案放在 config/locales 目錄，如同在應用程式中一樣。 5. 測試引擎當引擎建立後，會在 test/dummy 中建立一個小型的虛擬應用程式。這個應用程式被用作引擎的裝載點，使引擎測試非常簡單。你可以透過在目錄中產生控制器、模型或視圖來擴充此應用程式，然後用它們來測試你的引擎。 test 目錄和典型的 Rails 測試環境一樣，支援單元測試、功能測試和整合測試。 5.1 功能測試在編寫功能測試時，一件值得考慮的事是測試會在 test/dummy 應用程式上執行，而不是引擎。這是由測試環境的設定決定的，引擎需要裝載在應用程式才能測試其主要功能，尤其是控制器。也就是說，如果你在控制器的功能測試中像這樣為控制器編寫一個典型的 GET 請求： 12345678910module Blorgh class FooControllerTest &lt; ActionDispatch::IntegrationTest include Engine.routes.url_helpers def test_index get foos_url ... end endend 它的功能還無法正確運作。這是因為應用程式不知道如何將這些請求傳遞到引擎，除非你明確的告訴它如何處理。為此，你必須在程式中將 @routes 實例變數設定為引擎的路由： 1234567891011121314module Blorgh class FooControllerTest &lt; ActionDispatch::IntegrationTest include Engine.routes.url_helpers setup do @routes = Engine.routes end def test_index get foos_url ... end endend 這告訴應用程式你想對此控制器的 index 動作執行一個 GET 請求，但你想使用引擎的路由，而不是應用程式的路由。 這也確保了引擎的 URL 輔助方法能夠在測試中正常運作。 6. 改進引擎功能本節介紹如何在 Rails 主應用程式中加入或覆寫引擎的 MVC 功能。 6.1 覆寫模型和控制器在 Rails 主應用程式中，可以透過打開類別來擴充引擎模型和控制器類別（因為模型和控制器類別只是繼承 Rails 特定功能的 Ruby 類別）。透過打開類別，可以根據主應用程式的需求重新定義引擎的類別。通常會透過裝飾器模式來實作。 對於簡單的類別修改，可以使用 Class#class_eval。對於複雜的類別修改，可以考慮使用 ActiveSupport::Concern。 6.1.1 使用裝飾器和載入代碼時的注意事項因為這些裝飾器沒有被 Rails 應用程式本身引用，Rails 的自動載入系統不會載入你的裝飾器。也就是說，你需要自己載入它們。 以下是執行此操作的一些範例程式碼： 123456789101112# lib/blorgh/engine.rbmodule Blorgh class Engine &lt; ::Rails::Engine isolate_namespace Blorgh config.to_prepare do Dir.glob(Rails.root + \"app/decorators/**/*_decorator*.rb\").each do |c| require_dependency(c) end end endend 這不僅適用於裝飾器，也適用於任何加入到引擎中但未被主應用程式引用的東西。 6.1.2 使用 Class#class_eval 實作裝飾器模式加入 Article#time_since_created： 1234567# MyApp/app/decorators/models/blorgh/article_decorator.rbBlorgh::Article.class_eval do def time_since_created Time.current - created_at endend 12345# Blorgh/app/models/article.rbclass Article &lt; ApplicationRecord has_many :commentsend 覆寫 Article#summary： 1234567# MyApp/app/decorators/models/blorgh/article_decorator.rbBlorgh::Article.class_eval do def summary \"#&#123;title&#125; - #&#123;truncate(text)&#125;\" endend 12345678# Blorgh/app/models/article.rbclass Article &lt; ApplicationRecord has_many :comments def summary \"#&#123;title&#125;\" endend 6.1.3 使用 ActiveSupport::Concern 實作裝飾器模式使您可以顯著模塊化您的代碼。使用 Class#class_eval 非常適合簡單的調整，但是對於更複雜的類別修改，你可能需要考慮使用 ActiveSupport::Concern。ActiveSupport::Concern 能管理互相關聯相依模組和類別執行時的載入順序，讓你可以放心模組化你的程式碼。 加入 Article#time_since_created 並覆寫 Article#summary： 12345678910111213# MyApp/app/models/blorgh/article.rbclass Blorgh::Article &lt; ApplicationRecord include Blorgh::Concerns::Models::Article def time_since_created Time.current - created_at end def summary \"#&#123;title&#125; - #&#123;truncate(text)&#125;\" endend 12345# Blorgh/app/models/article.rbclass Article &lt; ApplicationRecord include Blorgh::Concerns::Models::Articleend 1234567891011121314151617181920212223242526272829# Blorgh/lib/concerns/models/article.rbmodule Blorgh::Concerns::Models::Article extend ActiveSupport::Concern # 'included do' 內的程式碼可以在被載入的地方（article.rb）執行，而不是在 # 模組內（blorgh/concerns/models/article）被執行。 included do attr_accessor :author_name belongs_to :author, class_name: \"User\" before_validation :set_author private def set_author self.author = User.find_or_create_by(name: author_name) end end def summary \"#&#123;title&#125;\" end module ClassMethods def some_class_method 'some class method string' end endend 6.2 覆寫視圖當 Rails 在尋找要呈現的視圖時，它首先會在應用程式的 app/views 目錄中尋找。如果找不到，接著就會在所有引擎的 app/views目錄中尋找。 當應用程式要呈現 Blorgh::ArticlesController 的 index 動作的視圖時，它會先在應用程式中尋找 app/views/blorgh/articles/index.html.erb 檔案。如果找不到，接著會在引擎中尋找。 你可以透過在應用程式中建立 app/views/blorgh/articles/index.html.erb 檔案來覆寫這個視圖。然後可以完全改變這個視圖輸出的內容。 現在試著建立 app/views/blorgh/articles/index.html.erb 檔案並放入以下內容： 12345678&lt;h1&gt;Articles&lt;/h1&gt;&lt;%= link_to \"New Article\", new_article_path %&gt;&lt;% @articles.each do |article| %&gt; &lt;h2&gt;&lt;%= article.title %&gt;&lt;/h2&gt; &lt;small&gt;By &lt;%= article.author %&gt;&lt;/small&gt; &lt;%= simple_format(article.text) %&gt; &lt;hr&gt;&lt;% end %&gt; 6.3 路由預設情況下，引擎與應用程式的路由是隔離的。這是透過在 Engine 類別中呼叫 isolate_namespace 完成的。也就是說，應用程式及其引擎可以具有相同名稱的路由，並且它們不會發生衝突。 在 config/routes.rb 檔案中，可以在 Engine 類別上定義引擎的路由： 123Blorgh::Engine.routes.draw do resources :articlesend 因為路由是隔離的，如果你想從應用程式中連結到引擎的某個位置時，必須使用引擎的路由代理方法。呼叫一般路由方法如 articles_path 可能會產生非預期的連結，因為應用程式和引擎可能都定義了這個輔助方法。 例如，就以下範例來說，如果是從應用程式呈現樣板，就會指向應用程式的 articles_path，如果是從引擎呈現樣板，則會指向引擎的 articles_path： 1&lt;%= link_to \"Blog articles\", articles_path %&gt; 要確保使用的是引擎的 articles_path 路由輔助方法，我們必須透過與引擎相同名稱的路由代理方法來呼叫這個輔助方法。 1&lt;%= link_to \"Blog articles\", blorgh.articles_path %&gt; 如果你想用類似的方式在引擎內引用應用程式，可以使用 main_app 輔助方法： 1&lt;%= link_to \"Home\", main_app.root_path %&gt; 如果你在引擎中使用上述程式碼，它會總是指向應用程式的根目錄。若不使用 main_app 「路由代理」方法，它可能會指向引擎或應用程式的根目錄，取決於從何處呼叫它。 如果嘗試從引擎中呈現的樣板使用應用程式的路由輔助方法，可能會導致呼叫未定義的方法。如果遇到此類問題，請確保你沒有嘗試在引擎內沒有 main_app 前綴的情況下呼叫應用程式的路由輔助方法。 6.4 靜態資源引擎內的資源與完整應用程式的工作方式相同。由於引擎類別繼承自 Rails::Engine，應用程式會知道在引擎的 app/assets 和 lib/assets 目錄中尋找靜態資源。 和引擎的所有其它元件一樣，靜態資源應該具有命名空間。也就是說，如果你有一個名為 style.css 的靜態資源，它應該被放在 app/assets/stylesheets/[engine name]/style.css，而不是 app/assets/stylesheets/style.css。如果靜態資源不具有命名空間，主應用程式可能會有一個相同名稱的靜態資源，在這種情況下，應用程式的靜態資源會具有較高的優先權，引擎的靜態資源將被忽略。 想像一下，你有一個靜態資源位於 app/assets/stylesheets/blorgh/style.css，要在應用程式中載入此檔案，只需使用 stylesheet_link_tag 並引用靜態資源即可： 1&lt;%= stylesheet_link_tag \"blorgh/style.css\" %&gt; 你也可以使用 Asset Pipeline 的 require 語法來載入引擎中的靜態資源： 123/* *= require blorgh/style*/ 記住，若要使用 Sass 或 CoffeeScript 等語言，你應該將相關函式庫加到引擎的 .gemspec。 6.5 獨立的靜態資源和預先編譯有時候，主應用程式不需要載入引擎的靜態資源。例如，你建立了僅存在於引擎中的管理功能。在這種情況下，主應用程式不需要載入 admin.css 或 admin.js。只有 gem 的管理後台才需要這些靜態資源。主應用程式在其樣式表中載入 blorgh/admin.css 是沒有意義的。在這種情況下，你應該明確定義這些需要預先編譯的靜態資源。這會告訴 Sprockets 在觸發 bin/rails assets:precompile 時加入你的引擎靜態資源。 你可以在 engine.rb 定義需要預先編譯的靜態資源： 123initializer \"blorgh.assets.precompile\" do |app| app.config.assets.precompile += %w( admin.js admin.css )end 更多相關資訊，請參閱 Asset Pipeline 指南。 6.6 其它相依 Gem引擎的相依套件應該在引擎跟目錄下的 .gemspec 檔案中指定。因為我們可能會以 gem 的方式安裝引擎。如果在引擎的 Gemfile 指定相依套件，那麼 gem install 將無法識別這些相依關係，因此它們不會被安裝，從而導致引擎發生故障。 要指定當 gem install 時應該和引擎一起安裝的相依套件，只需要在引擎中 .gemspec 檔案的 Gem::Specification 區塊內指定： 1s.add_dependency \"moo\" 還可以像這樣指定僅用於開發環境的相依套件： 1s.add_development_dependency \"moo\" 在應用程式內執行 bundle install 時，這兩種相依套件都會被安裝。用於開發環境的相依套件只有在執行引擎測試時才會使用。 注意，如果要在引擎載入時立即載入相依套件，你應該在引擎初始化前就載入它們。例如： 1234567require 'other_engine/engine'require 'yet_another_engine/engine'module MyEngine class Engine &lt; ::Rails::Engine endend 所以當你過早載入某些框架時（例如，ActiveRecord::Base），你就違反了使用 Rails 應用程式的使用慣例 7. Active Support 的 on_load HookActive Support 是 Ruby on Rails 元件，負責提供 Ruby 語言擴充套件和公用程式。 Rails 程式碼通常可以在應用程式載入時引用。Rails 負責這些框架的載入順序，所以當你過早載入某些框架時（例如 ActiveRecord::Base），就違反了 Rails 應用程式的使用慣例。此外，透過在應用程式啟動時載入如 ActiveRecord::Base 等程式碼，你正在載入整個框架，這可能會降低啟動時間，並可能導致載入順序與應用程式啟動發生衝突。 on_load API 能夠讓我們在初始化的流程中掛載你所需要的功能，而不違反 Rails 所制定的規則。這也將緩解啟動效能下降並避免衝突。 8. 什麼是 on_load Hook？由於 Ruby 是動態語言，因此某些程式碼會導致載入相關的 Rails 元件。以此程式碼片段為例： 1ActiveRecord::Base.include(MyActiveRecordHelper) 當這段程式碼片段被載入時，發現有 ActiveRecord::Base，因此 Ruby 會去尋找該常數的定義並載入它。這將導致整個 Active Record 框架在啟動時被載入。 ActiveSupport.on_load 是一種延遲載入程式碼的機制，直到真正需要時才載入。上述代碼可以修改為： 1ActiveSupport.on_load(:active_record) &#123; include MyActiveRecordHelper &#125; 新的程式碼片段會在 ActiveRecord::Base 載入後才載入 MyActiveRecordHelper。 9. 它是如何運作的？在 Rails 框架中，載入特定函式庫時會呼叫這些 hook。例如，當 ActionController::Base 被載入時，會呼叫 :action_controller_base hook。也就是說，ActiveSupport.on_load 呼叫設定用的 :action_controller_base hook 會在 ActionController::Base 環境中被呼叫。（因此 self 是 ActionController::Base 的實例變數）。 10. 修改程式碼，使用 on_load Hook修改程式碼很簡單。如果你有一行引用 Rails 框架的程式碼，例如 ActiveRecord::Base，你可以將該程式碼包裝在 on_load hook 中。 10.1 範例 11ActiveRecord::Base.include(MyActiveRecordHelper) 改為 1ActiveSupport.on_load(:active_record) &#123; include MyActiveRecordHelper &#125; # self 在這裡指的是 ActiveRecord::Base，所以可以直接呼叫 #include 10.2 範例 21ActionController::Base.prepend(MyActionControllerHelper) 改為 1ActiveSupport.on_load(:action_controller_base) &#123; prepend MyActionControllerHelper &#125; # self 在這裡指的是 ActionController::Base，所以可以直接呼叫 #prepend 10.3 範例 31ActiveRecord::Base.include_root_in_json = true 改為 1ActiveSupport.on_load(:active_record) &#123; self.include_root_in_json = true &#125; # self 在這裡指的是 ActiveRecord::Base 11. 可用的 Hook這些是可以在程式碼中使用的 hook。 要接上以下某個類別的初始化過程，請使用可用的 hook。 類別 可用的 Hook ActionCable action_cable ActionController::API action_controller_api ActionController::API action_controller ActionController::Base action_controller_base ActionController::Base action_controller ActionController::TestCase action_controller_test_case ActionDispatch::IntegrationTest action_dispatch_integration_test ActionDispatch::SystemTestCase action_dispatch_system_test_case ActionMailer::Base action_mailer ActionMailer::TestCase action_mailer_test_case ActionView::Base action_view ActionView::TestCase action_view_test_case ActiveJob::Base active_job ActiveJob::TestCase active_job_test_case ActiveRecord::Base active_record ActiveSupport::TestCase active_support_test_case i18n i18n 12. 配置 Hook這些是可用的配置 hook。它們並沒有涉及到任何特定的框架，而是在整個應用程式中執行。 Hook 使用案例 before_configuration 第一個執行的配置區塊。在所有初始化程式執行前呼叫。 before_initialize 第二個執行的配置區塊。框架初始化前呼叫。 before_eager_load 第三個執行的配置區塊。config.eager_load 設為 false 時不執行。 after_initialize 最後執行的配置區塊。框架初始化完成後呼叫。 12.1 範例1config.before_configuration &#123; puts 'I am called before any initializers' &#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://calvertyang.github.io/tags/Ruby-on-Rails/"},{"name":"Rails Engine","slug":"Rails-Engine","permalink":"https://calvertyang.github.io/tags/Rails-Engine/"}]},{"title":"在 Heroku 使用 Active Storage","slug":"active-storage-on-heroku","date":"2018-05-22T03:34:34.000Z","updated":"2019-11-15T08:50:11.879Z","comments":true,"path":"2018/05/22/active-storage-on-heroku/","link":"","permalink":"https://calvertyang.github.io/2018/05/22/active-storage-on-heroku/","excerpt":"原文：HEROKU BLOG — Rails 5.2 Active Storage: Previews, Poppler, and Solving Licensing Pitfalls 上個月剛剛發佈的 Rails 5.2 有一個重要的新功能：Active Storage。Active Storage 支援各種後端服務（如 AWS S3），為 Active Record 模型提供檔案上傳和附件功能。雖然有像 Paperclip 這樣的函式庫來做類似的工作，但這是 Rails 第一次發佈這樣的功能。在 Heroku，我們認為雲端儲存是最佳實作規範，所以我們確保它能在我們的平台上執行。在這篇文章中，我們將分享如何準備發佈 Rails 5.2，以及如何在部署的應用程式中使用新的 Active Storage 功能。","text":"原文：HEROKU BLOG — Rails 5.2 Active Storage: Previews, Poppler, and Solving Licensing Pitfalls 上個月剛剛發佈的 Rails 5.2 有一個重要的新功能：Active Storage。Active Storage 支援各種後端服務（如 AWS S3），為 Active Record 模型提供檔案上傳和附件功能。雖然有像 Paperclip 這樣的函式庫來做類似的工作，但這是 Rails 第一次發佈這樣的功能。在 Heroku，我們認為雲端儲存是最佳實作規範，所以我們確保它能在我們的平台上執行。在這篇文章中，我們將分享如何準備發佈 Rails 5.2，以及如何在部署的應用程式中使用新的 Active Storage 功能。 信任但要驗證在 Heroku，信任是我們的第一價值。當我們得知 Active Storage 隨著 Rails 5.2 發佈時，我們開始嘗試使用它的所有功能。Active Storage 其中一個最便利的功能就是能夠預覽 PDF 和影片。PDF 或影片的小截圖將從檔案中擷取並呈現在頁面上，而不是透過文字連結到資源。 測試版的 Rails 5.2 使用了熱門的開源工具 FFmpeg 和 MuPDF 來產生影片和 PDF 預覽。透過我們的安全及法務部門審查了這些新的二進位相依檔案，我們發現 MuPDF 採用 AGPL 授權條款，並且需要商業許可才能使用。如果我們在預設情況下簡單地將 MuPDF 加到 Rails 5.2+ 的應用程式中，我們的許多客戶會不知道他們需要購買 MuPDF 才能在商業上使用它。 AGPL 授權條款的限制在 2017 年 9 月引起公眾關注。為了準備 5.2 版本，我們的工程師 Terence Lee 致力於更新 Active Storage，以便 PDF 預覽功能也可以使用沒有商業許可的開源後端程式。我們在 2018 年 2 月向 Rails 提交了一個 PR，介紹採用 poppler PDF 作為 MuPDF 的替代方案的能力。該 PR 大約在 1 個月後被合併，現在任何 Rails 5.2 使用者，無論是否在 Heroku，都無需購買商業許可即可呈現 PDF 預覽。 展示在 Heroku 使用 Active Storage如果你已經有實作 Active Storage 的應用程式，則可以跳轉到我們開發中心的 Active Storage 文件。 或者，你可以使用我們的應用程式範例。這是一個 Rails 5.2 應用程式，它是數位布告欄，允許使用者張貼影片、PDF 和圖片。你可以在 Github 檢視原始碼或用 Heroku 按鈕部署應用程式： 注意：這個應用程式範例需要付費的 S3 附加元件。 以下是該應用程式的範例影片。 當你開啟首頁時，選擇適當的資源檔，然後送出表單。在影片中，mp4 檔案被上傳到 S3，然後透過 ffmpeg 幫助 Rails 產生預覽。很簡約。 在 Heroku 使用 Active Storage如果你使用按鈕部署應用程式範例，它已經透過 app.json 設定能在 Heroku 上運作，但是，如果你有自己的應用程式想要部署，你要如何設定它以便在 Heroku 上運作？ 根據開發中心的 Active Storage 文件，你將需要一個檔案儲存服務，讓你所有的 dynos 都可以與其溝通。該範例使用名為 Bucketeer 的 Heroku S3 附加元件，但你也可以使用現有的 S3 憑證。 馬上開始，請將 S3 的 AWS gem 加到 Gemfile，如果你要修改圖片，請加入 Mini Magick： 12gem \"aws-sdk-s3\", require: falsegem 'mini_magick', '~&gt; 4.8' 更新 Gemfile 後別忘了 $ bundle install。 接下來，在你的 config/storage.yml 檔案中加入一個 amazon 選項來指向 S3 設定，在這個範例中我們使用了由 Bucketeer 設定的配置： 123456amazon: service: S3 access_key_id: &lt;%= ENV['BUCKETEER_AWS_ACCESS_KEY_ID'] %&gt; secret_access_key: &lt;%= ENV['BUCKETEER_AWS_SECRET_ACCESS_KEY'] %&gt; region: &lt;%= ENV['BUCKETEER_AWS_REGION'] %&gt; bucket: &lt;%= ENV['BUCKETEER_BUCKET_NAME'] %&gt; 然後確保你的應用程式設定為在生產環境中使用 :amazon 儲存配置： 1config.active_storage.service = :amazon 如果你忘記了這一步，預設的儲存是使用 :local 將檔案儲存到磁碟。這不是處理生產環境中上傳檔案的可擴展方式。如果你不小心將它部署到 Heroku，首先它會顯示檔案已上傳，但是如果你執行超過一個 dyno，他們會在隨機的請求中消失。當重新啟動 dynos 時，這些檔案將完全消失。你可以在開發中心取得有關 Heroku 的臨時磁碟的更多資訊。 最後，要使其在生產環境中運作的最後一件事是安裝一個客制的建置套件，它將安裝用來產生資源預覽的二進位相依檔案 ffmpeg 和 poppler： 1$ heroku buildpacks:add -i 1 https://github.com/heroku/heroku-buildpack-activestorage-preview 一但你完成了，就可以部署到 Heroku！ 將 Active Storage 加到現有應用程式如果你的應用程式還沒有 Active Storage，可以把它加入。首先，你需要執行以下指令啟用 Active Storage： 1$ bin/rails active_storage:install 這會新增一個遷移，讓 Rails 追蹤上傳的檔案。 接下來，你需要一個模型來「附加」檔案。你可以使用現有模型或建立新模型。在應用程式範例中，使用了幾乎是空的 bulletin 模型： 1$ bin/rails generate scaffold bulletin 接下來，在應用程式上執行遷移： 1$ bin/rails db:migrate 在資料庫遷移後，更新模型讓 Rails 知道你打算讓它能夠附加檔案： 123class Bulletin &lt; ApplicationRecord has_one_attached :attachmentend 一旦完成，我們還需要三個部分：上傳附件的表單、儲存附件的控制器以及呈現附件的視圖。 如果你有一個現有的表單，你可以透過 file_field 視圖輔助方法加入一個附件欄位： 1&lt;%= form.file_field :attachment %&gt; 你可以在應用程式範例中看到帶有附件的表單範例。一旦有了表單，你將需要保存附件。 在這個應用程式範例中，首頁包含了表單和視圖。附件在 bulletin 控制器被儲存，然後將使用者導回主布告列表： 1234567def create @bulletin = Bulletin.new() @bulletin.attachment.attach(params[:bulletin][:attachment]) @bulletin.save! redirect_back(fallback_location: root_path)end 最後，在 welcome 視圖中，我們迭代每個布告項目，並根據我們的附件類型，以不同的方式呈現。 在 Active Storage 中，對於 PDF 和影片，只要系統安裝了正確的二進位檔案，previewable? 方法將回傳 true。對於圖片，如果安裝了 mini_magick，variable? 方法將回傳 true。如果這些都不是 true，那麼附件可能是一個最好在下載後查看的檔案。下面展示了我們如何表示該邏輯： 1234567891011121314&lt;ul class=\"no-bullet\"&gt; &lt;% @bulletin_list.each do |bulletin| %&gt; &lt;li&gt; &lt;% if bulletin.attachment.previewable? %&gt; &lt;%= link_to(image_tag(bulletin.attachment.preview(resize: \"200x200&gt;\")), rails_blob_path(bulletin.attachment, disposition: \"attachment\")) %&gt; &lt;% elsif bulletin.attachment.variable? %&gt; &lt;%= link_to(image_tag(bulletin.attachment.variant(resize: \"200x200\")), rails_blob_path(bulletin.attachment, disposition: \"attachment\"))%&gt; &lt;% else %&gt; &lt;%= link_to \"Download file\", rails_blob_path(bulletin.attachment, disposition: \"attachment\") %&gt; &lt;% end %&gt; &lt;/li&gt; &lt;% end %&gt;&lt;/ul&gt; 一旦你完成以上所有步驟，並將 Active Storage 設定為在生產環境中運作，使用者就可以輕鬆上傳和下載檔案。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://calvertyang.github.io/tags/Ruby-on-Rails/"},{"name":"Active Storage","slug":"Active-Storage","permalink":"https://calvertyang.github.io/tags/Active-Storage/"},{"name":"Heroku","slug":"Heroku","permalink":"https://calvertyang.github.io/tags/Heroku/"}]},{"title":"Active Storage 概要","slug":"active-storage-overview","date":"2018-05-18T04:00:33.000Z","updated":"2018-08-15T08:59:50.000Z","comments":true,"path":"2018/05/18/active-storage-overview/","link":"","permalink":"https://calvertyang.github.io/2018/05/18/active-storage-overview/","excerpt":"原文：Ruby on Rails Guides — Active Storage Overview Active Storage 是 Rails 5.2 所新增的功能，它可以讓你輕鬆的將檔案傳送到 Amazon S3、Google Cloud Storage 或 Microsoft Azure Storage 等雲端儲存服務，並將這些檔案附加到 Active Record。 支援一個主要雲端儲存服務，並在其它服務中建立鏡像以實現備援機制，它也提供了用於測試或本地部署的磁碟服務，但重點還是放在雲端儲存。 檔案可以從伺服器上傳到雲端或直接從客戶端上傳到雲端。","text":"原文：Ruby on Rails Guides — Active Storage Overview Active Storage 是 Rails 5.2 所新增的功能，它可以讓你輕鬆的將檔案傳送到 Amazon S3、Google Cloud Storage 或 Microsoft Azure Storage 等雲端儲存服務，並將這些檔案附加到 Active Record。 支援一個主要雲端儲存服務，並在其它服務中建立鏡像以實現備援機制，它也提供了用於測試或本地部署的磁碟服務，但重點還是放在雲端儲存。 檔案可以從伺服器上傳到雲端或直接從客戶端上傳到雲端。 閱讀本指南後，你將知道： 如何附加一或多個檔案到記錄。 如何刪除檔案。 如何連結到檔案。 如何使用變體（variant）來轉換圖片。 如何產生非圖片檔案的預覽圖，如 PDF 或影片。 如何繞過應用程式伺服器，直接從瀏覽器上傳檔案到儲存服務。 如何清理測試過程中儲存的檔案。 如何實作對其它雲端儲存服務的支援。 1. 什麼是 Active Storage?Active Storage 方便將檔案上傳到 Amazon S3、Google Cloud Storage 或 Microsoft Azure Storage 等雲端儲存服務，並將這些檔案附加到 Active Record 物件。它配備了本地磁碟服務以進行開發和測試，並支援將檔案鏡像到次要服務以進行備份和遷移。 使用 Active Storage，應用程式可以透過 ImageMagick 轉換上傳圖片，產生非圖片檔案（如 PDF 或影片）的預覽圖，並從任意檔案中提取中繼資料。 2. 安裝Active Storage 在應用程式資料庫中使用兩個名為 active_storage_blobs 和 active_storage_attachments 的資料表。建立新的應用程式（或將應用程式升級到 Rails 5.2），執行 rails active_storage:install 來產生用來建立這些資料表的遷移。使用 rails db:migrate 來執行遷移。 在 config/storage.yml 定義 Active Storage 服務。對應用程式使用的每個服務，提供一個名稱和必要的設定。下面的範例定義了三個名為 local、test 和 amazon 的服務： 123456789101112local: service: Disk root: &lt;%= Rails.root.join(\"storage\") %&gt;test: service: Disk root: &lt;%= Rails.root.join(\"tmp/storage\") %&gt;amazon: service: S3 access_key_id: \"\" secret_access_key: \"\" 透過設定 Rails.application.config.active_storage.service 告訴 Active Storage 要使用哪個服務。由於每個環境都可能使用不同的服務，因此建議在每個環境的基礎設定上進行。要在開發環境中使用先前範例中的磁碟服務，你可以將以下內容加到 config/environments/development.rb： 12# 在本地儲存檔案。config.active_storage.service = :local 要在生產環境使用 Amazon S3，你可以將以下內容加到 config/environments/production.rb： 12# 在 Amazon S3 儲存檔案。config.active_storage.service = :amazon 繼續閱讀來取得關於內建服務轉接器（如 Disk 和 S3）及其所需設定的更多資訊。 2.1. 磁碟服務在 config/storage.yml 定義磁碟服務： 123local: service: Disk root: &lt;%= Rails.root.join(\"storage\") %&gt; 2.2. Amazon S3 服務在 config/storage.yml 定義 S3 服務： 123456amazon: service: S3 access_key_id: \"\" secret_access_key: \"\" region: \"\" bucket: \"\" 將 aws-sdk-s3 gem 加到 Gemfile： 1gem \"aws-sdk-s3\", require: false Active Storage 的核心功能需要以下權限：s3:ListBucket、s3:PutObject、s3:GetObject 和 s3:DeleteObject。如果你設定了其它上傳選項，如 ACL 設定，則可能需要額外的權限。 如果你想使用環境變數、標準 SDK 設定檔、設定檔、IAM 實例設定檔或工作角色，則可以省略上面範例中的 access_key_id、secret_access_key 和 region 值。Amazon S3 服務支援 AWS SDK 文件中描述的所有認證選項。 2.3. Microsoft Azure Storage 服務在 config/storage.yml 定義 Azure Storage 服務： 12345azure: service: AzureStorage storage_account_name: \"\" storage_access_key: \"\" container: \"\" 將 azure-storage gem 加到 Gemfile： 1gem \"azure-storage\", require: false 2.4. Google Cloud Storage 服務在 config/storage.yml 定義 Google Cloud Storage 服務： 12345google: service: GCS credentials: &lt;%= Rails.root.join(\"path/to/keyfile.json\") %&gt; project: \"\" bucket: \"\" 可以選擇提供一個 Hash 憑證來取代密鑰路徑： 123456789101112131415google: service: GCS credentials: type: \"service_account\" project_id: \"\" private_key_id: &lt;%= Rails.application.credentials.dig(:gcs, :private_key_id) %&gt; private_key: &lt;%= Rails.application.credentials.dig(:gcs, :private_key) %&gt; client_email: \"\" client_id: \"\" auth_uri: \"https://accounts.google.com/o/oauth2/auth\" token_uri: \"https://accounts.google.com/o/oauth2/token\" auth_provider_x509_cert_url: \"https://www.googleapis.com/oauth2/v1/certs\" client_x509_cert_url: \"\" project: \"\" bucket: \"\" 將 google-cloud-storage gem 加到 Gemfile： 1gem \"google-cloud-storage\", \"~&gt; 1.8\", require: false 2.5. 鏡像服務你可以透過定義鏡像服務來讓多個服務保持同步。當檔案被上傳或刪除時，它會在所有鏡像服務中完成。鏡像服務可用來幫助生產環境中服務之間的遷移。你可以開始鏡像到新服務，將現有檔案從舊服務複製到新服務，然後全力投入新服務。根據上述定義你想要使用的每項服務，從鏡像服務中引用它們。 12345678910111213141516171819s3_west_coast: service: S3 access_key_id: \"\" secret_access_key: \"\" region: \"\" bucket: \"\"s3_east_coast: service: S3 access_key_id: \"\" secret_access_key: \"\" region: \"\" bucket: \"\"production: service: Mirror primary: s3_east_coast mirrors: - s3_west_coast 檔案由主服務提供。 與直接上傳功能不相容。 3. 將檔案附加到記錄3.1. has_one_attachedhas_one_attached 指令設定了記錄和檔案間的一對一關係。每個記錄可以附加一個檔案。 例如，假設你的應用程式有一個 User 模型。如果想讓每個使用者都有一個頭像，請這樣定義 User 模型： 123class User &lt; ApplicationRecord has_one_attached :avatarend 你可以建立一個帶有頭像的使用者： 123456789101112class SignupController &lt; ApplicationController def create user = User.create!(user_params) session[:user_id] = user.id redirect_to root_path end private def user_params params.require(:user).permit(:email_address, :password, :avatar) endend 呼叫 avatar.attach 將頭像附加到現有使用者： 1Current.user.avatar.attach(params[:avatar]) 呼叫 avatar.attached? 來確定特定使用者是否有頭像： 1Current.user.avatar.attached? 3.2. has_many_attachedhas_many_attached 指令設定了記錄和檔案間的一對多關係。每個記錄可以附加多個檔案。 例如，假設你的應用程式有一個 Message 模型。如果想讓每個訊息都有多張圖片，請這樣定義 Message 模型： 123class Message &lt; ApplicationRecord has_many_attached :imagesend 你可以建立一則帶有多張圖片的訊息： 1234567891011class MessagesController &lt; ApplicationController def create message = Message.create!(message_params) redirect_to message end private def message_params params.require(:message).permit(:title, :content, images: []) endend 呼叫 images.attach 將圖片附加到現有訊息： 1@message.images.attach(params[:images]) 呼叫 images.attached? 來確定特定訊息是否有圖片： 1@message.images.attached? 3.3 附加 File/IO 物件有時候你需要附加一個不是透過 HTTP 請求傳送的檔案。例如，你可能需要附加從磁碟上產生的檔案，或從使用者提交的網址下載的檔案。你可能也想在模型測試中附加檔案。要做到這一點，至少提供包含一個開啟 IO 物件和檔案名稱的 Hash： 1@message.image.attach(io: File.open('/path/to/file'), filename: 'file.pdf') 如果可能，最好提供內容類型。Active Storage 會嘗試從資料來確定檔案的內容類型。若辦不到，它將採用你提供的內容類型。 1@message.image.attach(io: File.open('/path/to/file'), filename: 'file.pdf', content_type: 'application/pdf') 如果你未提供內容類型，且 Active Storage 無法自動確定檔案的內容類型，則預設為 application/octet-stream。 譯者註：若使用 AJAX 來送出表單，可能會出現 No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. 的錯誤訊息，以 Amazon S3 為例，需要登入 AWS 後台修改 CORS 設定，設定範例如下： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;CORSConfiguration xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\"&gt;&lt;CORSRule&gt; &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt; &lt;AllowedMethod&gt;GET&lt;/AllowedMethod&gt; &lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt; &lt;AllowedHeader&gt;Authorization&lt;/AllowedHeader&gt;&lt;/CORSRule&gt;&lt;CORSRule&gt; &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt; &lt;AllowedMethod&gt;PUT&lt;/AllowedMethod&gt; &lt;AllowedMethod&gt;POST&lt;/AllowedMethod&gt; &lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt; &lt;AllowedHeader&gt;*&lt;/AllowedHeader&gt;&lt;/CORSRule&gt;&lt;/CORSConfiguration&gt; 4. 刪除檔案要從模型中刪除附件，請在附件上呼叫 purge。如果你的應用程式有設定使用 Active Job，刪除作業可以在背景完成。刪除作業會從儲存服務中刪除 blob 和檔案。 12345# 同步刪除頭像和實際資源檔案。user.avatar.purge# 透過 Active Job 非同步刪除相關模型和實際資源檔案。user.avatar.purge_later 5. 檔案連結為 blob 產生一個指向應用程式的永久連結。存取時，會返回一個重新導向到實際服務端點的連結。這種間接的方式將公開網址從實際網址分離開來，並允許例如鏡像不同服務中的附件以實現高可用性。重新導向連結的 HTTP 過期時間為 5 分鐘。 1url_for(user.avatar) 要建立下載連結，請使用 rails_blob_{path|url} 輔助方法。使用這個輔助方法可以讓你設定 disposition。 1rails_blob_path(user.avatar, disposition: \"attachment\") 如果你需要從控制器或視圖之外建立連結（背景作業、定時作業、等⋯），可以像這樣存取 rails_blob_path： 1Rails.application.routes.url_helpers.rails_blob_path(user.avatar, only_path: true) 6. 下載檔案如果需要在伺服器端處理 blob，例如，執行分析或進一步轉換時，可以用以下方式下載 blob 並取得二進位物件： 1binary = user.avatar.download 某些時候，您可能希望將其轉換為磁碟上的實體檔案，以便將檔案路徑傳遞給外部程式（如掃毒軟體、轉換程式、優化程式、壓縮程式等⋯）。在這種情況下，你可以在類別中引用 ActiveStorage::Downloading 模組，該模組提供了輔助方法直接下載檔案，避免將檔案儲存到記憶體中。ActiveStorage::Downloading 需要定義一個 blob 方法。 123456789101112131415class VirusScanner include ActiveStorage::Downloading attr_reader :blob def initialize(blob) @blob = blob end def scan download_blob_to_tempfile do |file| system 'scan_virus', file.path end endend 預設情況下，download_blob_to_tempfile 會在 Dir.tmpdir 中建立檔案。如果需要使用其它目錄，請在類別中覆寫 ActiveStorage::Downloading#tempdir： 123456789class VirusScanner include ActiveStorage::Downloading # ... private def tempdir '/path/to/tmp' endend 如果外部程式是獨立執行的程式，你可能也需要 chmod 該檔案及其目錄，因為 Tempfile 會將權限設定為 0600，其它用戶無法存取該檔案。 7. 轉換圖片要建立不同尺寸的圖片，請在 Blob 上呼叫 variant。你可以傳送任何 MiniMagick 所支援的轉換方式到此方法。 要啟用轉換功能，請將 mini_magick gem 加到 Gemfile： 1gem 'mini_magick' 當瀏覽器存取不同尺寸的圖片網址時，Active Storage 會將原始的 blob 延遲轉換為指定的格式，並導向到它新的服務位置。 1&lt;%= image_tag user.avatar.variant(resize: \"100x100\") %&gt; 8. 預覽檔案一些非圖片檔案可以被預覽：也就是說，他們可以用圖片來呈現。例如，可以透過擷取第一個影格來預覽影片檔。Active Storage 內建支援預覽影片和 PDF 文件。 1234567&lt;ul&gt; &lt;% @message.files.each do |file| %&gt; &lt;li&gt; &lt;%= image_tag file.preview(resize: \"100x100&gt;\") %&gt; &lt;/li&gt; &lt;% end %&gt;&lt;/ul&gt; 擷取預覽圖片需要第三方應用程式，用於影片的 ffmpeg 和用於 PDF 的 mutool。這些函式庫不是由 Rails 提供的。你必須自行安裝他們才能使用內建的預覽器。在安裝和使用第三方軟體前，請確定你了解這樣做所牽涉的許可。 9. 直接上傳Active Storage 及其包含的 JavaScript 函式庫支援從客戶端直接上傳到雲端。 9.1. 安裝直接上傳功能 在應用程式的 JavaScript 封裝載入 activestorage.js。使用 Asset Pipeline： 1//= require activestorage 使用 npm 套件： 12import * as ActiveStorage from \"activestorage\"ActiveStorage.start() 在檔案輸入欄位中註記直接上傳。 1&lt;%= form.file_field :attachments, multiple: true, direct_upload: true %&gt; 就是這樣！在表單提交後會開始上傳檔案。 9.2. 直接上傳功能的 JavaScript 事件 事件名稱 事件目標 事件資料（event.detail） 描述 direct-uploads:start &lt;form&gt; 無 已提交包含直接上傳欄位的表單。 direct-upload:initialize &lt;input&gt; {id, file} 表單提交後，處理每個檔案。 direct-upload:start &lt;input&gt; {id, file} 開始直接上傳。 direct-upload:before-blob-request &lt;input&gt; {id, file, xhr} 向你的應用程式請求直接上傳中繼資料之前。 direct-upload:before-storage-request &lt;input&gt; {id, file, xhr} 請求儲存檔案之前。 direct-upload:progress &lt;input&gt; {id, file, progress} 請求儲存檔案的進度。 direct-upload:error &lt;input&gt; {id, file, error} 發生錯誤。除非此事件被取消，否則將顯示提醒。 direct-upload:end &lt;input&gt; {id, file} 直接上傳已結束。 direct-uploads:end &lt;form&gt; 無 所有直接上傳都已結束。 9.3. 範例你可以使用這些事件來顯示上傳的進度。 在表單內顯示上傳的檔案： 1234567891011121314151617181920212223242526272829303132333435363738// direct_uploads.jsaddEventListener(\"direct-upload:initialize\", event =&gt; &#123; const &#123; target, detail &#125; = event const &#123; id, file &#125; = detail target.insertAdjacentHTML(\"beforebegin\", ` &lt;div id=\"direct-upload-$&#123;id&#125;\" class=\"direct-upload direct-upload--pending\"&gt; &lt;div id=\"direct-upload-progress-$&#123;id&#125;\" class=\"direct-upload__progress\" style=\"width: 0%\"&gt;&lt;/div&gt; &lt;span class=\"direct-upload__filename\"&gt;$&#123;file.name&#125;&lt;/span&gt; &lt;/div&gt; `)&#125;)addEventListener(\"direct-upload:start\", event =&gt; &#123; const &#123; id &#125; = event.detail const element = document.getElementById(`direct-upload-$&#123;id&#125;`) element.classList.remove(\"direct-upload--pending\")&#125;)addEventListener(\"direct-upload:progress\", event =&gt; &#123; const &#123; id, progress &#125; = event.detail const progressElement = document.getElementById(`direct-upload-progress-$&#123;id&#125;`) progressElement.style.width = `$&#123;progress&#125;%`&#125;)addEventListener(\"direct-upload:error\", event =&gt; &#123; event.preventDefault() const &#123; id, error &#125; = event.detail const element = document.getElementById(`direct-upload-$&#123;id&#125;`) element.classList.add(\"direct-upload--error\") element.setAttribute(\"title\", error)&#125;)addEventListener(\"direct-upload:end\", event =&gt; &#123; const &#123; id &#125; = event.detail const element = document.getElementById(`direct-upload-$&#123;id&#125;`) element.classList.add(\"direct-upload--complete\")&#125;) 加上樣式： 123456789101112131415161718192021222324252627282930313233343536373839/* direct_uploads.css */.direct-upload &#123; display: inline-block; position: relative; padding: 2px 4px; margin: 0 3px 3px 0; border: 1px solid rgba(0, 0, 0, 0.3); border-radius: 3px; font-size: 11px; line-height: 13px;&#125;.direct-upload--pending &#123; opacity: 0.6;&#125;.direct-upload__progress &#123; position: absolute; top: 0; left: 0; bottom: 0; opacity: 0.2; background: #0076ff; transition: width 120ms ease-out, opacity 60ms 60ms ease-in; transform: translate3d(0, 0, 0);&#125;.direct-upload--complete .direct-upload__progress &#123; opacity: 0.4;&#125;.direct-upload--error &#123; border-color: red;&#125;input[type=file][data-direct-upload-url][disabled] &#123; display: none;&#125; 9.4. 與函式庫或框架整合如果你想從 JavaScript 框架中使用直接上傳功能，或者想要整合自訂的拖放解決方案，可以使用 DirectUpload 類別來達成此目的。當從你的函式庫收到選擇的檔案後，實例化一個 DirectUpload 並呼叫它的 create 方法。當上傳完成時，create 會調用 callback。 12345678910111213141516171819202122232425262728293031323334353637import &#123; DirectUpload &#125; from \"activestorage\"const input = document.querySelector('input[type=file]')// 綁定到檔案放置 - 在父元素上使用 ondrop 或使用 Dropzone 之類的函式庫const onDrop = (event) =&gt; &#123; event.preventDefault() const files = event.dataTransfer.files; Array.from(files).forEach(file =&gt; uploadFile(file))&#125;// 綁定到正常的檔案選取input.addEventListener('change', (event) =&gt; &#123; Array.from(input.files).forEach(file =&gt; uploadFile(file)) // 你可以從輸入欄位清除選定的檔案 input.value = null&#125;)const uploadFile = (file) &#123; // 表單的檔案輸入欄位需要 direct_upload: true，它提供了 data-direct-upload-url const url = input.dataset.directUploadUrl const upload = new DirectUpload(file, url) upload.create((error, blob) =&gt; &#123; if (error) &#123; // 錯誤處理 &#125; else &#123; // 將適當名稱且值為 blob.signed_id 的隱藏輸入欄位加到表單中，以便 blob id 可以在 // 正常上傳流程中被傳送 const hiddenField = document.createElement('input') hiddenField.setAttribute(\"type\", \"hidden\"); hiddenField.setAttribute(\"value\", blob.signed_id); hiddenField.name = input.name document.querySelector('form').appendChild(hiddenField) &#125; &#125;)&#125; 如果你需要追蹤檔案上傳進度，可以傳送第三個參數給 DirectUpload 建構函數。在上傳過程中，DirectUpload 會呼叫物件的 directUploadWillStoreFileWithXHR 方法。然後，你可以在 XHR 上綁定自己的進度處理程式。 123456789101112131415161718192021222324252627import &#123; DirectUpload &#125; from \"activestorage\"class Uploader &#123; constructor(file, url) &#123; this.upload = new DirectUpload(this.file, this.url, this) &#125; upload(file) &#123; this.upload.create((error, blob) =&gt; &#123; if (error) &#123; // 錯誤處理 &#125; else &#123; // 將適當名稱且值為 blob.signed_id 的隱藏輸入欄位加到表單中，以便 blob id 可以在 // 正常上傳流程中被傳送 &#125; &#125;) &#125; directUploadWillStoreFileWithXHR(request) &#123; request.upload.addEventListener(\"progress\", event =&gt; this.directUploadDidProgress(event)) &#125; directUploadDidProgress(event) &#123; // 使用 event.loaded 和 event.total 來更新進度列 &#125;&#125; 10. 移除系統測試過程中儲存的檔案系統測試透過復原（Rollback）交易來清理測試資料。因為 destroy 永遠不會在對像上呼叫，所以附加的檔案永遠不會被清理。如果你想清除檔案，可以在 after_teardown callback 中完成。在此處操作可以確保測試過程中建立的連線都已完成，並且不會從 Active Storage 收到錯誤，表示無法找到檔案。 123456789101112class ApplicationSystemTestCase &lt; ActionDispatch::SystemTestCase driven_by :selenium, using: :chrome, screen_size: [1400, 1400] def remove_uploaded_files FileUtils.rm_rf(\"#&#123;Rails.root&#125;/storage_test\") end def after_teardown super remove_uploaded_files endend 如果你的系統測試驗證是否刪除帶有附件的模型，並且使用 Active Job，請將測試環境設定為使用行內佇列轉接器，以便立即執行清除工作，而不是在未來的某個時間執行。 你可能也想為測試環境使用單獨的服務定義，以便你的測試不會刪除在開發過程中建立的檔案。 12345# 使用行內作業處理，以便立即執行config.active_job.queue_adapter = :inline# 在測試環境中分開儲存檔案config.active_storage.service = :local_test 11. 實作支援其它雲端儲存服務如果你需要支援除了這些以外的雲端服務，則需要實作 Service。每個服務都透過實作上傳和下載檔案到雲端所需的方法，來擴充 ActiveStorage::Service。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://calvertyang.github.io/tags/Ruby-on-Rails/"},{"name":"Active Storage","slug":"Active-Storage","permalink":"https://calvertyang.github.io/tags/Active-Storage/"}]},{"title":"Electron API 範例","slug":"electron-api-demos","date":"2018-01-24T07:37:00.000Z","updated":"2019-11-15T08:50:11.876Z","comments":true,"path":"2018/01/24/electron-api-demos/","link":"","permalink":"https://calvertyang.github.io/2018/01/24/electron-api-demos/","excerpt":"","text":"因為最近在工作時需要使用 Electron，發現官方提供的 Electron API 應用程式範例很適合讓想入門的人了解一些基本 API 的用法以及實際執行的效果。 在 Github 上搜尋這個範例程式發現沒有正體中文版覺得有點可惜，於是就花了點時間來翻譯此範例程式。 原始碼可從 Github 下載，若有任何翻譯建議也歡迎提出。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://calvertyang.github.io/tags/Electron/"}]},{"title":"使用 RVG 繪圖","slug":"drawing-with-rvg","date":"2017-03-15T05:50:06.000Z","updated":"2019-11-15T08:50:11.861Z","comments":true,"path":"2017/03/15/drawing-with-rvg/","link":"","permalink":"https://calvertyang.github.io/2017/03/15/drawing-with-rvg/","excerpt":"原文：RMagick User’s Guide and Reference — Drawing with RVG 介紹RVG（Ruby 向量圖形）是 RMagick 的 Draw 類別的外觀，它提供了基於 W3C 推薦的可縮放向量圖形（Scalable Vector Graphics）的繪圖 API。 RVG 是一個可縮放向量繪圖函式庫。可縮放意味著圖形不是固定的像素尺寸。相同的圖形可以被呈現在螢幕上或列印出來。向量圖使用了幾何物件，如直線和圓。與點陣圖不同，向量圖在放大時不會「像素化」。 作為 RVG 函式庫的介紹，讓我們來看看如何畫出上面這隻小鴨。以下是完整的程式。 1234567891011121314151617181920212223242526272829303132333435363738require 'rvg/rvg'include MagickRVG::dpi = 72rvg = RVG.new(2.5.in, 2.5.in).viewbox(0,0,250,250) do |canvas| canvas.background_fill = 'white' canvas.g.translate(100, 150).rotate(-30) do |body| body.styles(:fill=&gt;'yellow', :stroke=&gt;'black', :stroke_width=&gt;2) body.ellipse(50, 30) body.rect(45, 20, -20, -10).skewX(-35) end canvas.g.translate(130, 83) do |head| head.styles(:stroke=&gt;'black', :stroke_width=&gt;2) head.circle(30).styles(:fill=&gt;'yellow') head.circle(5, 10, -5).styles(:fill=&gt;'black') head.polygon(30,0, 70,5, 30,10, 62,25, 23,20).styles(:fill=&gt;'orange') end foot = RVG::Group.new do |_foot| _foot.path('m0,0 v30 l30,10 l5,-10, l-5,-10 l-30,10z'). styles(:stroke_width=&gt;2, :fill=&gt;'orange', :stroke=&gt;'black') end canvas.use(foot).translate(75, 188).rotate(15) canvas.use(foot).translate(100, 185).rotate(-15) canvas.text(125, 30) do |title| title.tspan(\"duck|\").styles(:text_anchor=&gt;'end', :font_size=&gt;20, :font_family=&gt;'helvetica', :fill=&gt;'black') title.tspan(\"type\").styles(:font_size=&gt;22, :font_family=&gt;'times', :font_style=&gt;'italic', :fill=&gt;'red') end canvas.rect(249,249).styles(:stroke=&gt;'blue', :fill=&gt;'none') endrvg.draw.write('duck.gif') 摘要所有的繪圖都遵循相同的 3 個步驟： 建立一個 RVG 物件。指定最終圖片的寬度和高度。轉交程式碼區塊給 RVG.new 方法。 在程式區塊內，在 RVG 物件調用方法來指定背景，加入形狀、文字或點陣圖，或加入一組形狀、文字或點陣圖。 調用 draw 方法在背景繪出形狀、文字或點陣圖。 我將逐行介紹範例。","text":"原文：RMagick User’s Guide and Reference — Drawing with RVG 介紹RVG（Ruby 向量圖形）是 RMagick 的 Draw 類別的外觀，它提供了基於 W3C 推薦的可縮放向量圖形（Scalable Vector Graphics）的繪圖 API。 RVG 是一個可縮放向量繪圖函式庫。可縮放意味著圖形不是固定的像素尺寸。相同的圖形可以被呈現在螢幕上或列印出來。向量圖使用了幾何物件，如直線和圓。與點陣圖不同，向量圖在放大時不會「像素化」。 作為 RVG 函式庫的介紹，讓我們來看看如何畫出上面這隻小鴨。以下是完整的程式。 1234567891011121314151617181920212223242526272829303132333435363738require 'rvg/rvg'include MagickRVG::dpi = 72rvg = RVG.new(2.5.in, 2.5.in).viewbox(0,0,250,250) do |canvas| canvas.background_fill = 'white' canvas.g.translate(100, 150).rotate(-30) do |body| body.styles(:fill=&gt;'yellow', :stroke=&gt;'black', :stroke_width=&gt;2) body.ellipse(50, 30) body.rect(45, 20, -20, -10).skewX(-35) end canvas.g.translate(130, 83) do |head| head.styles(:stroke=&gt;'black', :stroke_width=&gt;2) head.circle(30).styles(:fill=&gt;'yellow') head.circle(5, 10, -5).styles(:fill=&gt;'black') head.polygon(30,0, 70,5, 30,10, 62,25, 23,20).styles(:fill=&gt;'orange') end foot = RVG::Group.new do |_foot| _foot.path('m0,0 v30 l30,10 l5,-10, l-5,-10 l-30,10z'). styles(:stroke_width=&gt;2, :fill=&gt;'orange', :stroke=&gt;'black') end canvas.use(foot).translate(75, 188).rotate(15) canvas.use(foot).translate(100, 185).rotate(-15) canvas.text(125, 30) do |title| title.tspan(\"duck|\").styles(:text_anchor=&gt;'end', :font_size=&gt;20, :font_family=&gt;'helvetica', :fill=&gt;'black') title.tspan(\"type\").styles(:font_size=&gt;22, :font_family=&gt;'times', :font_style=&gt;'italic', :fill=&gt;'red') end canvas.rect(249,249).styles(:stroke=&gt;'blue', :fill=&gt;'none') endrvg.draw.write('duck.gif') 摘要所有的繪圖都遵循相同的 3 個步驟： 建立一個 RVG 物件。指定最終圖片的寬度和高度。轉交程式碼區塊給 RVG.new 方法。 在程式區塊內，在 RVG 物件調用方法來指定背景，加入形狀、文字或點陣圖，或加入一組形狀、文字或點陣圖。 調用 draw 方法在背景繪出形狀、文字或點陣圖。 我將逐行介紹範例。 第 1 ~ 3 行12require 'rvg/rvg'include Magick 這只是平常用來載入 RVG 擴展的 Ruby 程式碼。為了少打一些字，我引入了 Magick 模組到物件的命名空間。 第 4 ~ 6 行123RVG::dpi = 72rvg = RVG.new(2.5.in, 2.5.in).viewbox(0,0,250,250) do |canvas| RVG::dpi 啟用了在 RVG 使用單位方法。當你將 RVG::dpi 設定為非 nil 值時，RVG 向整數和浮點數類別加入了許多轉換方法。這些方法允許你使用如英吋、毫米和厘米來指定測量單位。DPI 代表「每英吋點數」圖片解析度。這裡我設定 RVG::dpi 為 72，一個螢幕常用的數值。 RVG.new 需要 2 個參數。這些參數以像素指定最終圖片的寬度和高度。由於我定義了 RVG::dpi，我可以透過 in 轉換方法使用英吋指定這些數值。在 72dpi，最終圖片的邊長將會是 2.5 * 72 = 180 像素。 預設情況下，RVG 使用像素作為其測量單位，但由於我正在繪製一個可縮放的圖片，我不想限制自己的像素。viewbox 方法定義了一個具有邏輯單位的座標系。viewbox 需要 4 個參數，min_x、min_y、width 和 height。在第 6 行，我定義了我的座標系，它的原點在 (0,0)，寬度和高度為 250 單位。透過使用我自己的座標系，我可以稍後將圖片的尺寸更改為 5 英吋正方形或 1 英吋正方形，只需要更改 new 的參數。 預設座標系 預設情況下，RVG 座標系的原點在左上角。X 軸向右為正值，Y 軸向下為正值。上面的圖片顯示了該座標系的座標軸。我為範例圖片加上了淺藍色方格紙背景，以協助將坐標參數與圖片中的實際位置相關聯。只要記住，座標軸和方格紙背景實際上不是我產生的圖片的一部分。 RVG 類別是 RVG 定義的容器類別之一。容器物件可以包含圖形物件，如圓和線、文字、點陣圖及其他容器物件。最外面的容器永遠是 RVG 物件。我將加入所有組成鴨子的圖形物件到此容器。 我們通常會轉交一個程式區塊給容器建構方法。但是，在這裡我連接了 viewbox 到 new，所以 viewbox 負責產生並傳遞新的 RVG 實例到 canvas 參數。 第 7 行1canvas.background_fill = 'white' 預設情況下，RVG 圖形是繪製在透明背景上。當你想要顯示你的圖片在另一個圖片上時，這是很方便的。你可以透過為 background_fill= 屬性指定顏色來覆蓋預設背景顏色。這裡我設定背景顏色為「白色」。 第 9 ~ 13 行12345canvas.g.translate(100, 150).rotate(-30) do |body| body.styles(:fill=&gt;'yellow', :stroke=&gt;'black', :stroke_width=&gt;2) body.ellipse(50, 30) body.rect(45, 20, -20, -10).skewX(-35)end 這幾行做了很多事情，調用 7 個方法，所以讓我們一次介紹一個方法。 Groups（群組）Group 是 RVG 中的第二個容器類別。群組的目的是將一組座標系變形和一組樣式與群組中的圖形物件相關聯。要在另一個容器中建立群組物件，可調用容器上的 g 方法。如果程式區塊存在的話，g 方法會轉交給程式區塊。在這個範例中，沒有與 g 關聯的程式區塊，所以 g 返回了新群組。g 方法加入群組到其容器的內容。在這個範例中，群組的容器是在第 6 行建立的 canvas 物件。群組中的圖形物件會作為繪製容器的一部分被繪製。連接到 g 的 translate 和 rotate，透過_新增坐標系變形_來修改群組。 （那邊有一個程式區塊，但有個 2 方法調用在 g 和程式區塊間。我稍後會解釋。） Transforms（變形）我將使用這個群組來包含組成鴨子身體的橢圓和組成翅膀的矩形。我可以只指定 x 和 y 座標來定位這些形狀相對於原點的位置，但移動原點到我想繪製形狀的位置更容易。這是 translate 方法的目的。這個方法將原點移動到由其參數指定的（x,y）位置。我在群組物件上調用 translate，並且由群組的內容取得為此群組指定的座標系變形，橢圓和矩形將在相對於舊座標系原點的座標（100,150）上繪製。 另外，我想讓鴨子的身體向上傾斜，所以我使用 rotate 方法來旋轉座標軸。rotate 的參數是旋轉的角度。負數表示逆時針旋轉。 在平移及旋轉座標系後，座標軸看起來像這樣： 變形方法 有六種變形方法，除了 translate 和 rotate 外，還有 scale、skewX、skewY 和 matrix。當巢狀群組時，在內部群組上定義的任何變形都會被增加入外部變形。 Styles（樣式）回想一下，styles 方法修改了預設的群組樣式。styles 方法需要一個雜湊作為參數。雜湊的鍵是樣式名稱，雜湊的值為樣式值。在這個範例中，有三個樣式名稱。:fill 樣式將填充顏色設定為「黃色」。:stroke 樣式將邊框顏色設定為「黑色」。:stroke_width 樣式將邊框寬度設定為「2」。我想要樣式套用在全組內的所有物件，所以第 10 行我在新的群組物件上調用 style。 styles 方法是真正的主力。它幾乎在每個 RVG 的類別內都有定義，除了這三個之外還有許多其他樣式名稱。 Basic shapes（基本形狀）該群組包含了兩個基本形狀，一個橢圓和一個矩形。我使用 ellipse 方法將橢圓加入群組。ellipse 有四個參數，前兩個是在 x 軸及 y 軸上的半徑，是必要的。後兩個是中心點的 (x,y) 座標，當如同此處省略時，會預設為 (0,0)。我使用 rect 方法將矩形加入，它也有四個參數。前兩個是矩形的寬與高，後兩個是左上角的 (x,y) 座標。這兩個方法都會回傳自己本身，所以你可以連接其他方法給他們。 這是群組呈現時的樣子。橢圓以原點為中心，矩形的左上角稍微向上並且在原點的左邊。 形狀方法 有七種形狀方法，除了 ellipse 和 rect 外，還有 circle、line、path、polygon 和 polyline。你也可以把文字當成形狀。形狀可以加上邊框和填充顏色，也可以透過變形方法和 styles 方法進行修改。 SkewX（X 方向傾斜）每個人都知道翅膀看起來不像矩形！翅膀看起來像傾斜的平行四邊形。（嗯，在這個範例是這樣！）幸運的是，我們可以如同對容器一樣在形狀使用變形。skewX 方法讓我們很容易傾斜矩形。skewX 方法是另一個變形，它需要一個參數，傾斜 x 軸的角度。由於所有的形狀建構式包含 rect，都會回傳自己本身，我可以將 skewX 直接連接到 rect，並限制只有矩形有變形效果。結果如下所示。（我為翅膀座標系畫了座標軸。） 身體就是這樣。在繼續之前讓我們來完成其他瑣事。我之前說過容器建構式（如 g）會轉交給程式區塊如果存在的話。在這個範例，translate 和 rotate 方法介於 g 和程式區塊間。如果有相關聯的程式區塊，所有變形方法都會轉交過去，所以我可以很容易地將他們連接到容器建構式，並仍然使用程式區塊參數來定義群組內的圖形物件。方法連結是 RVG 常見的慣用方法，你會在範例中看到很多。 下一個群組繪製頭部。 第 15 ~ 20 行123456canvas.g.translate(130, 83) do |head| head.styles(:stroke=&gt;'black', :stroke_width=&gt;2) head.circle(30).styles(:fill=&gt;'yellow') head.circle(5, 10, -5).styles(:fill=&gt;'black') head.polygon(30,0, 70,5, 30,10, 62,25, 23,20).styles(:fill=&gt;'orange')end 這個部分與前一部分非常相似。我要定義一個群組來包含繪製鴨子頭部、眼睛和喙的圖形物件。首先，我使用平移方法來將原點移動到 (130,83)： 在第 16 行我在群組定義了 strok 和 stroke_width。在群組上定義的樣式會傳播到群組中的形狀，除非你覆蓋他們。要做到這一點，在形狀調用 styles。在這個群組，每個形狀都有自己的填充顏色。黃色的圓組成了頭部，circle 需要 3 個參數，第一個參數是圓的半徑，另外兩個參數是中心點的 (x,y) 座標。當如同此處省略時，會預設為 (0,0)。我使用一個小黑圓作為眼睛。 最後，我使用 polygon 方法來繪製鳥喙。此方法使用一系列的 (x,y) 座標繪製多邊形。如果最後一個座標不等於第一個，polygon 會暗中的加上它以關閉多邊形。同樣地，我使用 styles 將填充顏色設定為「橘色」。 第 22 ~ 25 行1234foot = RVG::Group.new do |_foot| _foot.path('m0,0 v30 l30,10 l5,-10, l-5,-10 l-30,10z'). styles(:stroke_width=&gt;2, :fill=&gt;'orange', :stroke=&gt;'black')end 這裡我透過直接調用 new 來建立一個群組，而不是在容器上調用 g 方法。這將建立一個不包含在畫布中的群組物件。你可以想像腳沒有附加到任何東西，像這樣： 第 26 ~ 27 行12canvas.use(foot).translate(75, 188).rotate(15)canvas.use(foot).translate(100, 185).rotate(-15) 要將群組加入到畫布，我使用 use 方法。use 方法可以接受任何容器或圖形物件作為參數。你還可以指定一個 (x,y) 座標來放置物件。然而，在這個範例中，我讓那些參數預設為 (0,0)，並使用 translate 來決定腳的位置。以下展示了左腳如何附加到鴨子上： 當然，鴨子在走路，所以我必須用 rotate 讓腳有點傾斜： 附加右腳很簡單，再次調用 use 但使用不同的參數來 translate 和 rotate： 第 29 ~ 34 行123456canvas.text(125, 30) do |title| title.tspan(\"duck|\").styles(:text_anchor=&gt;'end', :font_size=&gt;20, :font_family=&gt;'helvetica', :fill=&gt;'black') title.tspan(\"type\").styles(:font_size=&gt;22, :font_family=&gt;'times', :font_style=&gt;'italic', :fill=&gt;'red')end 我現在需要的是一個圖片標題。文字在 RVG 是 text 方法的工作。和形狀方法相同，text 可以與任何容器物件一起使用。text 本身是一個容器，除了它只能包含文字相關的物件。text 方法接受 2 或 3 個參數，一個 (x,y) 座標對和一個可選的字串。(x,y) 座標對定義目前文字開始呈現的位置，如果有一個字串參數，它將從目前文字位置開始被呈現。呈現文字會改變目前文字位置到文字的結尾。 在這個範例中，文字被作為一個容器，文字物件可以包含 tspan 物件。每個 tspan 可以指定它自己的樣式。預設情況下，每個 tspan 會從目前文字位置開始呈現。 同樣地，我可以使用 styles 改變文字外觀。我在這裡選擇字體、字體樣式（預設是「normal」）、以點計算的大小和顏色。 第 35 行1canvas.rect(249,249).styles(:stroke=&gt;'blue', :fill=&gt;'none') 就快完成了，我現在需要的是加上一個藍色邊框。（我現在要刪除方格紙背景，因為我們不再需要它。） 第 38 行1rvg.draw.write('duck.gif') 調用 draw 方法沒有佔用大量空間，只有 4 個字母，但是做了很多工作。draw 方法會遍歷我加到最外層 RVG 容器的所有圖形物件，並在背景繪製他們。繪製完成後，draw 將以 RMagick Image 物件的形式回傳圖像。你可以在圖像上使用任何 Image 類別方法，這裡我簡單地將圖像輸出為 GIF 檔案。 縮放圖片RVG 圖片真的可以縮放嗎？讓我們試試看。更改 RVG.new 調用讓圖片變成 4 倍大。邊長是 5 英吋： 1rvg = RVG.new(5.in, 5.in).viewbox(0,0,250,250) do |canvas| 不改變其他東西。再次執行程式，看看你得到什麼。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://calvertyang.github.io/tags/Ruby/"},{"name":"Rmagick","slug":"Rmagick","permalink":"https://calvertyang.github.io/tags/Rmagick/"}]},{"title":"如何在 Ubuntu 中為 vsftpd 設置虛擬帳號","slug":"how-to-setup-virtual-users-for-vsftpd-in-ubuntu","date":"2017-02-06T06:35:56.000Z","updated":"2019-11-15T08:50:11.877Z","comments":true,"path":"2017/02/06/how-to-setup-virtual-users-for-vsftpd-in-ubuntu/","link":"","permalink":"https://calvertyang.github.io/2017/02/06/how-to-setup-virtual-users-for-vsftpd-in-ubuntu/","excerpt":"","text":"以下是在 Ubunto 16.04 LTS 安裝 vsftpd 並設定虛擬帳號的步驟 安裝 vsftpd 12$ sudo apt-get update$ sudo apt-get install vsftpd 編輯設定檔 1$ sudo vim /etc/vsftpd.conf 以下設定僅供參考，可依實際使用情形調整（詳細設定及說明可查看 man vsftpd.conf） /etc/vsftpd.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102# 設定為 YES 表示 vsftpd 是以 standalone 的方式來啟動# 註：listen_ipv6 預設接受 IPv6 及 IPv4 連線，因此設定 listen_ipv6 為 YES 即可listen=NOlisten_ipv6=YES# 是否允許匿名者登入anonymous_enable=NO# 是否以實體用戶的方式登入 vsftpd 伺服器# 註：使用虛擬帳號時需要一個實體帳號local_enable=YES# 是否允許使用者上傳資料write_enable=YES# 建立新目錄與檔案的權限預設值local_umask=022# 若目錄下有 .message 檔案時，當使用者進入此目錄是否顯示該檔案的內容dirmessage_enable=YES# 是否使用本地時間use_localtime=YES# 是否將使用者上傳與下載檔案記錄起來xferlog_enable=YES# 是否支援主動式連線功能connect_from_port_20=YES# 使用者在指定秒數內都沒有命令動作時，是否強制離線idle_session_timeout=600# 是否將使用者限制在自己的家目錄之內chroot_local_user=YES# 用於 chroot 的空目錄路徑，此目錄不應被 ftp 使用者寫入secure_chroot_dir=/var/run/vsftpd/empty# pam 模組的名稱pam_service_name=vsftpd# RSA 加密的憑證檔案所在位置rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem# RSA 加密的私鑰檔案所在位置rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key# 是否啟動 SSL 支援ssl_enable=NO# 是否標示 vsftpd 使用 UTF-8 檔案系統utf8_filesystem=YES# 是否將目錄中的所有使用者和群組資訊顯示為 &quot;ftp&quot;hide_ids=YES# 限制同一時間可以同時連上 vsftpd 的用戶端數量max_clients=50# 限制同一時間同一個 IP 的最大連線數量max_per_ip=5# 是否支援被動式連線模式pasv_enable=YES# 設定被動式連線模式可用的連接埠範圍pasv_min_port=65400pasv_max_port=65410# 指定某個純文字檔作為使用者登入 vsftpd 伺服器時所顯示的歡迎訊息banner_file=/etc/vsftpd/banner_file# 是否同時產生 wu-ftpd 格式及 vsftpd 自有格式的記錄檔dual_log_enable=YES# vsftpd 格式記錄檔的所在位置vsftpd_log_file=/var/log/vsftpd.log# 是否支援 TCP Wrappers 的防火牆機制tcp_wrappers=YES# 這個選項允許根據各別用戶來覆蓋本設定檔中指定的任何設定user_config_dir=/etc/vsftpd/user_conf# 虛擬帳號是否將使用與本地用戶相同的權限virtual_use_local_privs=YES# 基於模板為每個虛擬帳號自動產生主目錄user_sub_token=$USER# 設定用戶家目錄local_root=/var/ftp/$USER# 是否允許用戶根目錄有寫入權限allow_writeable_chroot=YES# 若這個值設定為 YES 時，那麼任何實體帳號，均會被視為 guestguest_enable=YES# 指定訪客身份guest_username=vsftpd 設定虛擬帳號前仍須先建立一個實體帳號，虛擬帳號皆會使用此帳號登入 1$ sudo useradd --home /home/vsftpd --gid nogroup -m --shell /bin/false vsftpd 設定虛擬帳號由於要使用非實體帳號來登入，需另外建立帳號及密碼資料提供 vsftpd 作認證 1$ sudo vim /etc/vsftpd/virtual-user 建立帳密文件，格式為一行帳號、一行密碼 /etc/vsftpd/virtual-user1234user1user1_passworduser2user2_password 接著將帳密文件轉換成資料庫檔案（Berkeley DB 格式） 1$ sudo db_load -T -t hash -f /etc/vsftpd/virtual-user /etc/vsftpd/virtual-user.db 註：若出現 The program &#39;db_load&#39; is currently not installed. 訊息，則用以下指令安裝必要套件 1$ sudo apt-get install db-util 因設定檔內有使用了 user_config_dir 設定，可在此目錄內針對各使用者套用額外設定 1$ sudo mkdir /etc/vsftpd/user_conf 以下範例為限制 user2 僅擁有上傳權限 1$ sudo vim /etc/vsftpd/user_conf/user2 設定內容如下 /etc/vsftpd/user_conf/user21download_enable=NO 修改 vsftpd 認證設定 12$ sudo mv /etc/pam.d/vsftpd /etc/pam.d/vsftpd.old$ sudo vim /etc/pam.d/vsftpd 設定內容如下 /etc/pam.d/vsftpd12auth required pam_userdb.so db=/etc/vsftpd/virtual-useraccount required pam_userdb.so db=/etc/vsftpd/virtual-user 重啟服務 1$ sudo systemctl restart vsftpd 現在已可透過虛擬帳號登入囉！","categories":[{"name":"Server","slug":"Server","permalink":"https://calvertyang.github.io/categories/Server/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://calvertyang.github.io/tags/Linux/"}]},{"title":"在 Capistrano 自動化部署時使用 Ed25519 金鑰","slug":"capistrano-with-ed25519-keys","date":"2016-10-16T06:43:27.000Z","updated":"2019-11-15T08:50:11.881Z","comments":true,"path":"2016/10/16/capistrano-with-ed25519-keys/","link":"","permalink":"https://calvertyang.github.io/2016/10/16/capistrano-with-ed25519-keys/","excerpt":"","text":"原文：steigr — Capistrano with ED25519 keys 我最近將我的 Capistrano 自動化部署切換到了 Ed25519 金鑰。在正常運作之前我發現到一些奇怪的錯誤，部署使用者/代理程式無法登入到主機。在檢查 authorized_keys 檔案權限、本地 SSH 代理程式後，我開始用 Google 搜尋這個問題。結果是，net-ssh 版本小於 4 不支援 Ed25519 金鑰。 在 Gemfile 加入以下幾行，安裝所需的版本和 ruby gems 以啟用 Ed25519 金鑰支援： 1234gem 'bcrypt_pbkdf', group: :developmentgem 'rbnacl-libsodium', group: :developmentgem 'rbnacl', group: :developmentgem 'net-ssh', '~&gt; 4.0.0.beta', group: :development 確認 ruby 開發標頭檔，安裝到 rbnacl 及 rbnacl-libsodium 的 C 編譯器和相依開發標頭檔皆有原生擴充功能。 現在，deploy-agent@server&#39;s password: 訊息應該消失了。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://calvertyang.github.io/tags/Ruby-on-Rails/"},{"name":"Ed25519","slug":"Ed25519","permalink":"https://calvertyang.github.io/tags/Ed25519/"}]},{"title":"升級你的 SSH 金鑰！","slug":"upgrade_your_ssh_keys","date":"2016-10-05T05:53:00.000Z","updated":"2019-11-15T08:50:11.885Z","comments":true,"path":"2016/10/05/upgrade_your_ssh_keys/","link":"","permalink":"https://calvertyang.github.io/2016/10/05/upgrade_your_ssh_keys/","excerpt":"原文：Gert van Dijk — Upgrade your SSH keys! 無論你是軟體開發人員或系統管理員，我敢打賭你正在使用 SSH 金鑰。比起使用密碼來推送提交到 Github 或是管理 Unix 系統，透過 SSH 公開金鑰驗證是最佳的方法。然而，隨著時光飛逝，很多人都使用舊金鑰而沒有意識到需要產生一個新的來提供私密資料更好的保護。在這篇文章，我將示範如何平穩的轉換到 Ed25519 金鑰、你為什麼會想要它以及展示一些技巧和訣竅。 長話短說，使用 ssh-keygen -o -a 100 -t ed25519 來產生新的金鑰並指定一個高強度的通關密語，如果你需要平穩的轉換，請繼續往下閱讀。 我計劃發佈更多 SSH 技巧和訣竅，所以請關注我的部落格。這篇文章的重點是關於作為使用者公開金鑰驗證的 SSH 金鑰。 DSA 和 RSA 1024 位元已經廢止如果你已經使用預設選項建立金鑰超過四年，它可能不安全（RSA &lt; 2048 位元）。更糟的是，我最近看到了推特迷、同事和朋友還在使用 DSA 金鑰（OpenSSH 格式裡的 ssh-dss 類型）。那是一種類似於 RSA 的金鑰類型，但長度受限於 1024 位元且被推薦了很長一段時間。它顯然不安全，且被最近的 OpenSSH 版本以正當理由拒絕（請參見 7.0 更新日誌）。 難過的是，我看到關於如何重新啟用支援 DSA 金鑰的文章，而不是轉移到一種更安全的金鑰類型。真的，依照指示更改 PubkeyAcceptedKeyTypes 或 HostKeyAlgorithms 的設定是不明智的(host keys are for a later post)。取而代之，升級你的金鑰！","text":"原文：Gert van Dijk — Upgrade your SSH keys! 無論你是軟體開發人員或系統管理員，我敢打賭你正在使用 SSH 金鑰。比起使用密碼來推送提交到 Github 或是管理 Unix 系統，透過 SSH 公開金鑰驗證是最佳的方法。然而，隨著時光飛逝，很多人都使用舊金鑰而沒有意識到需要產生一個新的來提供私密資料更好的保護。在這篇文章，我將示範如何平穩的轉換到 Ed25519 金鑰、你為什麼會想要它以及展示一些技巧和訣竅。 長話短說，使用 ssh-keygen -o -a 100 -t ed25519 來產生新的金鑰並指定一個高強度的通關密語，如果你需要平穩的轉換，請繼續往下閱讀。 我計劃發佈更多 SSH 技巧和訣竅，所以請關注我的部落格。這篇文章的重點是關於作為使用者公開金鑰驗證的 SSH 金鑰。 DSA 和 RSA 1024 位元已經廢止如果你已經使用預設選項建立金鑰超過四年，它可能不安全（RSA &lt; 2048 位元）。更糟的是，我最近看到了推特迷、同事和朋友還在使用 DSA 金鑰（OpenSSH 格式裡的 ssh-dss 類型）。那是一種類似於 RSA 的金鑰類型，但長度受限於 1024 位元且被推薦了很長一段時間。它顯然不安全，且被最近的 OpenSSH 版本以正當理由拒絕（請參見 7.0 更新日誌）。 難過的是，我看到關於如何重新啟用支援 DSA 金鑰的文章，而不是轉移到一種更安全的金鑰類型。真的，依照指示更改 PubkeyAcceptedKeyTypes 或 HostKeyAlgorithms 的設定是不明智的(host keys are for a later post)。取而代之，升級你的金鑰！ 確定你目前的狀況列出你的所有金鑰： 1$ for keyfile in ~/.ssh/id_*; do ssh-keygen -l -f \"$&#123;keyfile&#125;\"; done | uniq DSA 或 RSA 1024 位元：不安全的 RSA 2048：建議更改 RSA 3072/4096：好極了，但是 Ed25519 有一些好處！ ECDSA：要看情況，建議更改 Ed25519：哇！太酷了！但是可以抵抗暴力破解嗎？ 平穩的轉換，我保證。你可能在想⋯「我用金鑰很久了，我不想現在到處更改。」很有道理，但你不需要到處更改！好消息是，你可以有多個金鑰在系統上，而且你的 SSH 客戶端會自動選擇正確的金鑰給正確的系統。 這是 SSH 協定的一部分，它可以提供多個金鑰，而伺服器會挑選一個，你的客戶端必須透過質詢證明來擁有私鑰。加入一些參數（-vvv）在 SSH 連線指令來觀看運作情形。此外，若有使用 SSH 金鑰管理器，你可以載入多個金鑰，它會識別所有金鑰。很簡單吧。 你會喜歡 Twisted Edwards curve最常見的金鑰類型是 RSA，也被稱為 ssh-rsa。它的相容性很好但也緩慢，若使用位元長度小於 2048 位元建立，具有潛在危險性。我們剛剛得知你的 SSH 客戶端可以處理多個金鑰，所以趕緊使用最新快速的橢圓曲線加密法，並享受它所提供非常緊湊的金鑰格式！ Ed25519 金鑰很短。非常短。如果你已經習慣了從系統複製多行字元到其它系統，你會對於它的大小感到驚喜。公鑰的長度僅有 68 個字元。驗證速度也比高強度的 RSA（3072+ 位元）更快。 Ed25519 金鑰可透過在 ssh-keygen 指令加上 -t ed25519 選項來產生。 Ed25519 是使用 Twisted Edwards curve 實作的 EdDSA。 增加對暴力破解密碼的抵抗當產生金鑰對時，會詢問你一個密碼短語來加密私鑰。若你將永遠失去私鑰，它應該保護他人冒充你，因為它會被密碼短語加密。要真正防止這種情況，應該確保防止密碼短語容易暴力破解。 OpenSSH 金鑰產生器提供了兩種選項，以抵抗暴力破解密碼：使用新的 OpenSSH 金鑰格式並增加金鑰推導函數的使用次數。它會降低解鎖金鑰的速度，但也防止了惡意使用者高效的暴力破解。在你的系統實驗推倒函數的使用次數，約從 100 次開始。在我的系統大約需要 1 秒來解密，且每天用金鑰管理器載入一次。在我看來，是可以接受的。 透過 ssh-keygen 使用 -o 選項並利用 bcrypt 所搭載的嶄新金鑰推導函數建立新的 RFC4716 金鑰格式。使用 -a &lt;num&gt; 選項指定推導函數的使用次數。 事實上，當建立一個 Ed25519 金鑰時，-o 選項看來是預設值。 OpenSSH 的手冊並沒有真正關於「新」格式的解釋。我發現 www.tedunangst.com 內的這篇文章非常有用：「新的 OpenSSH 金鑰格式及 bcrypt pbkdf」。 產生新的吸引人的 Ed25519 金鑰 提示：使用相同的密碼短語在你所有的金鑰類型來獲得更多便利性。（參見：知道多個金鑰的 SSH 客戶端。） 123456789$ ssh-keygen -o -a 100 -t ed25519Generating public/private ed25519 key pair.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/gert/.ssh/id_ed25519.Your public key has been saved in /home/gert/.ssh/id_ed25519.pub.The key fingerprint is:SHA256: [...] gert@hostnameThe key&apos;s randomart image is: [...] 注意那行「Your identification has been saved in /home/gert/.ssh/id_ed25519」。你現在的 RSA/DSA 金鑰都在相同的 ~/.ssh 資料夾內。如同其它金鑰，你可以複製在 ~/.ssh/id_ed25519.pub 的公鑰到目的主機以便驗證。 知道多個金鑰的 SSH 客戶端所有在預設路徑內的金鑰會被 SSH 客戶端應用程式自動偵測，包含透過 ssh-add 的 SSH 金鑰管理器。所以，如果你像以前一樣使用 ssh、scp、rsync 等應用程式⋯ 1$ ssh user@host 現在將提供多個公鑰給伺服器，伺服器會對匹配的項目要求證明所有權以便驗證。你日常使用的 ssh-add 指令不會改變，且自動找到 Ed25519 金鑰： 1234$ ssh-addEnter passphrase for /home/gert/.ssh/id_rsa:Identity added: /home/gert/.ssh/id_rsa (gert@hostname)Identity added: /home/gert/.ssh/id_ed25519 (gert@hostname) 它不僅找到這些金鑰，也載入它們僅透過輸入一次密碼短語（因為是相同的）！ 我們現在已經達成重要的目標。在沒有改變你任何的日常工作下，我們可以慢慢的更改原端主機上現有的設定來接受 Ed25519 金鑰。在此期間 RSA 金鑰仍然可運作。很棒對吧！？ 變更或設定密碼短語如果你害怕這會改變你的金鑰，別擔心。使用密碼短語加密的金鑰對私有部分，僅存在於你的本地機器上。只要你喜歡，可以經常改變它。這個建議是防止金鑰落入不法分子手中時遭到濫用。重複所有的金鑰檔案，以確保新的金鑰格式使用 100 次 bcrypt KDF： 1$ ssh-keygen -f ~/.ssh/id_rsa -p -o -a 100 升級你現在的 RSA 金鑰現在使用 Ed25519 在大多數情況下會（也應該）正常運作，但是舊式系統可能不支援。最好的應急辦法是使用高強度 RSA 金鑰對。 雖然 OpenSSH 客戶端支援多個 RSA 金鑰，它需要設定或命令列選項來指定路徑，所以相當容易出錯。取而代之，我建議你升級現有的金鑰，這樣做會讓事情變得簡單。根據你目前的 RSA 金鑰強度，你可以立即或悠閒的更新。 如果你仍然有弱的 RSA 金鑰，將它從標準路徑移出來並產生一個長度 4096 位元的新金鑰： 123$ mv ~/.ssh/id_rsa ~/.ssh/id_rsa_legacy$ mv ~/.ssh/id_rsa.pub ~/.ssh/id_rsa_legacy.pub$ ssh-keygen -t rsa -b 4096 -o -a 100 如果你使用金鑰管理器，手動將其指定到所有的金鑰： 1$ ssh-add ~/.ssh/id_rsa ~/.ssh/id_rsa_legacy ~/.ssh/id_ed25519 一旦你完成了所有遠端目標的更新，你可以回到便利的方式，讓它自動找到新的 RSA 和 Ed25519 金鑰；只要忽略金鑰檔案參數。 支援 Ed25519 的軟體自 OpenSSH 6.5 開始支援，在提供給工作站的 Unix 作業系統也已經採用。Ubuntu 14.04+、Debian 8+、CentOS/RedHat 7+ 等等都支援它了。（如果你有關於 Mac OS X 的詳細訊息，請留個訊息，無法快速搜尋到它）。某些軟體如自訂的桌面版金鑰管理器也許有幾個不喜歡新的金鑰的原因（見下文「我的 Gnome-keyring 不再運作」）。 順帶一提，Github 上也運作的很好。不幸的是，Launchpad 和 Gerrit 程式碼審查看來需要 RSA 金鑰。在 Windows 使用 PuTTY 嗎？見下文。 我的 Gnome-keyring 不再運作Gnome-keyring 被用在 Ubuntu Unity，無法讀取新的 RFC4716 格式金鑰，但回報成功。這是臭蟲。更多細節在我的 AskUbuntu Q&amp;A 文章。我建議停用 Gnome keyring 作為 SSH 金鑰管理器，改用普通的 OpenSSH 金鑰管理器來代替。 我在 Windows 使用 PuTTY抱歉，我沒有使用 PuTTY，但是首先要確定已經升級。根據願望清單項目建議，從 2015 年末版本開始支援 Ed25519。一般來說，我對於它實作的安全功能的速度不是太興奮。 這是最安全的 SSH 金鑰對？我們已經採取了一些重要措施，但是離最安全還很遠。在處理高保證環境時，如本文所述，因為在記憶體中保存著未加密的私鑰，我強烈反對使用金鑰。取而代之，使用安全硬體（智慧卡）來避免洩露金鑰甚至從記憶體轉存。它未涵蓋在此文章，主要是因為它需要你購買硬體，其次是因為依賴於設備的限制。一個很好的解決方案是利用可能已經內建在你電腦的可信賴平台模組，不過那肯定值得用其它文章來解說。","categories":[{"name":"Security","slug":"Security","permalink":"https://calvertyang.github.io/categories/Security/"}],"tags":[{"name":"Ed25519","slug":"Ed25519","permalink":"https://calvertyang.github.io/tags/Ed25519/"},{"name":"SSH","slug":"SSH","permalink":"https://calvertyang.github.io/tags/SSH/"}]},{"title":"使用 Mailboxer 實作站內信系統","slug":"use-the-mailboxer-to-implement-messaging-systems","date":"2015-05-19T17:34:00.000Z","updated":"2019-11-15T08:50:11.886Z","comments":true,"path":"2015/05/20/use-the-mailboxer-to-implement-messaging-systems/","link":"","permalink":"https://calvertyang.github.io/2015/05/20/use-the-mailboxer-to-implement-messaging-systems/","excerpt":"Mailboxer 是一個 Rails gem，為 social_stream 框架用來建立社群網路的一部分。它是具備一些通用方法的訊息系統，允許任何 model 擔任傳遞訊息的角色。 使用 Mailboxer，你可以與一或多個收件人建立對話（訊息會被歸納到寄件匣、收件匣及垃圾桶）並透過電子郵件發送通知。它甚至可以在不同 model 間發送訊息和附件！唯一的缺點是缺乏文件，所以我希望這邊文章是有幫助的。 我們要討論的範例程式為： 使用 Devise 做基本身份驗證 使用 Gravatar 讓使用者管理頭像 整合 Mailboxer 使用圖形介面來建立／回覆對話（使用 Bootstrap 樣式及 Chosen jQuery 插件） 顯示資料夾，並允許在它們之間輕鬆切換 允許將對話標示為已讀、放到垃圾桶或還原，也可以清理垃圾桶。 設定電子郵件通知 此範例將使用 Rails 4，但幾乎相同的解決方案也可以實作於 Rails 3.2（Mailboxer 不再支援 3.1 版）。 原始碼可以在 Github 找到。","text":"Mailboxer 是一個 Rails gem，為 social_stream 框架用來建立社群網路的一部分。它是具備一些通用方法的訊息系統，允許任何 model 擔任傳遞訊息的角色。 使用 Mailboxer，你可以與一或多個收件人建立對話（訊息會被歸納到寄件匣、收件匣及垃圾桶）並透過電子郵件發送通知。它甚至可以在不同 model 間發送訊息和附件！唯一的缺點是缺乏文件，所以我希望這邊文章是有幫助的。 我們要討論的範例程式為： 使用 Devise 做基本身份驗證 使用 Gravatar 讓使用者管理頭像 整合 Mailboxer 使用圖形介面來建立／回覆對話（使用 Bootstrap 樣式及 Chosen jQuery 插件） 顯示資料夾，並允許在它們之間輕鬆切換 允許將對話標示為已讀、放到垃圾桶或還原，也可以清理垃圾桶。 設定電子郵件通知 此範例將使用 Rails 4，但幾乎相同的解決方案也可以實作於 Rails 3.2（Mailboxer 不再支援 3.1 版）。 原始碼可以在 Github 找到。 前置準備假設我們要建立內部的私人訊息系統提供同事討論不同主旨。這個系統應該允許使用者與無數個收件人建立對話、提供通知系統並允許刪除舊的對話。 建立名為 Synergy 不含預設測試套件的 Rails 應用程式： 1$ rails new Synergy -T 在你的 Gemfile 加入以下的 Gem（我會使用 Bootstrap，但你可以使用任何其它的 CSS 框架、自行設計或者跳過美化網站的步驟）： Gemfile1234[...]gem 'bootstrap-sass'gem 'kaminari'[...] 執行 12$ bundle install$ rails generate kaminari:views bootstrap3 然後加入 Bootstrap 檔案： app/assets/stylesheets/application.scss12@import \"bootstrap-sprockets\";@import \"bootstrap\"; app/assets/javascripts/application.js1//= require bootstrap-sprockets 接著調整 layout： app/views/layouts/application.html.erb123456789101112131415[...]&lt;div class=\"container\"&gt; &lt;% flash.each do |key, value| %&gt; &lt;div class=\"alert alert-&lt;%= key %&gt;\"&gt; &lt;%= value %&gt; &lt;/div&gt; &lt;% end %&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt;&lt;%= yield :page_header %&gt;&lt;/h1&gt; &lt;/div&gt; &lt;%= yield %&gt;&lt;/div&gt;[...] 讓我們新增 helper 來方便呈現頁面標題： app/helpers/application_helper.rb12345[...]def page_header(text) content_for(:page_header) &#123; text.to_s &#125;end[...] 身份驗證實作訊息功能之前，我們需要一個 model 來傳遞訊息。建立 User model： 12$ rails g model User name:string$ rake db:migrate 你可以使用任何類型的身份驗證，但我喜歡 Devise。Devise 的基本設定非常簡單，並有大量文件協助您進一步自訂設定。 加入新的 gem： Gemfile123[...]gem 'devise'[...] 並安裝它： 1$ bundle install 現在，我們可以利用 Devise 的產生器來幫我們做一些工作： 1$ rails generate devise:install 請務必閱讀安裝後的訊息來完成一些額外的步驟。具體來說，你需要為 development 和 production 調整 config.action_mailer.default_url_options 設定，因為它會被用來發送郵件給使用者（例如，幫助他們恢復遺忘的密碼）。請注意，電子郵件在 development 時不會發送，除非你在 config/environments/development.rb 設定 config.action_mailer.perform_deliveries = true。 這裡有關於如何設定 ActionMailer 的一些範例。 當你準備好後，執行以下指令使用 Devise 建立 User model： 12$ rails generate devise User$ rake db:migrate 你可能想要在套用變更前檢查指令產生的遷移檔，並加入更多欄位到資料表（啟用 Confirmable 或 Lockable 模組）。你還需要調整 model 內相應的設定。 最後，執行以下指令來複製 Devise 的 views 到你的專案，以便稍作修改： 1$ rails generate devise:views 要能夠讓使用者變更他們的名字，所以新增一個欄位到註冊表單： app/views/devise/registrations/new.html.erb123456[...]&lt;div class=\"field\"&gt; &lt;%= f.label :name %&gt;&lt;br /&gt; &lt;%= f.text_field :name %&gt;&lt;/div&gt;[...] 同樣的將此欄位加入 app/views/devise/registrations/edit.html.erb（或者將它重構為 partial），讓使用者可以在註冊時提供名字，並在稍後編輯它。 由於 Rails 4 引進了新的保護機制 Strong Parameters，需要設定允許 :name 參數可以傳遞： app/controllers/application_controller.rb12345678910[...]before_action :configure_permitted_parameters, if: :devise_controller?protected def configure_permitted_parameters devise_parameter_sanitizer.for(:sign_up) &lt;&lt; :name devise_parameter_sanitizer.for(:account_update) &lt;&lt; :name end[...] devise_controller?方法是由 Devise 提供。在這裡，我們允許建立及編輯帳號時傳遞 :name 屬性。如果你忘了這樣做，使用者將無法設定自己的名字。 此時，你也可以修改 view 的樣式。我不會涵蓋這一步驟，因為它不是太難且高度依賴於你的設定（無論你是不是使用 Bootstrap）。如果你決定使用 Bootstrap，Devise 所產生的訊息將不會有樣式。為了解決這個問題，使用 SASS @extend 方法，如下： app/assets/stylesheets/application.scss12345678[...].alert-notice &#123; @extend .alert-success;&#125;.alert-alert &#123; @extend .alert-warning;&#125; 整合 Mailboxer太好了，我們準備進行主要的任務－整合及設定 Mailboxer。 首先，加入新的 gem： Gemfile123[...]gem 'mailboxer'[...] 並安裝它： 1$ bundle install 產生和套用所有必要的遷移並建立初始化檔案： 12$ rails generate mailboxer:install$ rake db:migrate 查看 config/initializers/mailboxer.rb 檔案看你能修改哪些選項。現在，先維持檔案內的設定，稍後我們會設定寄送電子郵件通知。 需要稍作調整 model 來配置 Mailboxer 的功能： app/models/user.rb123[...]acts_as_messageable[...] 顯示對話如指南所建議，為 Mailboxer 建立圖形介面的最佳方法是建立兩個 controller：一個用於訊息，一個用於對話。獨立的訊息會被歸類為對話。稍後，你會看到對話可以是不同類型。 首先建立對話 controller： 1$ rails generate controller conversations app/controllers/conversations_controller.rb1234567891011121314class ConversationsController &lt; ApplicationController before_action :authenticate_user! before_action :get_mailbox def index @conversations = @mailbox.inbox.page(params[:page]) end private def get_mailbox @mailbox ||= current_user.mailbox endend 每個使用者都有自己的信箱，反過來說，又分為收件匣、寄件匣及垃圾桶。目前，我們先關注在收件匣就好。 authenticate_user!是 Devise 的一部分。我們只希望通過驗證的使用者存取應用程式，因此它設定為 before_action。如果使用者沒有通過驗證，他將被導向到登入頁面。 如你所見，我也使用了 kaminari 所提供的 page 方法。 新增路由（其它 controller 方法很快就會加入）： config/routes.rb123[...]resources :conversations, only: [:index, :show, :destroy][...] 並修改 view： app/views/conversations/index.html.erb1234567&lt;% page_header \"Your Conversations\" %&gt;&lt;ul class=\"list-group\"&gt; &lt;%= render partial: 'conversations/conversation', collection: @conversations %&gt;&lt;/ul&gt;&lt;%= paginate @conversations %&gt; page_header 是我們先前建立的 helper 方法。paginate 會顯示分頁控制項（只有超過一頁時會顯示）。 我們必須指定 partial 參數，因為 @conversations 是 Mailboxer::Conversation::ActiveRecord_Relation 的一個實例，因此 Rails 預設會在 mailboxer/conversations 目錄尋找 _conversation。 新增 partial： app/views/conversations/_conversation.html.erb123&lt;li class=\"list-group-item clearfix\"&gt; &lt;%= link_to conversation.subject, conversation_path(conversation) %&gt;&lt;/li&gt; 每個對話都有一個主旨和一些將被顯示於頁面上的訊息。 新增選單到 layout： app/views/layouts/application.html.erb123456789101112131415161718[...]&lt;nav class=\"navbar navbar-inverse\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;%= link_to 'Synergy', root_path, class: 'navbar-brand' %&gt; &lt;/div&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;% if user_signed_in? %&gt; &lt;li&gt;&lt;%= link_to 'Edit Profile', edit_user_registration_path %&gt;&lt;/li&gt; &lt;li&gt;&lt;%= link_to 'Your Conversations', conversations_path %&gt;&lt;/li&gt; &lt;li&gt;&lt;%= link_to 'Log Out', destroy_user_session_path, method: :delete %&gt;&lt;/li&gt; &lt;% else %&gt; &lt;li&gt;&lt;%= link_to 'Log In', new_user_session_path %&gt;&lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt;[...] user_signed_in? 方法以及大部分的路由都是由 Devise 提供。 接下來是 show 動作： app/controllers/conversations_controller.rb12345678910111213141516171819202122class ConversationsController &lt; ApplicationController before_action :authenticate_user! before_action :get_mailbox before_action :get_conversation, except: [:index] def index @conversations = @mailbox.inbox.page(params[:page]) end def show end private def get_mailbox @mailbox ||= current_user.mailbox end def get_conversation @conversation ||= @mailbox.conversations.find(params[:id]) endend 你可能知道，當查詢不到資料時會拋出例外錯誤。這就是我們想要的，但是應該要處理例外錯誤。為了簡單起見，我們使用 rescue_from 方法： app/controllers/application_controller.rb12345678910[...]rescue_from ActiveRecord::RecordNotFound do flash[:warning] = 'Resource not found.' redirect_back_or root_pathenddef redirect_back_or(path) redirect_to request.referer || pathend[...] 我們只是將使用者導向並顯示警告訊息。如果 referer 欄位沒有設定（例如，使用者安裝了插件清除此欄位），他們會被導向到 root_path。 接著，編輯 view： app/views/conversations/show.html.erb1234567891011121314151617&lt;% page_header \"Conversation\" %&gt;&lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt;&lt;%= @conversation.subject %&gt;&lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;div class=\"messages\"&gt; &lt;% @conversation.receipts_for(current_user).each do |receipt| %&gt; &lt;% message = receipt.message %&gt; &lt;%= message.sender.name %&gt; says at &lt;%= message.created_at.strftime(\"%F %T\") %&gt; &lt;%= message.body %&gt; &lt;% end %&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 我們呈現了每個訊息的寄件者的名字、建立時間及訊息內容。讓我們來修改一下 .messages 容器的樣式，讓它不要變得太高： app/assets/stylesheets/application.scss1234567[...].messages &#123; max-height: 400px; overflow-y: auto; margin-bottom: 1em; margin-top: 1em;&#125; 不錯，一些基本的 view 都已經存在了。然而，我們還缺乏了一些重要的東西： 使用者應該知道在和誰對話 使用者需要可以建立新的對話 使用者需要可以回覆對話 寄件匣和垃圾桶應該顯示在對話頁面 使用者應該能將對話標示為已讀 顯示使用者頭像雖然這和 Mailboxer 無關，我認為顯示頭像會讓我們的應用程式看起來更漂亮。然而，允許使用者直接上傳頭像到應用程式有點小題大作，讓我們使用 Gravatar 並透過 gravatar_image_tag 整合到 Rails。 加入新的 gem： Gemfile123[...]gem 'gravatar_image_tag'[...] 並執行 1$ bundle install 同樣的，新增 helper 來方便呈現頭像： app/helpers/application_helper.rb12345[...]def gravatar_for(user, size = 30, title = user.name) image_tag gravatar_image_url(user.email, size: size), title: title, class: 'img-rounded'end[...] 建立單獨的 partial 來呈現對話內收件人的頭像（除了目前的使用者）： app/views/conversations/_participants.html.erb12345&lt;% conversation.participants.each do |participant| %&gt; &lt;% unless participant == current_user %&gt; &lt;%= gravatar_for participant %&gt; &lt;% end %&gt;&lt;% end %&gt; 編輯以下的 view： app/views/conversations/show.html.erb1234567891011121314151617181920212223242526272829&lt;% page_header \"Conversation\" %&gt;&lt;p&gt;Chatting with &lt;%= render 'conversations/participants', conversation: @conversation %&gt;&lt;/p&gt;&lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt;&lt;%= @conversation.subject %&gt;&lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;div class=\"messages\"&gt; &lt;% @conversation.receipts_for(current_user).each do |receipt| %&gt; &lt;div class=\"media\"&gt; &lt;% message = receipt.message %&gt; &lt;div class=\"media-left\"&gt; &lt;%= gravatar_for message.sender, 45, message.sender.name %&gt; &lt;/div&gt; &lt;div class=\"media-body\"&gt; &lt;h6 class=\"media-heading\"&gt;&lt;%= message.sender.name %&gt; says at &lt;%= message.created_at.strftime(\"%F %T\") %&gt; &lt;/h6&gt; &lt;%= message.body %&gt; &lt;/div&gt; &lt;/div&gt; &lt;% end %&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; app/views/conversations/_conversation.html.erb12345&lt;li class=\"list-group-item clearfix\"&gt; &lt;%= link_to conversation.subject, conversation_path(conversation) %&gt; &lt;p&gt;&lt;%= render 'conversations/participants', conversation: conversation %&gt;&lt;/p&gt;&lt;/li&gt; 顯示對話內最後一則訊息及它的建立時間： app/views/conversations/_conversation.html.erb12345678910&lt;li class=\"list-group-item clearfix\"&gt; &lt;%= link_to conversation.subject, conversation_path(conversation) %&gt; &lt;p&gt;&lt;%= render 'conversations/participants', conversation: conversation %&gt;&lt;/p&gt; &lt;p&gt; &lt;%= conversation.last_message.body %&gt; &lt;small&gt;(&lt;span class=\"text-muted\"&gt;&lt;%= conversation.last_message.created_at.strftime(\"%F %T\") %&gt;&lt;/span&gt;)&lt;/small&gt; &lt;/p&gt;&lt;/li&gt; 我們已經完成頭像了。是時候讓使用者建立新的對話。 建立對話建立對話實際上意味著建立帶有主旨的新訊息（雖然這是可選的）。這表示需要新的 controller： 1$ rails generate controller messages app/controllers/messages_controller.rb12345678910111213class MessagesController &lt; ApplicationController before_action :authenticate_user! def new end def create recipients = User.where(id: params['recipients']) conversation = current_user.send_message(recipients, params[:message][:body], params[:message][:subject]).conversation flash[:success] = \"Message has been sent!\" redirect_to conversation_path(conversation) endend 在 create 動作內，尋找收件人（存放在 params[‘recipients’] 中）並利用 Mailboxer 的 send_message 方法，傳入收件人、訊息和主旨。稍後，我們將啟用電子郵件通知，以便讓使用者知道收到新訊息了。 現在來編輯 view： app/views/messages/new.html.erb1234567891011121314151617181920&lt;% page_header \"Start Conversation\" %&gt;&lt;%= form_tag messages_path, method: :post do %&gt; &lt;div class=\"form-group\"&gt; &lt;%= label_tag 'message[subject]', 'Subject' %&gt; &lt;%= text_field_tag 'message[subject]', nil, class: 'form-control', required: true %&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;%= label_tag 'message[body]', 'Message' %&gt; &lt;%= text_area_tag 'message[body]', nil, cols: 3, class: 'form-control', required: true %&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;%= label_tag 'recipients', 'Choose recipients' %&gt; &lt;%= select_tag 'recipients', recipients_options, multiple: true, class: 'form-control' %&gt; &lt;/div&gt; &lt;%= submit_tag 'Send', class: 'btn btn-primary' %&gt;&lt;% end %&gt; recipients_options 是 helper 方法，我們需要建立它： app/helpers/messages_helper.rb12345module MessagesHelper def recipients_options options_for_select(User.all.map &#123; |user| [user.name, user.id] &#125;) endend 別忘了設定路由： config/routes.rb123[...]resources :messages, only: [:new, :create][...] 接著在 conversations#index 頁面顯示「Start conversation」連結： app/views/conversations/index.html.erb1234&lt;% page_header \"Your Conversations\" %&gt;&lt;p&gt;&lt;%= link_to 'Start conversation', new_message_path, class: 'btn btn-lg btn-primary' %&gt;&lt;/p&gt;[...] 技術上來說，一切都已經就緒可以發佈你的第一則訊息。你可以傳遞給自己或是註冊另一個帳號來模擬有兩個使用者的情況。 然而，選擇收件人不是很方便。目前，已經呈現了基本的選擇欄位，但如果有很多使用者時，要在列表中找到某個人是很麻煩的。我們可以使用 Chosen 來強化這個欄位，它是讓下拉選單更加人性化的一個 jQuery 插件。有個 chosen-rails gem 可以輕鬆的將此插件整合到 Rails 應用程式。 將這個 gem 加到 Gemfile： Gemfile123[...]gem 'chosen-rails'[...] 我也指定了 sass-rails 與 coffee-rails 的版本，因為有與 application.scss 檔案相關的 bug： Gemfile12345[...]gem 'sass-rails', '~&gt; 4.0.5'gem 'coffee-rails', '~&gt; 4.1.0'gem 'jquery-turbolinks'[...] 同時也使用了 jquery-turbolinks gem，當使用 Turbolinks 時可恢復預設的 jQuery page load 事件。 別忘了執行 1$ bundle install 然後將 Chosen 加到 application.js 和 application.scss： app/assets/javascripts/application.js1234[...]//= require jquery.turbolinks//= require chosen-jquery[...] app/assets/stylesheets/application.scss123[...]@import \"chosen\";[...] 接著將 .chosen-it 類別加到我們的 select 標籤： app/views/messages/new.html.erb123456[...]&lt;div class=\"form-group\"&gt; &lt;%= label_tag 'recipients', 'Choose recipients' %&gt; &lt;%= select_tag 'recipients', recipients_options, multiple: true, class: 'form-control chosen-it' %&gt;&lt;/div&gt;[...] 並將所有此類別的元素都裝上 Chosen 的功能： app/assets/javascripts/messages.coffee12$ -&gt; $('.chosen-it').chosen() 現在重載伺服器，到 conversations/new 頁面，會發現嶄新的 select 標籤。這用起來更加方便，不是嗎？ 我們可以更進一步的在 select 標籤內使用者名字前顯示頭像。有個 Chosen 的擴充插件 Image-Select。只要將 ImageSelect.jquery.js 和 ImageSelect.css 放到你的專案並分別在 application.js 和 application.scss 引入。然後，稍微修改 helper 方法： app/helpers/messages_helper.rb12345module MessagesHelper def recipients_options options_for_select(User.all.map &#123; |user| [user.name, user.id, &#123; 'data-img-src' =&gt; gravatar_image_url(user.email, size: 50) &#125;] &#125;) endend 接著再重載伺服器並確認成果。非常棒！ 回覆對話現在，使用者可以建立對話，但是沒有辦法回覆！為了解決這個問題，我們需要另一個表單及 controller 方法，以及新的路由： app/views/conversations/show.html.erb1234567[...]&lt;%= form_tag reply_conversation_path(@conversation), method: :post do %&gt; &lt;div class=\"form-group\"&gt; &lt;%= text_area_tag 'body', nil, cols: 3, class: 'form-control', placeholder: 'Type something...', required: true %&gt; &lt;/div&gt; &lt;%= submit_tag \"Send Message\", class: 'btn btn-primary' %&gt;&lt;% end %&gt; 註：你也可以加入另一個文字欄位讓使用者新增主旨。 app/controllers/conversations_controller.rb1234567[...]def reply current_user.reply_to_conversation(@conversation, params[:body]) flash[:success] = 'Reply sent' redirect_to conversation_path(@conversation)end[...] Mailboxer 的 reply_to_conversation 方法讓回覆對話變得很輕鬆。它接受對話的回覆訊息、主旨（可選）及些許其他的參數。需要注意的是，如果對話被移動到垃圾桶（我們將在稍後處理），預設會被復原。可以去看看原始碼取得更多資訊。 config/routes.rb1234567[...]resources :conversations, only: [:index, :show, :destroy] do member do post :reply endend[...] 很好，基本的聊天系統已可啟動並執行！ 實作寄件匣及垃圾桶目前，我們只有顯示使用者的收件匣。然而，顯示寄件匣與垃圾桶是個好主意。 也許要決定該顯示哪個資料夾最簡單的方式是使用 GET 參數，所以讓我們來調整 controller： app/controllers/conversations_controller.rb1234567891011121314151617181920212223242526272829[...]before_action :get_box, only: [:inbox]def index if @box.eql? \"inbox\" @conversations = @mailbox.inbox elsif @box.eql? \"sent\" @conversations = @mailbox.sentbox else @conversations = @mailbox.trash end @conversations = @conversations.page(params[:page])end[...]private[...] def get_box if params[:box].blank? or ![\"inbox\", \"sent\", \"trash\"].include?(params[:box]) params[:box] = 'inbox' end @box = params[:box] end[...] 新的私有方法 get_box 用來取得所需的資料夾。 在 view 的地方，如果你使用的是 Bootstrap，我建議使用垂直導覽列來呈現資料夾。此外，目前所在的資料夾應該被高亮。建立 helper 方法來處理這個： app/helpers/conversations_helper.rb1234567module ConversationsHelper def mailbox_section(title, current_box, opts = &#123;&#125;) opts[:class] = opts.fetch(:class, '') opts[:class] += ' active' if title.downcase == current_box content_tag :li, link_to(title.capitalize, conversations_path(box: title.downcase)), opts endend 這個方法需要連結的標題（也會被用於 GET 的參數）、目前開啟的資料夾及要直接傳遞給 content_tag 方法的 hash 格式選項。然後檢查 opts 是否已有類別的屬性。沒有的話就設為空字串，並在目前的資料夾的類別附加 active 類別。 修改 view： app/views/conversations/index.html.erb123456789101112131415161718192021&lt;% page_header \"Your Conversations\" %&gt;&lt;p&gt;&lt;%= link_to 'Start conversation', new_message_path, class: 'btn btn-lg btn-primary' %&gt;&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-sm-3\"&gt; &lt;ul class=\"nav nav-pills nav-stacked\"&gt; &lt;%= mailbox_section 'inbox', @box %&gt; &lt;%= mailbox_section 'sent', @box %&gt; &lt;%= mailbox_section 'trash', @box %&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"col-sm-9\"&gt; &lt;ul class=\"list-group\"&gt; &lt;%= render partial: 'conversations/conversation', collection: @conversations %&gt; &lt;/ul&gt; &lt;%= paginate @conversations %&gt; &lt;/div&gt;&lt;/div&gt; 下一步是在每個尚未丟棄到垃圾桶的對話加入「Move to trash」按鈕。對於丟棄在垃圾桶的對話，應該顯示「Restore」按鈕。 app/views/conversations/_conversation.html.erb123456789101112131415161718&lt;li class=\"list-group-item clearfix\"&gt; &lt;%= link_to conversation.subject, conversation_path(conversation) %&gt; &lt;div class=\"btn-group-vertical pull-right\"&gt; &lt;% if conversation.is_trashed?(current_user) %&gt; &lt;%= link_to 'Restore', restore_conversation_path(conversation), class: 'btn btn-xs btn-info', method: :post %&gt; &lt;% else %&gt; &lt;%= link_to 'Move to trash', conversation_path(conversation), class: 'btn btn-xs btn-danger', method: :delete, data: &#123; confirm: 'Are you sure?' &#125; %&gt; &lt;% end %&gt; &lt;/div&gt; &lt;p&gt;&lt;%= render 'conversations/participants', conversation: conversation %&gt;&lt;/p&gt; &lt;p&gt; &lt;%= conversation.last_message.body %&gt; &lt;small&gt;(&lt;span class=\"text-muted\"&gt;&lt;%= conversation.last_message.created_at.strftime(\"%F %T\") %&gt;&lt;/span&gt;)&lt;/small&gt; &lt;/p&gt;&lt;/li&gt; 增加相應的方法： app/controllers/conversations_controller.rb12345678910111213[...]def destroy @conversation.move_to_trash(current_user) flash[:success] = 'The conversation was moved to trash.' redirect_to conversations_pathenddef restore @conversation.untrash(current_user) flash[:success] = 'The conversation was restored.' redirect_to conversations_pathend[...] move_to_trash 和 untrash 是由 Mailboxer 提供的兩個方法，從命名就能知道用途。 修改路由： config/routes.rb12345678[...]resources :conversations, only: [:index, :show, :destroy] do member do post :reply post :restore endend[...] 那麼「Empty trash」按鈕呢？很簡單： app/views/conversations/index.html.erb12345678910111213[...]&lt;div class=\"col-sm-9\"&gt; &lt;% if @box == 'trash' %&gt; &lt;p&gt;&lt;%= link_to 'Empty trash', empty_trash_conversations_path, class: 'btn btn-danger', method: :delete, data: &#123; confirm: 'Are you sure?' &#125; %&gt;&lt;/p&gt; &lt;% end %&gt; &lt;ul class=\"list-group\"&gt; &lt;%= render partial: 'conversations/conversation', collection: @conversations %&gt; &lt;/ul&gt; &lt;%= paginate @conversations %&gt;&lt;/div&gt;[...] 以及相應的方法： app/controllers/conversations_controller.rb1234567891011[...]before_action :get_conversation, except: [:index, :empty_trash][...]def empty_trash @mailbox.trash.each do |conversation| conversation.receipts_for(current_user).update_all(deleted: true) end flash[:success] = 'Your trash was cleaned!' redirect_to conversations_pathend[...] 並增加路由： config/routes.rb1234567891011[...]resources :conversations, only: [:index, :show, :destroy] do member do post :reply post :restore end collection do delete :empty_trash endend[...] 將對話標示為已讀讓我們允許使用者將對話標示為已讀。為了實作它，我們需要另外的方法、路由及按鈕： app/views/conversations/_conversation.html.erb12345678910111213[...]&lt;div class=\"btn-group-vertical pull-right\"&gt; &lt;% if conversation.is_trashed?(current_user) %&gt; &lt;%= link_to 'Restore', restore_conversation_path(conversation), class: 'btn btn-xs btn-info', method: :post %&gt; &lt;% else %&gt; &lt;%= link_to 'Move to trash', conversation_path(conversation), class: 'btn btn-xs btn-danger', method: :delete, data: &#123; confirm: 'Are you sure?' &#125; %&gt; &lt;% if conversation.is_unread?(current_user) %&gt; &lt;%= link_to 'Mark as read', mark_as_read_conversation_path(conversation), class: 'btn btn-xs btn-info', method: :post %&gt; &lt;% end %&gt; &lt;% end %&gt;&lt;/div&gt;[...] 這邊使用的 is_unread? 方法需要指定使用者。還有另一個相反的方法 is_read?。 app/controllers/conversations_controller.rb1234567[...]def mark_as_read @conversation.mark_as_read(current_user) flash[:success] = 'The conversation was marked as read.' redirect_to conversations_pathend[...] 最後，修改路由： config/routes.rb123456789101112[...]resources :conversations, only: [:index, :show, :destroy] do member do post :reply post :restore post :mark_as_read end collection do delete :empty_trash endend[...] 大功告成！ 註：你還可以優化 show 動作，讓對話被開啟時自動標示為已讀！ 電子郵件通知記住，Mailboxer 可以在使用者收到訊息時寄送電子郵件通知。此功能在 initializer 中啟用： config/initializers/mailboxer.rb12345678910111213Mailboxer.setup do |config| #Configures if you application uses or not email sending for Notifications and Messages config.uses_emails = true #Configures the default from for emails sent for Messages and Notifications config.default_from = \"no-reply@mailboxer.com\" #Configures the methods needed by mailboxer config.email_method = :mailboxer_email config.name_method = :name [...]end config.email_method 和 config.name_method 告訴 Mailboxer 如何分別取得電子郵件和名字。name 已經存在於我們的 User model，但是沒有 mailboxer_email。你可以嘗試改變這個值為 Devise 所提供的 email 方法，但是這會導致一個錯誤，因為 Mailboxer 會傳遞參數給它，包含收到的訊息。所以有兩個選擇，一個是重新定義此方法，或是建立一個新的。我會選擇第二個選項： app/models/user.rb12345[...]def mailboxer_email(object) emailend[...] 電子郵件通知已經啟用了（請確定有依照先前的指示設定 ActionMailer。另外，不要忘記，電子郵件在 development 時預設是不會發送的。） 補充：如何新增按鈕來寄送訊息給指定使用者這個功能可以很容易地完成！指定的使用者應該從「Start conversation」頁面上的下拉選單自動選取。我認為，最好的方式就是使用 GET 參數帶入指定的使用者。修改 MessagesController 如下： app/controllers/messages_controller.rb12345[...]def new @chosen_recipient = User.find_by(id: params[:to].to_i) if params[:to]end[...] 現在，@chosen_recipient 會有使用者的資料或是 nil。 接著修改 view： app/views/messages/new.html.erb123456[...]&lt;div class=\"form-group\"&gt; &lt;%= label_tag 'recipients', 'Choose recipients' %&gt; &lt;%= select_tag 'recipients', recipients_options(@chosen_recipient), multiple: true, class: 'form-control chosen-it' %&gt;&lt;/div&gt;[...] 我們傳遞了 @chosen_recipient 給 helper 方法。 app/helpers/messages_helper.rb12345[...]def recipients_options(chosen_recipient = nil) options_for_select(User.all.map &#123; |user| [user.name, user.id, &#123; 'data-img-src' =&gt; gravatar_image_url(user.email, size: 50) &#125;] &#125;, chosen_recipient.nil? ? nil : chosen_recipient.id)end[...] 這是更新後的 recipients_options helper 方法。將預設選取的選項帶入 options_for_select 的第二個參數即可！ 基本上，這樣就完成了！為了示範如何運作，新增一個使用者清單頁面並於每個使用者後方加上「Send message」按鈕。 config/routes.rb123[...]resources :users, only: [:index][...] 建立使用者 controller： 1$ rails generate controller users app/controllers/users_controller.rb12345class UsersController &lt; ApplicationController def index @users = User.order('created_at DESC').page(params[:page]) endend app/views/users/index.html.erb1234567891011121314&lt;% page_header \"Users\" %&gt;&lt;ul&gt; &lt;% @users.each do |user| %&gt; &lt;li&gt; &lt;strong&gt;&lt;%= user.name %&gt;&lt;/strong&gt; &lt;% unless current_user == user %&gt; &lt;%= link_to 'Send message', new_message_path(to: user.id), class: 'btn btn-default btn-sm' %&gt; &lt;% end %&gt; &lt;/li&gt; &lt;% end %&gt;&lt;/ul&gt;&lt;%= paginate @users %&gt; 調整 layout 加入使用者清單頁面連結： app/views/layouts/application.html.erb123[...]&lt;li&gt;&lt;%= link_to 'Users', users_path %&gt;&lt;/li&gt;[...] 到此，這個功能就完成囉！ 結論呼！討論了相當多，對吧？我們探討了 Mailboxer 的基本功能，包含了訊息、不同類型的對話、管理對話以及設定電子郵件通知。我們也整合了 Devise 到此應用程式並利用 Gravatar 讓頁面看起來更美觀。 希望本文對你有幫助。順帶一提，你可能會對 Mailboxer 維基上的這個頁面以及介紹 Mailboxer 基本功能的應用程式範例有興趣。 資料來源：Messaging with Rails and Mailboxer","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://calvertyang.github.io/tags/Ruby-on-Rails/"}]},{"title":"了解 GitHub Flow","slug":"understanding-the-github-flow","date":"2014-09-21T06:51:00.000Z","updated":"2019-11-15T08:50:11.884Z","comments":true,"path":"2014/09/21/understanding-the-github-flow/","link":"","permalink":"https://calvertyang.github.io/2014/09/21/understanding-the-github-flow/","excerpt":"","text":"原文：GitHub — Understanding the GitHub Flow GitHub Flow 是一個基於分支的輕量化工作流程，幫助團隊及專案定期的進行部署。 在進行一項專案時，任何時候你可能會有一堆不同功能或想法，有些已經準備好了，而另有些則沒有。分支的存在是為了幫助你管理這些工作流程。 當你在專案建立一個分支，代表建立了一個環境來測試你的新想法。在分支所做的修改不會影響 master 分支，所以可以自由的嘗試並提交修改。你可以放心，分支不會被合併，直到準備將它交由某位協同者來檢查。 進階提示整個 GitHub Flow 是基於分支，它是 Git 的一個核心概念。這裡只有一個規則：任何在 master 分支中的都是可部署的。 正因為如此，當在進行一個功能或修復時，分離新分支與 master 是非常重要的。分支名稱應該具有描述性（如 refactor-authentication、user-content-cache-key 或 make-retina-avatars），讓其他人知道哪些正在進行中。 一旦你的分支已經建立，是時候開始進行修改。無論你何時新增、修改或刪除檔案，你會提交更新並將它們加入分支。加入提交的過程讓你可以追蹤分支的工作進度。 提交也產生了一個透明的工作記錄，讓其他人可以了解你做了些什麼，以及原因。每個提交都有相關的提交訊息，用以解釋為什麼做了修改。此外，每個提交被視為一個修改的獨立個體。這使你在找到錯誤或決定朝不同方向時可以復原修改。 進階提示提交訊息是很重要的，尤其當 Git 追蹤你的修改並顯示這些提交於伺服器上。透過撰寫清楚的提交訊息，你可以更容易讓其他人了解並提供回饋。 Pull Requests 發起了關於提交的討論。因為它們緊密的與底層的 Git 儲存庫結合，任何人都可以清楚的看到如果他們接受你的請求，將會合併什麼修改。 在任何的開發過程中，你可以開啟一個 Pull Request：當你有些許或沒有程式碼，但想分享一些截圖或想法，當你卡住了，需要幫助或建議，或者當你準備好讓某人來檢查你的工作。在 Pull Request 訊息內使用 GitHub 的 @ 提及系統，可以要求某個人或團隊的回饋，無論他們身在何處。 進階提示Pull Requests 對於協作開源專案和管理共享儲存庫的修改很有用。如果你使用的是 Fork 及 Pull 模式，Pull Requests 提供了一個方法來通知專案維護者關於你所做的修改。如果你使用的是共享儲存庫模式，Pull Requests 協助在合併到 master 分支前的程式碼檢閱和討論關於修改的建議。 一旦 Pull Request 被開啟，檢閱修改的人或團隊可能會有問題或意見。也許是程式碼風格不符合專案指引、缺少單元測試，或者也許一切看起來都不錯且狀況良好。Pull Requests 旨在鼓勵這種類型的討論。 在討論及回饋關於你的提交時，你還可以繼續推送到你的分支。如果有人反應說你忘了做某件事，或者在程式碼中有錯誤，你可以在分支中修正它並推送修改。GitHub 會顯示你的新提交及任何可能會收到的額外回饋在統一的 Pull Request 頁面。 進階提示Pull Request 的意見都是用 Markdown 撰寫，所以你可以插入圖片和表情符號，使用預先格式化的文字區塊，及其他輕量化的格式。 一旦你的 Pull Request 進行了檢閱且分支通過測試，是時候將程式碼合併到 master 分支進行部署。如果你想在合併到 GitHub 儲存庫前測試東西，你可以先在本地進行合併。若你沒有推送到儲存庫的權限，這就派上用場了。 合併後，Pull Requests 保存了一筆程式碼的修改歷史記錄。因為他們是可搜尋的，可讓任何人回頭來了解為什麼及如何作出決定。 進階提示你可以透過將特定的關鍵字放入 Pull Request 訊息中，將問題與程式碼做關聯。當你的 Pull Request 被合併，相關的問題也將被關閉。舉例來說，輸入 Closes #32 將會關閉儲存庫中編號 32 的問題。欲了解更多資訊，請查看我們的幫助文章。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://calvertyang.github.io/tags/GitHub/"},{"name":"GitHub Flow","slug":"GitHub-Flow","permalink":"https://calvertyang.github.io/tags/GitHub-Flow/"},{"name":"Workflow","slug":"Workflow","permalink":"https://calvertyang.github.io/tags/Workflow/"}]},{"title":"修正 FacebookSDK 使用 Advertising Identifier(IDFA) 造成的 App 退審","slug":"revised-app-rejected-because-of-idfa-in-facebooksdk","date":"2014-08-22T21:21:00.000Z","updated":"2019-11-15T08:50:11.855Z","comments":true,"path":"2014/08/23/revised-app-rejected-because-of-idfa-in-facebooksdk/","link":"","permalink":"https://calvertyang.github.io/2014/08/23/revised-app-rejected-because-of-idfa-in-facebooksdk/","excerpt":"","text":"這次 App 送審被 Apple 以違反 PLA 3.3.12 而退審，內容大致上是說 Advertising Identifier(IDFA) 僅可基於廣告目的使用於應用程式內，但審核團隊沒發現需用 IDFA 來呈現廣告的地方。 因送審的 App 內僅使用 iAd，而 iAd 是不需 AdSupport framework、ASIdentifierManager 或 Advertising Identifier 的，所以唯一的可能性就是第三方 Framework 使用了 IDFA。 Apple 在退審原因內提示可透過 strings 或 otool 指令來幫忙找出問題點，最終揪出兇手就是 FacebookSDK，在 FBUtility.m 引入了 AdSupport 並使用 advertisingIdentifier。 暫時的解決方法如下： git clone FacebookSDK 到本機 開啟 src/Core/FBUtility.m，將此行註解 1//#import &lt;AdSupport/AdSupport.h&gt; 將 123456789+ (NSString *)advertiserID &#123; NSString *advertiserID = nil; Class ASIdentifierManagerClass = [FBDynamicFrameworkLoader loadClass:@\"ASIdentifierManager\" withFramework:@\"AdSupport\"]; if ([ASIdentifierManagerClass class]) &#123; ASIdentifierManager *manager = [ASIdentifierManagerClass sharedManager]; advertiserID = [[manager advertisingIdentifier] UUIDString]; &#125; return advertiserID;&#125; 改為 123+ (NSString *)advertiserID &#123; return @\"\";&#125; 將 1234567891011121314+ (FBAdvertisingTrackingStatus)advertisingTrackingStatus &#123; if ([FBSettings restrictedTreatment] == FBRestrictedTreatmentYES) &#123; return AdvertisingTrackingDisallowed; &#125; FBAdvertisingTrackingStatus status = AdvertisingTrackingUnspecified; Class ASIdentifierManagerClass = [FBDynamicFrameworkLoader loadClass:@\"ASIdentifierManager\" withFramework:@\"AdSupport\"]; if ([ASIdentifierManagerClass class]) &#123; ASIdentifierManager *manager = [ASIdentifierManagerClass sharedManager]; if (manager) &#123; status = [manager isAdvertisingTrackingEnabled] ? AdvertisingTrackingAllowed : AdvertisingTrackingDisallowed; &#125; &#125; return status;&#125; 改為 123+ (FBAdvertisingTrackingStatus)advertisingTrackingStatus &#123; return AdvertisingTrackingDisallowed;&#125; 使用 scripts/build_framework.sh 重新打包 FacebookSDK。 返回原專案引用新打包的 FacebookSDK 重建 App 並送審。 註：若 App 內使用了 iAd 以外的廣告服務且廣告有正常顯示，應該不會因違反 PLA 3.3.12 而退審。 參考資料： Stack Overflow：app rejected because of advertisingIdentifier in Facebook SDK and Flurry SDK Github：Rejection for ASIdentifierManager","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://calvertyang.github.io/tags/iOS/"}]},{"title":"看懂 npm 語意化版本","slug":"npm-semantic-versioner","date":"2014-08-19T22:14:00.000Z","updated":"2019-11-15T08:50:11.863Z","comments":true,"path":"2014/08/20/npm-semantic-versioner/","link":"","permalink":"https://calvertyang.github.io/2014/08/20/npm-semantic-versioner/","excerpt":"","text":"npm(Node Package Manager) 採用語意化版本 2.0.0 規範，詳細的規範內容可查看 http://semver.org/。 使用 npm 管理套件時，你會注意到 package.json 內的套件版本有許多表示法，以下說明各表示法所代表的意思： 版本 說明 1.2.3 指定版本。需為完整的版號，包含主版號、次版號及修訂號。需注意的是，版本編譯資訊（Metadata）會被忽略，所以 1.2.3+build2012 滿足此條件。 &gt;1.2.3 大於指定版本。 &lt;1.2.3 小於指定版本。如果沒有預先發佈版在此版本範圍，則沒有預先發佈版會被允許，即使在技術上是「小於」。 &gt;=1.2.3 大於或等於。需注意的是，預先發佈版不等同其版本。因此 1.2.3-beta 不滿足此條件，但 2.3.0-beta 則會。 &lt;=1.2.3 小於或等於。在這種情況下，允許預先發佈版，所以 1.2.3-beta 滿足此條件。 1.2.3 - 2.3.4 等同於 &gt;=1.2.3 &lt;=2.3.4。 ~1.2.3 等同於 &gt;=1.2.3-0 &lt;1.3.0-0，當使用 ~ 符號時，支援預先發佈版，但不含次版號的變更（及其預先發佈版）。因此 1.3.0-beta 不滿足 ~1.2.3。 ^1.2.3 等同於 &gt;=1.2.3-0 &lt;2.0.0-0，當使用 ^ 符號時，支援任何次版號及修訂號的變更（含預先發佈版），但不含主版號的變更（及其預先發佈版）。因此 1.5.1 能滿足 ^1.2.3，而 1.2.2 及 2.0.0-beta 則不會。 ^0.1.3 等同於 0.1.3，與 0.1.3 版相容。0.x.x 版比較特殊，因為語意化版本規範規定 0.x.x 版不作任何穩定性保證，只有指定的版本被認為是有效的。 ~0.0.2 等同於 0.0.2，與 0.0.2 版相容。 ~1.2 等同於 &gt;=1.2.0-0 &lt;1.3.0-0，任何從 1.2 開始的版本。 ^1.2 等同於 &gt;=1.2.0-0 &lt;1.3.0-0，任何相容於從 1.2 開始的版本。 1.2.x 等同於 &gt;=1.2.0-0 &lt;1.3.0-0，任何從 1.2 開始的版本。 1.2.* 等同於 1.2.x。 1.2 等同於 1.2.x。 ~1 等同於 &gt;=1.0.0-0 &lt;2.0.0-0，任何從 1 開始的版本。 ^1 等同於 &gt;=1.0.0-0 &lt;2.0.0-0，任何相容於從 1 開始的版本。 1.x 等同於 &gt;=1.0.0-0 &lt;2.0.0-0，任何從 1 開始的版本。 1.* 等同於 1.x。 1 等同於 1.x。 * 任何版本。 x 等同於 *。 &quot;&quot; 空字串，等同於 *。 官方文件：The semantic versioner for npm","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://calvertyang.github.io/tags/Node-js/"},{"name":"npm","slug":"npm","permalink":"https://calvertyang.github.io/tags/npm/"},{"name":"SemVer","slug":"SemVer","permalink":"https://calvertyang.github.io/tags/SemVer/"}]},{"title":"SQL 及 MongoDB 集合(Aggregation)指令對應表","slug":"sql-to-aggregation-mapping-chart","date":"2013-11-15T19:10:00.000Z","updated":"2019-11-15T08:50:11.881Z","comments":true,"path":"2013/11/16/sql-to-aggregation-mapping-chart/","link":"","permalink":"https://calvertyang.github.io/2013/11/16/sql-to-aggregation-mapping-chart/","excerpt":"集合管線(aggregation pipeline)允許 MongoDB 提供原生集合功能，對應 SQL 中許多常見的資料集合操作。 下表列出了常見的 SQL 集合術語、功能及概念和相應的 MongoDB 集合運算元概觀。 SQL 術語、功能及概念 MongoDB 集合運算元 WHERE $match GROUP BY $group HAVING $match SELECT $project ORDER BY $sort LIMIT $limit SUM() $sum COUNT() $sum join 沒有直接對應的運算元，然而，$unwind 運算元允許有些類似的功能，但是與嵌入的欄位在文件內。","text":"集合管線(aggregation pipeline)允許 MongoDB 提供原生集合功能，對應 SQL 中許多常見的資料集合操作。 下表列出了常見的 SQL 集合術語、功能及概念和相應的 MongoDB 集合運算元概觀。 SQL 術語、功能及概念 MongoDB 集合運算元 WHERE $match GROUP BY $group HAVING $match SELECT $project ORDER BY $sort LIMIT $limit SUM() $sum COUNT() $sum join 沒有直接對應的運算元，然而，$unwind 運算元允許有些類似的功能，但是與嵌入的欄位在文件內。 範例(Examples)下表列出了 SQL 集合語句和相應的 MongoDB 語句的快速參考。在表格中的範例假定有下列條件： SQL 範例假設有兩張資料表 orders 及 order_lineitem，透過 order_lineitem.order_id 及 orders.id 資料行相連結。 MongoDB 範例假設一個名為 orders 的集合，包含的文件原型如下： 12345678&#123; cust_id: \"abc123\", ord_date: ISODate(\"2012-11-02T17:04:11.102Z\"), status: 'A', price: 50, items: [ &#123; sku: \"xxx\", qty: 25, price: 1 &#125;, &#123; sku: \"yyy\", qty: 25, price: 1 &#125; ]&#125; MongoDB 語句中集合內的文件的欄位名稱在集合操作時以 $ 字元為字首。 計算 orders 所有資料數 SQL 架構語句 12SELECT COUNT(*) AS countFROM orders MongoDB 架構語句 1234db.orders.aggregate( [ &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;] ) 加總 orders 的 price 欄位 SQL 架構語句 12SELECT SUM(price) AS totalFROM orders MongoDB 架構語句 1234db.orders.aggregate( [ &#123; $group: &#123; _id: null, total: &#123; $sum: \"$price\" &#125; &#125; &#125;] ) 對不同的 cust_id 加總 price 欄位 SQL 架構語句 1234SELECT cust_id, SUM(price) AS totalFROM ordersGROUP BY cust_id MongoDB 架構語句 1234db.orders.aggregate( [ &#123; $group: &#123; _id: \"$cust_id\", total: &#123; $sum: \"$price\" &#125; &#125; &#125;] ) 對不同的 cust_id 加總 price 欄位，並依照加總排序 SQL 架構語句 12345SELECT cust_id, SUM(price) AS totalFROM ordersGROUP BY cust_idORDER BY total MongoDB 架構語句 12345db.orders.aggregate( [ &#123; $group: &#123; _id: \"$cust_id\", total: &#123; $sum: \"$price\" &#125; &#125; &#125;, &#123; $sort: &#123; total: 1 &#125; &#125;] ) 對不同的 cust_id 及 ord_date 分組，加總 price 欄位 SQL 架構語句 12345SELECT cust_id, ord_date, SUM(price) AS totalFROM ordersGROUP BY cust_id, ord_date MongoDB 架構語句 12345db.orders.aggregate( [ &#123; $group: &#123; _id: &#123; cust_id: \"$cust_id\", ord_date: \"$ord_date\" &#125;, total: &#123; $sum: \"$price\" &#125; &#125; &#125;] ) 對於 cust_id 的多筆資料，返回 cust_id 和相應的資料數 SQL 架構語句 1234SELECT cust_id, count(*)FROM ordersGROUP BY cust_idHAVING count(*) &gt; 1 MongoDB 架構語句 12345db.orders.aggregate( [ &#123; $group: &#123; _id: \"$cust_id\", count: &#123; $sum: 1 &#125; &#125; &#125;, &#123; $match: &#123; count: &#123; $gt: 1 &#125; &#125; &#125;] ) 對不同的 cust_id 及 ord_date 分組，加總 price 欄位，並只返回總和大於 250 的資料 SQL 架構語句 123456SELECT cust_id, ord_date, SUM(price) AS totalFROM ordersGROUP BY cust_id, ord_dateHAVING total &gt; 250 MongoDB 架構語句 123456db.orders.aggregate( [ &#123; $group: &#123; _id: &#123; cust_id: \"$cust_id\", ord_date: \"$ord_date\" &#125;, total: &#123; $sum: \"$price\" &#125; &#125; &#125;, &#123; $match: &#123; total: &#123; $gt: 250 &#125; &#125; &#125;] ) 對 status 為 A 的不同的 cust_id 加總 price 欄位 SQL 架構語句 12345SELECT cust_id, SUM(price) as totalFROM ordersWHERE status = 'A'GROUP BY cust_id MongoDB 架構語句 12345db.orders.aggregate( [ &#123; $match: &#123; status: 'A' &#125; &#125;, &#123; $group: &#123; _id: \"$cust_id\", total: &#123; $sum: \"$price\" &#125; &#125; &#125;] ) 對 status 為 A 的不同的 cust_id 加總 price 欄位，並只返回總和大於 250 的資料 SQL 架構語句 123456SELECT cust_id, SUM(price) as totalFROM ordersWHERE status = 'A'GROUP BY cust_idHAVING total &gt; 250 MongoDB 架構語句 123456db.orders.aggregate( [ &#123; $match: &#123; status: 'A' &#125; &#125;, &#123; $group: &#123; _id: \"$cust_id\", total: &#123; $sum: \"$price\" &#125; &#125; &#125;, &#123; $match: &#123; total: &#123; $gt: 250 &#125; &#125; &#125;] ) 對不同的 cust_id 加總與 orders 相應的 order_lineitem 的 qty 欄位 SQL 架構語句 123456SELECT cust_id, SUM(li.qty) as qtyFROM orders o, order_lineitem liWHERE li.order_id = o.idGROUP BY cust_id MongoDB 架構語句 12345db.orders.aggregate( [ &#123; $unwind: \"$items\" &#125;, &#123; $group: &#123; _id: \"$cust_id\", qty: &#123; $sum: \"$items.qty\" &#125; &#125; &#125;] ) 計算不同的 cust_id 及 ord_date 分組數量 SQL 架構語句 1234SELECT COUNT(*)FROM (SELECT cust_id, ord_date FROM orders GROUP BY cust_id, ord_date) as DerivedTable MongoDB 架構語句 12345db.orders.aggregate( [ &#123; $group: &#123; _id: &#123; cust_id: \"$cust_id\", ord_date: \"$ord_date\" &#125; &#125; &#125;, &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;] )","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://calvertyang.github.io/tags/SQL/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://calvertyang.github.io/tags/NoSQL/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://calvertyang.github.io/tags/MongoDB/"}]},{"title":"SQL 及 MongoDB 基本指令對應表","slug":"sql-to-mongodb-mapping-chart","date":"2013-11-14T03:46:00.000Z","updated":"2019-11-15T08:50:11.883Z","comments":true,"path":"2013/11/14/sql-to-mongodb-mapping-chart/","link":"","permalink":"https://calvertyang.github.io/2013/11/14/sql-to-mongodb-mapping-chart/","excerpt":"由於新專案採用了 Node.js 開發且使用 MongoDB 作為儲存媒介，所以動手翻譯了官方文件方便查閱相關指令用法。 術語和概念(Terminology and Concepts)下表列出了各種 SQL 和相應的 MongoDB 的術語和概念。 SQL 術語/概念 MongoDB 術語/概念 資料庫(database) 資料庫(database) 資料表(table) 集合(collection) 資料列(row) 文件(document) 或 BSON 文件 資料行(column) 欄位(field) 索引(index) 索引(index) 資料表連結(table joins) 嵌入式文件及連結(embedded documents and linking) 主索引鍵(primary key)指定任意一個或多個欄位組合為主索引鍵，資料內容須唯一不可重複。 主索引鍵(primary key)在 MongoDB，主索引鍵會自動設定到 _id 欄位。 彙總(aggregation)，例如：group by 彙總管線(aggregation pipeline)參閱 SQL 至彙總(Aggregation)對應表. 可執行檔案(Executables)下表列出了 MySQL / Oracle 可執行檔案和相應的 MongoDB 的可執行檔案。 MySQL / Oracle MongoDB 資料庫伺服器(Database Server) mysqld / oracle mongod 資料庫用戶端(Database Client) mysql / sqlplus mongo","text":"由於新專案採用了 Node.js 開發且使用 MongoDB 作為儲存媒介，所以動手翻譯了官方文件方便查閱相關指令用法。 術語和概念(Terminology and Concepts)下表列出了各種 SQL 和相應的 MongoDB 的術語和概念。 SQL 術語/概念 MongoDB 術語/概念 資料庫(database) 資料庫(database) 資料表(table) 集合(collection) 資料列(row) 文件(document) 或 BSON 文件 資料行(column) 欄位(field) 索引(index) 索引(index) 資料表連結(table joins) 嵌入式文件及連結(embedded documents and linking) 主索引鍵(primary key)指定任意一個或多個欄位組合為主索引鍵，資料內容須唯一不可重複。 主索引鍵(primary key)在 MongoDB，主索引鍵會自動設定到 _id 欄位。 彙總(aggregation)，例如：group by 彙總管線(aggregation pipeline)參閱 SQL 至彙總(Aggregation)對應表. 可執行檔案(Executables)下表列出了 MySQL / Oracle 可執行檔案和相應的 MongoDB 的可執行檔案。 MySQL / Oracle MongoDB 資料庫伺服器(Database Server) mysqld / oracle mongod 資料庫用戶端(Database Client) mysql / sqlplus mongo 範例(Examples)下表列出了各種 SQL 語句和相應的 MongoDB 語句。在表格中的範例假定有下列條件： SQL 範例假設是名為 users 的資料表 MongoDB 範例假設是名為 users 的集合，包含的文件原型如下： 123456&#123; _id: ObjectID(\"509a8fb2f3f4948bd2f983a0\"), user_id: \"abc123\", age: 55, status: 'A'&#125; 建立及修改資料表(Create and Alter)下面列出了關於資料表層級操作的各種 SQL 語句和相應的 MongoDB 語句。 SQL 架構語句 12345678CREATE TABLE users ( id MEDIUMINT NOT NULL AUTO_INCREMENT, user_id Varchar(30), age Number, status char(1), PRIMARY KEY (id)) MongoDB 架構語句在第一次插入資料操作時透過隱含方式建立。若未指定 _id 欄位，則會自動建立主索引鍵 _id。 12345db.users.insert( &#123; user_id: \"abc123\", age: 55, status: \"A\" &#125; ) 然而，你也可以明確地建立一個集合： 1db.createCollection(\"users\") 參閱 insert() 和 db.createCollection() 取得更多資訊。 SQL 架構語句 12ALTER TABLE usersADD join_date DATETIME MongoDB 架構語句集合不描述或強制其文件結構，即在集合層級沒有結構上的改變。然而，在文件層級，update() 操作可以透過 $set 運算元加入欄位到已存在的文件。 12345db.users.update( &#123; &#125;, &#123; $set: &#123; join_date: new Date() &#125; &#125;, &#123; multi: true &#125;) 參閱 Data Modeling Concepts、update() 及 $set 取得更多改變集合中文件結構的更多資訊。 SQL 架構語句 12ALTER TABLE usersDROP COLUMN join_date MongoDB 架構語句集合不描述或強制其文件結構，即在集合層級中沒有結構上的改變。然而，在文件層級，update() 操作可以透過 $unset 運算元從文件移除欄位。 12345db.users.update( &#123; &#125;, &#123; $unset: &#123; join_date: \"\" &#125; &#125;, &#123; multi: true &#125;) 參閱 Data Modeling Concepts、update() 及 $unset 取得更多改變集合中文件結構的更多資訊。 SQL 架構語句 12CREATE INDEX idx_user_id_ascON users(user_id) MongoDB 架構語句 1db.users.ensureIndex( &#123; user_id: 1 &#125; ) 參閱 ensureIndex() 及 indexes 取得更多資訊。 SQL 架構語句 123CREATE INDEX idx_user_id_asc_age_descON users(user_id, age DESC) MongoDB 架構語句 1db.users.ensureIndex( &#123; user_id: 1, age: -1 &#125; ) 參閱 ensureIndex() 及 indexes 取得更多資訊。 SQL 架構語句 1DROP TABLE users MongoDB 架構語句 1db.users.drop() 參閱 drop() 取得更多資訊。 插入(Insert)下面列出了關於插入資料到資料表的各種 SQL 語句和相應的 MongoDB 語句。 SQL 架構語句 12345678INSERT INTO users( user_id, age, status)VALUES ( \"bcd001\", 45, \"A\") MongoDB 架構語句 12345db.users.insert( &#123; user_id: \"bcd001\", age: 45, status: \"A\"&#125; ) 參閱 insert() 取得更多資訊。 選擇(Select)下面列出了關於從資料表讀取資料的各種 SQL 語句和相應的 MongoDB 語句。 SQL 架構語句 12SELECT *FROM users MongoDB 架構語句 1db.users.find() 參閱 find() 取得更多資訊。 SQL 架構語句 12SELECT id, user_id, statusFROM users MongoDB 架構語句 1234db.users.find( &#123; &#125;, &#123; user_id: 1, status: 1 &#125;) 參閱 find() 取得更多資訊。 SQL 架構語句 12SELECT user_id, statusFROM users MongoDB 架構語句 1234db.users.find( &#123; &#125;, &#123; user_id: 1, status: 1, _id: 0 &#125;) 參閱 find() 取得更多資訊。 SQL 架構語句 123SELECT *FROM usersWHERE status = \"A\" MongoDB 架構語句 123db.users.find( &#123; status: \"A\" &#125;) 參閱 find() 取得更多資訊。 SQL 架構語句 123SELECT user_id, statusFROM usersWHERE status = \"A\" MongoDB 架構語句 1234db.users.find( &#123; status: \"A\" &#125;, &#123; user_id: 1, status: 1, _id: 0 &#125;) 參閱 find() 取得更多資訊。 SQL 架構語句 123SELECT *FROM usersWHERE status != \"A\" MongoDB 架構語句 123db.users.find( &#123; status: &#123; $ne: \"A\" &#125; &#125;) 參閱 find() 及 $ne 取得更多資訊。 SQL 架構語句 1234SELECT *FROM usersWHERE status = \"A\"AND age = 50 MongoDB 架構語句 1234db.users.find( &#123; status: \"A\", age: 50 &#125;) 參閱 find() 及 $and 取得更多資訊。 SQL 架構語句 1234SELECT *FROM usersWHERE status = \"A\"OR age = 50 MongoDB 架構語句 1234db.users.find( &#123; $or: [ &#123; status: \"A\" &#125; , &#123; age: 50 &#125; ] &#125;) 參閱 find() 及 $or 取得更多資訊。 SQL 架構語句 123SELECT *FROM usersWHERE age &gt; 25 MongoDB 架構語句 123db.users.find( &#123; age: &#123; $gt: 25 &#125; &#125;) 參閱 find() 及 $gt 取得更多資訊。 SQL 架構語句 123SELECT *FROM usersWHERE age &lt; 25 MongoDB 架構語句 123db.users.find( &#123; age: &#123; $lt: 25 &#125; &#125;) 參閱 find() 及 $lt 取得更多資訊。 SQL 架構語句 1234SELECT *FROM usersWHERE age &gt; 25AND age &lt;= 50 MongoDB 架構語句 123db.users.find( &#123; age: &#123; $gt: 25, $lte: 50 &#125; &#125;) 參閱 find()、$gt 及 $lte 取得更多資訊。 SQL 架構語句 123SELECT *FROM usersWHERE user_id like \"%bc%\" MongoDB 架構語句 123db.users.find( &#123; user_id: /bc/ &#125;) 參閱 find() 及 $regex 取得更多資訊。 SQL 架構語句 123SELECT *FROM usersWHERE user_id like \"bc%\" MongoDB 架構語句 123db.users.find( &#123; user_id: /^bc/ &#125;) 參閱 find() 及 $regex 取得更多資訊。 SQL 架構語句 1234SELECT *FROM usersWHERE status = \"A\"ORDER BY user_id ASC MongoDB 架構語句 1db.users.find( &#123; status: \"A\" &#125; ).sort( &#123; user_id: 1 &#125; ) 參閱 find() 及 sort() 取得更多資訊。 SQL 架構語句 1234SELECT *FROM usersWHERE status = \"A\"ORDER BY user_id DESC MongoDB 架構語句 1db.users.find( &#123; status: \"A\" &#125; ).sort( &#123; user_id: -1 &#125; ) 參閱 find() 及 sort() 取得更多資訊。 SQL 架構語句 12SELECT COUNT(*)FROM users MongoDB 架構語句 1db.users.count() 或 1db.users.find().count() 參閱 find() 及 count() 取得更多資訊。 SQL 架構語句 12SELECT COUNT(user_id)FROM users MongoDB 架構語句 1db.users.count( &#123; user_id: &#123; $exists: true &#125; &#125; ) 或 1db.users.find( &#123; user_id: &#123; $exists: true &#125; &#125; ).count() 參閱 find()、count() 及 $exists 取得更多資訊。 SQL 架構語句 123SELECT COUNT(*)FROM usersWHERE age &gt; 30 MongoDB 架構語句 1db.users.count( &#123; age: &#123; $gt: 30 &#125; &#125; ) 或 1db.users.find( &#123; age: &#123; $gt: 30 &#125; &#125; ).count() 參閱 find()、count() 及 $gt 取得更多資訊。 SQL 架構語句 12SELECT DISTINCT(status)FROM users MongoDB 架構語句 1db.users.distinct( \"status\" ) 參閱 find() 及 distinct() 取得更多資訊。 SQL 架構語句 123SELECT *FROM usersLIMIT 1 MongoDB 架構語句 1db.users.findOne() 或 1db.users.find().limit(1) 參閱 find()、findOne() 及 limit() 取得更多資訊。 SQL 架構語句 1234SELECT *FROM usersLIMIT 5SKIP 10 MongoDB 架構語句 1db.users.find().limit(5).skip(10) 參閱 find()、limit() 及 skip() 取得更多資訊。 SQL 架構語句 123EXPLAIN SELECT *FROM usersWHERE status = \"A\" MongoDB 架構語句 1db.users.find( &#123; status: \"A\" &#125; ).explain() 參閱 find() 及 explain() 取得更多資訊。 修改資料(Update Records)下面列出了關於修改現有資料表內資料的各種 SQL 語句和相應的 MongoDB 語句。 SQL 架構語句 123UPDATE usersSET status = \"C\"WHERE age &gt; 25 MongoDB 架構語句 12345db.users.update( &#123; age: &#123; $gt: 25 &#125; &#125;, &#123; $set: &#123; status: \"C\" &#125; &#125;, &#123; multi: true &#125;) 參閱 update()、$gt 及 $set 取得更多資訊。 SQL 架構語句 123UPDATE usersSET age = age + 3WHERE status = \"A\" MongoDB 架構語句 12345db.users.update( &#123; status: \"A\" &#125; , &#123; $inc: &#123; age: 3 &#125; &#125;, &#123; multi: true &#125;) 參閱 update()、$inc 及 $set 取得更多資訊。 刪除資料(Delete Records)下面列出了關於從資料表刪除資料的各種 SQL 語句和相應的 MongoDB 語句。 SQL 架構語句 12DELETE FROM usersWHERE status = \"D\" MongoDB 架構語句 1db.users.remove( &#123; status: \"D\" &#125; ) 參閱 remove() 取得更多資訊。 SQL 架構語句 1DELETE FROM users MongoDB 架構語句 1db.users.remove( ) 參閱 remove() 取得更多資訊。 參考資料：SQL to MongoDB Mapping Chart","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://calvertyang.github.io/tags/SQL/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://calvertyang.github.io/tags/NoSQL/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://calvertyang.github.io/tags/MongoDB/"}]},{"title":"如何在 CentOS 6 安裝 Redis","slug":"how-to-install-redis-in-centos-6","date":"2013-11-05T20:45:00.000Z","updated":"2019-11-15T08:50:11.863Z","comments":true,"path":"2013/11/06/how-to-install-redis-in-centos-6/","link":"","permalink":"https://calvertyang.github.io/2013/11/06/how-to-install-redis-in-centos-6/","excerpt":"","text":"Redis 是一個開源、遵守 BSD 授權、先進的鍵值對儲存庫。它通常被稱為資料結構伺服器，因為值可以是字串(String)、雜湊(Hash)、列表(List)、集合(Set)及序列集合(Sorted Set)等類型。 下載並解壓縮 123$ wget http://download.redis.io/redis-stable.tar.gz$ tar -zxvf redis-stable.tar.gz$ cd redis-stable 編譯並測試是否可安裝 12$ make$ make test 若出現訊息，代表系統尚未安裝 tcl 123456cd src &amp;&amp; make testmake[1]: Entering directory `/tmp/redis-stable/src'You need tcl 8.5 or newer in order to run the Redis testmake[1]: *** [test] Error 1make[1]: Leaving directory `/tmp/redis-stable/src'make: *** [test] Error 2 tcl 安裝步驟，詳見官方文件 安裝 redis 1234567891011$ make installcd src &amp;&amp; make installmake[1]: Entering directory '/tmp/redis-stable/src'Hint: To run 'make test' is a good idea ;)mkdir -p /usr/local/bin INSTALL install INSTALL install INSTALL install INSTALL install INSTALL installmake[1]: Leaving directory `/tmp/redis-stable/src' 到此，redis 便安裝完畢了，redis 包含了以下幾個部分： redis-server: is the Redis Server itself. redis-cli: is the command line interface utility to talk with Redis. redis-benchmark: is used to check Redis performances. redis-check-aof 及 redis-check-dump: are useful in the rare event of corrupted data files. 啟動 redis最簡單的啟動方式為直接執行 redis-server 且不含任何參數。 1234567$ redis-server[12182] 06 Nov 13:58:15.841 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf[12182] 06 Nov 13:58:15.842 * Max number of open files set to 10032......[12182] 06 Nov 13:58:15.843 # Server started, Redis version 2.6.16[12182] 06 Nov 13:58:15.843 * The server is now ready to accept connections on port 6379 若要啟動 redis 並帶入設定檔，只需將設定檔的完整路徑帶入即可，如：redis-server /etc/redis.conf 接著加入設定將 redis 作為服務於開機時啟動建立工作目錄 1$ sudo mkdir /var/redis 從 utils 資料夾複製啟動腳本到 /etc/init.d/ 1$ sudo cp utils/redis_init_script /etc/init.d/redis 編輯啟動腳本，根據需求修改 REDIS_PORT 1sudo vi /etc/init.d/redis 複製預設設定檔 1sudo cp redis.conf /etc/redis.conf 需修改以下幾個項目 daemonize: 設定為 yes 讓 redis 可背景執行，預設為 no port: 根據需求修改連接埠，預設為 6379 loglevel: 根據需求修改要記錄的訊息等級，預設為 notice logfile: 設定要放置記錄檔的位置，預設為標準輸出(stdout) 不會保留記錄於檔案內 dir: 將工作目錄設定為 /var/redis (此設定非常重要) 最後，將啟動腳本加入開機執行 1sudo update-rc.d redis defaults 現在你可以透過以下指令啟動 redis 1service redis start","categories":[{"name":"Server","slug":"Server","permalink":"https://calvertyang.github.io/categories/Server/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://calvertyang.github.io/tags/Linux/"},{"name":"Redis","slug":"Redis","permalink":"https://calvertyang.github.io/tags/Redis/"}]},{"title":"Mac OS X 延長 SSD 壽命","slug":"mac-os-x-ssd-performance-optimization","date":"2013-10-26T04:28:00.000Z","updated":"2019-11-15T08:50:11.875Z","comments":true,"path":"2013/10/26/mac-os-x-ssd-performance-optimization/","link":"","permalink":"https://calvertyang.github.io/2013/10/26/mac-os-x-ssd-performance-optimization/","excerpt":"","text":"由於有時候會重灌電腦，所以在這記錄一下重灌之後要延長 SSD 所做的步驟。 關閉 Time Machine 的本機備份模式如果有開啟 Time Machine 功能，當備份磁碟無法使用時，系統還是會每小時建立快照摒除存在本機硬碟，使用以下指令可以禁止系統在本地端備份檔案 1$ sudo tmutil disablelocal 往後也可以使用以下的指令重新開啟這個功能 1$ sudo tmutil enablelocal 設定 noatime 掛載Unix like 的作業系統，會在每次存取檔案時修改 Access time 的屬性，可以令如 Spotlight 的程式找到最近存取的檔案。但是每次存取檔案時皆會對硬碟寫入資料，對有存取次數限制的 SSD 來說便會縮短壽命，以下的步驟可以取消記錄存取時間。 在家目錄建立 com.disk.noatime.plist 檔案，內容如下： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt;&lt;key&gt;Label&lt;/key&gt;&lt;string&gt;com.disk.noatime&lt;/string&gt;&lt;key&gt;ProgramArguments&lt;/key&gt;&lt;array&gt;&lt;string&gt;mount&lt;/string&gt;&lt;string&gt;-vuwo&lt;/string&gt;&lt;string&gt;noatime&lt;/string&gt;&lt;string&gt;/&lt;/string&gt;&lt;/array&gt;&lt;key&gt;RunAtLoad&lt;/key&gt;&lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt; 搬移檔案到 LaunchDaemons 資料夾 1$ sudo mv ~/com.disk.noatime.plist /Library/LaunchDaemons/ 變更 com.disk.noatime.plist 檔案擁有者 1$ sudo chown root:wheel /Library/LaunchDaemons/com.disk.noatime.plist 重開機後，於終端機內輸入 mount 看到 noatime 代表已使用 noatime 掛載 12$ mount/dev/disk0s2 on / (hfs, local, journaled, noatime) 變更睡眠時資料儲存位置當系統進入睡眠狀態時，OS X 預設將資料保存於記憶體內，另外再將記憶體資料寫入硬碟，防止電腦沒電時資料遺失。假設記憶體有 8 GB，代表睡眠時若電腦電力不足都會將 8 GB 資料寫入硬碟，長期下來 SSD 的壽命將會大打折扣，因此我們要變更睡眠時的資料存放位置，改為只存於記憶體中，但若是電腦沒電時，資料便會遺失。 透使用下列指令設定睡眠時只存在記憶體 1$ sudo pmset -a hibernatemode 0 刪除在硬碟上的睡眠備份檔 1$ sudo rm /var/vm/sleepimage 若要改回預設的模式，則輸入 1$ sudo pmset -a hibernatemode 3 輸入下列指令可以查看目前模式 1$ sudo pmset -g | grep hibernatemode hibernatemode 0 建立一個空檔案，防止系統再產生 sleepimage建立檔案 1$ sudo touch /var/vm/sleepimage 防止系統修改此檔案 1$ chflags uchg /var/vm/sleepimage","categories":[{"name":"Mac","slug":"Mac","permalink":"https://calvertyang.github.io/categories/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://calvertyang.github.io/tags/Mac/"}]},{"title":"使用 jQuery Validation Plugin 驗證元素陣列","slug":"jquery-validation-plugin-for-array-of-elements","date":"2013-10-19T17:52:00.000Z","updated":"2019-11-15T08:50:11.885Z","comments":true,"path":"2013/10/20/jquery-validation-plugin-for-array-of-elements/","link":"","permalink":"https://calvertyang.github.io/2013/10/20/jquery-validation-plugin-for-array-of-elements/","excerpt":"","text":"有時候我們會需要驗證表單中的元素陣列，例如： 1234567891011121314151617181920212223242526272829&lt;form id=\"userDataForm\" name=\"userDataForm\" method=\"post\" action=\"\"&gt; &lt;!-- User 1 --&gt; &lt;input type=\"text\" id=\"userName1\" name=\"userName[]\" /&gt; &lt;input type=\"text\" id=\"userAddress1\" name=\"userAddress[]\" /&gt; &lt;select id=\"sex1\" name=\"sex[]\"&gt; &lt;option value=\"\"&gt;- 請選擇 -&lt;/option&gt; &lt;option value=\"1\"&gt;男&lt;/option&gt; &lt;option value=\"0\"&gt;女&lt;/option&gt; &lt;/select&gt; … &lt;!-- User 2 --&gt; &lt;input type=\"text\" id=\"userName2\" name=\"userName[]\" /&gt; &lt;input type=\"text\" id=\"userAddress2\" name=\"userAddress[]\" /&gt; &lt;select id=\"sex2\" name=\"sex[]\"&gt; &lt;option value=\"\"&gt;- 請選擇 -&lt;/option&gt; &lt;option value=\"1\"&gt;男&lt;/option&gt; &lt;option value=\"0\"&gt;女&lt;/option&gt; &lt;/select&gt; … &lt;!-- User N --&gt; &lt;input type=\"text\" id=\"userNameN\" name=\"userName[]\" /&gt; &lt;input type=\"text\" id=\"userAddressN\" name=\"userAddress[]\" /&gt; &lt;select id=\"sexN\" name=\"sex[]\"&gt; &lt;option value=\"\"&gt;- 請選擇 -&lt;/option&gt; &lt;option value=\"1\"&gt;男&lt;/option&gt; &lt;option value=\"0\"&gt;女&lt;/option&gt; &lt;/select&gt; …&lt;/form&gt; 現在，使用 jQuery Validation Plugin 來驗證此表單。驗證條件為使用者必須填寫各輸入欄位，驗證語法如下： 123456789101112131415161718&lt;script src=\"jquery.js\"&gt;&lt;/script&gt;&lt;script src=\"jquery.validate.js\"&gt;&lt;/script&gt;&lt;script&gt;$(function() &#123; $(\"#userDataForm\").validate(&#123; rules: &#123; \"userName[]\": \"required\", \"userAddress[]\": \"required\", \"sex[]\": \"required\" &#125;, messages: &#123; \"userName[]\": \"請輸入姓名\", \"userAddress[]\": \"請輸入地址\", \"sex[]\": \"請選擇性別\" &#125; &#125;);&#125;);&lt;/script&gt; 使用以上的語法會遇到的問題是 jquery.validate.js 僅有驗證 userName 及 userAddress 陣列的第一個元素，所以我們需要對此插件做點小修改。 開啟 jquery.validate.js，可以找到名為 checkForm 的方法，內容如下： jquery.validate.js1234567checkForm: function() &#123; this.prepareForm(); for ( var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++ ) &#123; this.check( elements[i] ); &#125; return this.valid();&#125; 將此方法修改為如下的內容後，便會驗證陣列中的所有元素。 jquery.validate.js1234567891011121314checkForm: function() &#123; this.prepareForm(); for ( var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++ ) &#123; if ( this.findByName( elements[i].name ).length != undefined &amp;&amp; this.findByName( elements[i].name ).length &gt; 1 ) &#123; for ( var j = 0; j &lt; this.findByName( elements[i].name ).length; j++ ) &#123; this.check( this.findByName( elements[i].name )[j] ); &#125; &#125; else &#123; this.check( elements[i] ); &#125; &#125; return this.valid();&#125; 參考資料：JQuery Validation for Array of Input Elements","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://calvertyang.github.io/tags/JavaScript/"}]},{"title":"為 Ngnix 建立自行簽章的憑證","slug":"creating-a-self-signed-ssl-certificate-for-nginx","date":"2013-10-17T02:01:00.000Z","updated":"2019-11-15T08:50:11.876Z","comments":true,"path":"2013/10/17/creating-a-self-signed-ssl-certificate-for-nginx/","link":"","permalink":"https://calvertyang.github.io/2013/10/17/creating-a-self-signed-ssl-certificate-for-nginx/","excerpt":"必要條件產生憑證需要 OpenSSL 類別庫，請先確認系統是否已安裝 OpenSSL。 若尚未安裝，可透過以下方式安裝： Mac OS X 使用 Homebrew 安裝 1$ brew install openssl Windows 可到此網站下載安裝檔：OpenSSL for Windows Ubuntu/Debian Linux 1$ sudo apt-get install openssl RedHat/CentOS Linux 1$ sudo yum install openssl","text":"必要條件產生憑證需要 OpenSSL 類別庫，請先確認系統是否已安裝 OpenSSL。 若尚未安裝，可透過以下方式安裝： Mac OS X 使用 Homebrew 安裝 1$ brew install openssl Windows 可到此網站下載安裝檔：OpenSSL for Windows Ubuntu/Debian Linux 1$ sudo apt-get install openssl RedHat/CentOS Linux 1$ sudo yum install openssl 步驟一：建立存放憑證的資料夾12$ mkdir /etc/nginx/ssl$ cd /etc/nginx/ssl 步驟二：建立伺服器私鑰及憑證建立伺服器私鑰開始建立伺服器私鑰。過程中，將會提示輸入密碼，請牢記此密碼，若忘記或遺失該密碼，將無法存取憑證。 1$ sudo openssl genrsa -des3 -out server.key 2048 以下為建立私鑰時可能會看到的訊息 123456Generating RSA private key, 2048 bit long modulus....................+++..............................................................+++e is 65537 (0x10001)Enter pass phrase for server.key:Verifying - Enter pass phrase for server.key: 建立伺服器憑證建立時會詢問私鑰密碼，若密碼不正確便無法建立憑證。建立憑證時，最重要的欄位為 Common Name。請在此輸入網域名稱，若沒有網域名稱則輸入網站 IP。並請不要填寫 challenge password 及 optional company name 欄位。 1$ sudo openssl req -new -key server.key -out server.csr 以下為建立憑證時可能會看到的訊息 1234567891011121314151617181920Enter pass phrase for server.key:You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]: TWState or Province Name (full name) [Some-State]: TaipeiLocality Name (eg, city) []: TaipeiOrganization Name (eg, company) [Internet Widgits Pty Ltd]: Example IncOrganizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []: example.comEmail Address []: admin@example.comPlease enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:An optional company name []: 步驟三：移除伺服器私鑰密碼(Passphrase)雖然密碼可提供高度的安全性，但若有人重載 nginx 則會產生問題。在 nginx 崩潰或需要重新啟動時，永遠都需要輸入密碼才能使網頁伺服器上線。 1$ sudo cp server.key server.key.origin 1$ sudo openssl rsa -in server.key.org -out server.key 步驟四：為憑證簽章可以自行指定該憑證有效期限，在此範例中憑證為 1 年後到期。 1$ sudo openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt 現在所需的憑證已產生完畢！ 步驟五：設定憑證開啟 nginx 設定檔，加入以下設定，請記得將 server_name 改為網域名稱或 IP。 12345678910# HTTPS serverserver &#123; listen 443; server_name example.com; ssl on; ssl_certificate /etc/nginx/ssl/server.crt; ssl_certificate_key /etc/nginx/ssl/server.key;&#125; 重新啟動 nginx 1$ sudo /etc/init.d/nginx restart 前往 https://domain_name 將會看到自行簽章的憑證。","categories":[{"name":"Server","slug":"Server","permalink":"https://calvertyang.github.io/categories/Server/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://calvertyang.github.io/tags/Linux/"},{"name":"SSL","slug":"SSL","permalink":"https://calvertyang.github.io/tags/SSL/"},{"name":"Nginx","slug":"Nginx","permalink":"https://calvertyang.github.io/tags/Nginx/"}]}]}
{"meta":{"title":"Calvert's murmur","subtitle":null,"description":null,"author":"Calvert","url":"https://calvertyang.github.io"},"pages":[{"title":"About","date":"2018-05-21T07:58:00.000Z","updated":"2018-05-21T07:58:00.000Z","comments":true,"path":"about/index.html","permalink":"https://calvertyang.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-05-21T07:58:00.000Z","updated":"2018-05-21T07:58:00.000Z","comments":true,"path":"categories/index.html","permalink":"https://calvertyang.github.io/categories/index.html","excerpt":"","text":""},{"title":"Project","date":"2018-05-21T07:58:00.000Z","updated":"2018-05-21T07:58:00.000Z","comments":true,"path":"project/index.html","permalink":"https://calvertyang.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-21T07:58:00.000Z","updated":"2018-05-21T07:58:00.000Z","comments":true,"path":"tags/index.html","permalink":"https://calvertyang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"在 Ruby on Rails 使用時區","slug":"working-with-time-zones-in-ruby-on-rails","date":"2018-09-18T06:42:46.000Z","updated":"2018-09-19T01:00:21.000Z","comments":true,"path":"2018/09/18/working-with-time-zones-in-ruby-on-rails/","link":"","permalink":"https://calvertyang.github.io/2018/09/18/working-with-time-zones-in-ruby-on-rails/","excerpt":"原文：VARVET BLOG — WORKING WITH TIME ZONES IN RUBY ON RAILS Rails 提供了很好的工具來處理時區，但仍有很多事情可能會出錯。這篇文章會點出這些問題並提供解決方案。 讓我被欺騙最多次的應該是，Rails 會愚弄你，讓你誤以為它替你處理好了所有和時間有關的部分。別誤會我的意思，我希望 Rails 盡可能的為我做更多事情，但在學習的過程中由於不夠熟悉 Rails 為我做了些什麼，因此碰到了許多困難。另外需要注意的是，在處理時區上，有更多是你意想不到需要處理的。需要考慮資料庫、伺服器、開發機器、系統設定、使用者設定和瀏覽器。","text":"原文：VARVET BLOG — WORKING WITH TIME ZONES IN RUBY ON RAILS Rails 提供了很好的工具來處理時區，但仍有很多事情可能會出錯。這篇文章會點出這些問題並提供解決方案。 讓我被欺騙最多次的應該是，Rails 會愚弄你，讓你誤以為它替你處理好了所有和時間有關的部分。別誤會我的意思，我希望 Rails 盡可能的為我做更多事情，但在學習的過程中由於不夠熟悉 Rails 為我做了些什麼，因此碰到了許多困難。另外需要注意的是，在處理時區上，有更多是你意想不到需要處理的。需要考慮資料庫、伺服器、開發機器、系統設定、使用者設定和瀏覽器。 設定你的 Rails 應用程式作為 Rails 開發人員，我們可以使用哪些工具？最重要的一個是 config/application.rb 檔案中的 config.time_zone 設定。Active Record 會協助你轉換 UTC 和你選擇的時區（文件沒有解釋）。也就是，如果你所做的只是要透過表單取得用戶文章發佈時間，並使用 Active Record 來保存它，那麼你可以開始了。 處理時間資訊那麼在保存時間資訊前要做些什麼呢？ 解析重要的是永遠不要在沒有指定時區的情況下解析時間資訊。最好的方法是使用 Time.zone.parse（會使用 config.time_zone 指定的時區）而不是使用 Time.parse（會使用電腦的時區）。 使用數字和 Active Record 屬性如果可以，請使用如 2.hours.ago 這樣的方法，它會使用你設定的時區！Active Record 模型的時間屬性也是如此。 123post = Post.firstpost.published_at# =&gt; Fri, 10 Aug 2018 00:00:00 JST +09:00 Active Record 從資料庫取得 UTC 時間，並將其轉換為 config.time_zone 中設定的時區。 Date 與 TimeTime 包含日期和時間資訊，但是 Date 只有日期資訊。即使你認為時間資訊並不重要，但很快地就會意識到它的重要性。安全地使用 Time（或 DateTime，如果你需要支援較遠的時間）。 假設你需要將日期視為時間，至少要確保將它轉換為你設定的時區： 123451.day.from_now# =&gt; Sat, 11 Aug 2018 12:11:11 JST +09:00Date.current.in_time_zone# =&gt; Fri, 10 Aug 2018 00:00:00 JST +09:00 永遠別用： 12Date.today.to_time# =&gt; 2018-08-10 00:00:00 +0800 查詢由於 Rails 知道時間資訊是以 UTC 格式儲存於資料庫中，它會將你給它的任何時間轉換為 UTC。 1Post.where(['posts.published_at &gt; ?', Time.current]) 永遠不要手動建立查詢字串，應使用 Time.current 取得目前時間，以確保時間資訊是正確的。 使用於 APIs提供端建立 Web API 提供其他人使用？請確保始終以 UTC 格式傳送所有時間資料。 12Time.current.utc.iso8601# =&gt; \"2018-08-10T03:11:35Z\" 在此閱讀更多關於為什麼 iso8601 是好的：http://devblog.avdi.org/2009/10/25/iso8601-dates-in-ruby/ 用戶端當你從外部 API 取得時間資訊時，你無法掌控它，只需要確定它傳送給你的格式和時區。因為 Time.zone.parse 可能無法使用在你收到的格式，你可能需要使用： 1Time.strptime(time_string, '%Y-%m-%dT%H:%M:%S%z').in_time_zone 上面的範例假設了 time_string 是 iso8601 格式的字串。當時間字串的格式與格式樣板參數不匹配時，strptime 會拋出一個非常不直覺的錯誤。in_time_zone 預設會使用 Rails 設定的時區。 目前可以使用 Time.zone.strptime 或 Time.zone.parse 來解析時間資訊。 使用用戶時區許多系統需要支援用戶在各種時區輸入和查看時間資訊。要實現此目的，你需要儲存每個用戶的時區（可能只是一個在 rake time:zones:all 中找到的時區字串名稱）。然後，要實際使用該時區最常見的方式是在 ActionController 中建立一個私有方法，並將其作為 around_action 執行。 12345around_action :user_time_zone, if: :current_userdef user_time_zone(&amp;block) Time.use_zone(current_user.time_zone, &amp;block)end 這與 config.time_zone 做的事完全相同，但是是基於每個請求。我仍然建議將預設的 config.time_zone 更改為用戶的預設時區。 測試以上所有內容都是測試應該涵蓋的範圍。問題是你作為開發伺服器的用戶和電腦恰好位於同一時區。在生產環境中這種情況很少發生。 有一個 Zonebie gem 可以幫助你解決這個問題。我還沒有時間試試看，但看起來很有希望。如果你覺得這有點矯枉過正，至少要確保你的測試執行時將 Time.zone 設定為另一時區，而不是開發機所在的時區！ 速查表可以做12345678910111213141516171819202122232.hours.ago# =&gt; Fri, 10 Aug 2018 10:12:02 JST +09:001.day.from_now# =&gt; Sat, 11 Aug 2018 12:12:15 JST +09:00Time.zone.parse('2018-08-08T12:34:56Z')# =&gt; Wed, 08 Aug 2018 21:34:56 JST +09:00Time.current# =&gt; Fri, 10 Aug 2018 12:12:40 JST +09:00Time.current.utc.iso8601# 當提供 API 時（\"2018-08-10T03:12:47Z\"）Time.strptime('2018-08-08T12:34:56Z', '%Y-%m-%dT%H:%M:%S%z').in_time_zone# 如果你不能使用 Time.zone.parse（Wed, 08 Aug 2018 21:34:56 JST +09:00）Date.current# 如果由於某種原因你真的不能有 Time 或 DateTime（Fri, 10 Aug 2018）Date.current.in_time_zone# 如果你有日期並希望充分利用它（Fri, 10 Aug 2018 00:00:00 JST +09:00） 不可以做1234567891011Time.now# 返回系統時間並忽略你設定的時區。（2018-08-10 11:13:30 +0800）Time.parse('2015-08-27T12:09:36Z')# 會假設時間字串是在系統的時區。（2015-08-27 12:09:36 UTC）Time.strptime('2015-08-27T12:09:36Z', '%Y-%m-%dT%H:%M:%S%z')# 與 Time.parse 相同的問題。（2015-08-27 12:09:36 UTC）Date.today# 取決於機器的時區，這可能是昨天或明天，更多相關資訊，請參閱 https://github.com/ramhoj/time-zone-article/issues/1。（Fri, 10 Aug 2018）","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://calvertyang.github.io/tags/Ruby-on-Rails/"}]},{"title":"什麼時候應該在類別內使用 self","slug":"when-should-you-use-self-in-your-classes","date":"2018-07-31T04:47:45.000Z","updated":"2018-08-07T10:14:09.000Z","comments":true,"path":"2018/07/31/when-should-you-use-self-in-your-classes/","link":"","permalink":"https://calvertyang.github.io/2018/07/31/when-should-you-use-self-in-your-classes/","excerpt":"在 Ruby 類別內，你不知道什麼時候需要使用 self，而什麼時候又可以省略，本文將透過範例來做簡單的說明。 範例一1234567class Foo attr_writer :bar def do_something bar = 123 endend 在此範例中 bar = 123 會建立一個名稱為 bar 的區域變數，而不是呼叫由 attr_writer 所產生的 bar= 方法，只要加上 self 就可以修正這個問題。 1234567class Foo attr_writer :bar def do_something self.bar = 123 endend self.bar 便會呼叫我們所預期的 bar= 方法。","text":"在 Ruby 類別內，你不知道什麼時候需要使用 self，而什麼時候又可以省略，本文將透過範例來做簡單的說明。 範例一1234567class Foo attr_writer :bar def do_something bar = 123 endend 在此範例中 bar = 123 會建立一個名稱為 bar 的區域變數，而不是呼叫由 attr_writer 所產生的 bar= 方法，只要加上 self 就可以修正這個問題。 1234567class Foo attr_writer :bar def do_something self.bar = 123 endend self.bar 便會呼叫我們所預期的 bar= 方法。 範例二你也可以使用 self 來呼叫與區域變數名稱相同的屬性閱讀器： 12345678class Foo attr_reader :bar def do_something bar = 123 puts self.bar endend 此處的 bar 與 self.bar 分別為區域變數與實例變數，是兩個不同的東西，因此通常為了避免混淆，最好避免區域變數與存取器名稱相同。 範例三1234567891011class People attr_accessor :name def initialize self.name = 'Calvert' end def greeting \"Hello, #&#123;name&#125;\" endend 在這個範例中，可以看到在 greeting 方法中沒有使用 self 來讀取實例變數 name，因為 attr_accessor 會產生以下兩個方法，因此可以省略 self 來讀取 name： 1234567def name @nameenddef name=(new_name) @name = new_nameend 結論當呼叫設值方法時你必須使用 self.foo = 123 而不是 foo = 123，這樣 Ruby 才會知道你不是要嘗試建立一個新的區域變數。 同樣的，如果你有一個與區域變數相同名稱的方法 greeting，則必須使用 self.greeting 來呼叫該方法，因為使用 greeting 會讀取區域變數而不是呼叫該方法。 參考資料 https://stackoverflow.com/questions/5068304/in-ruby-when-should-you-use-self-in-your-classes https://stackoverflow.com/questions/4699687/when-to-use-self-foo-instead-of-foo-in-ruby-methods https://stackoverflow.com/questions/10805136/when-to-use-self-in-model","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://calvertyang.github.io/tags/Ruby/"}]},{"title":"Rails Engine 入門","slug":"getting-started-with-engines","date":"2018-06-11T06:39:07.000Z","updated":"2018-06-11T06:39:30.000Z","comments":true,"path":"2018/06/11/getting-started-with-engines/","link":"","permalink":"https://calvertyang.github.io/2018/06/11/getting-started-with-engines/","excerpt":"原文：Ruby on Rails Guides — Getting Started with Engines Rails::Engine 允許你包裝特定的 Rails 應用程式或功能子集，並與其他應用程式共享或在更大的封裝應用程式中。每個 Rails::Application 都只是一個引擎，它允許簡單的功能及應用程式共享。 任何 Rails::Engine 也是一個 Rails::Railtie，所以在 railties 可用的相同方法（如 rake_tasks 和 generators）和配置選項也可用於引擎。 在本指南中，你將瞭解引擎以及如何透過乾淨且非常易於使用的介面，為主應用程式提供附加功能。","text":"原文：Ruby on Rails Guides — Getting Started with Engines Rails::Engine 允許你包裝特定的 Rails 應用程式或功能子集，並與其他應用程式共享或在更大的封裝應用程式中。每個 Rails::Application 都只是一個引擎，它允許簡單的功能及應用程式共享。 任何 Rails::Engine 也是一個 Rails::Railtie，所以在 railties 可用的相同方法（如 rake_tasks 和 generators）和配置選項也可用於引擎。 在本指南中，你將瞭解引擎以及如何透過乾淨且非常易於使用的介面，為主應用程式提供附加功能。 閱讀本指南後，你將知道： 是什麼構成了引擎。 如何產生引擎。 如何為引擎建立功能。 如何將引擎掛載到應用程式中。 如何在應用程式中覆寫引擎功能。 透過載入和配置 Hook 避免載入 Rails 框架。 1. 什麼是引擎？引擎可以看成是為主應用程式提供功能的微型應用程式。Rails 應用程式實際上只是一個「增壓」引擎，Rails::Application 類別繼承了許多來自 Rails::Engine 的行為。 因此，引擎和應用程式可以被認為是幾乎相同的東西，只有存在細微的差異，你將在本指南中看到。引擎和應用程式也共享一個公用的結構。 引擎也與外掛程式密切相關。兩者共享一個公用的 lib 目錄結構，並且都是使用 rails plugin new 產生器產生的。不同之處在於，引擎被 Rails 視為一個「完整外掛程式」（如傳遞給產生器指令的 --full 選項所示）。我們實際上會在此處使用 --mountable 選項，其中包含 --full 的所有功能，甚至更多。本指南全文將這些「完整外掛程式」簡稱為「引擎」。引擎可以是外掛程式，外掛程式可以是引擎。 將在本指南中建立的引擎稱為「blorgh」。此引擎將為其主應用程式提供部落格功能，允許建立新文章和評論。在本指南的開頭，你將獨自在引擎內工作，但在後面的章節中，你將看到如何將其掛載到應用程式中。 引擎也可以與主應用程式隔離。意思是應用程式可以擁有路由輔助方法提供的路徑，如 articles_path，並使用一個也提供了名為 articles_path 路徑的引擎，而且兩者不會發生衝突。除此之外，控制器、模型和資料表名稱也具有命名空間。本指南稍後將介紹如何執行此操作。 重要的是在任何時候牢記這一點，應用程式應該總是優先於其引擎。應用程式是對其環境中發生的事情有最終決定權的物件。引擎應該只是加強它，而不是徹底改變它。 查看其他引擎的範例，查看 Devise，一個為其父應用程式提供身份驗證的引擎，或 Thredded，一個提供論壇功能的引擎。還有 Spree 提供電子商務平台，以及 Refinery CMS，一個 CMS 引擎。 最後，如果沒有 James Adam、Piotr Sarnacki、Rails 核心團隊和其他一些人的工作，引擎是不可能實現的。如果你見過他們，別忘了說聲謝謝！ 2. 產生一個引擎要產生引擎，你需要執行外掛程式產生器並根據需求將選項傳遞給它。對於「blorgh」範例，你需要建立一個「可掛載的」引擎，在終端機中執行此指令： 1$ rails plugin new blorgh --mountable 輸入以下內容即可看到外掛程式產生器的完整選項清單： 1$ rails plugin --help --mountable 選項告訴產生器你想建立一個「可掛載的」且命名空間隔離的引擎。此產生器將提供與 --full 選項相同的骨架結構。--full 選項告訴產生器你想建立一個引擎，包含提供以下內容的骨架結構： 一個 app 目錄樹 一個 config/routes.rb 檔案： 12Rails.application.routes.draw doend 一個在 lib/blorgh/engine.rb 的檔案，其功能與標準 Rails 應用程式的 config/application.rb 檔案相同： 1234module Blorgh class Engine &lt; ::Rails::Engine endend --mountable 選項會加入 --full 選項： 靜態資源清單檔案（application.js 和 application.css） 一個具有命名空間的 ApplicationController 一個具有命名空間的 ApplicationHelper 引擎的佈局視圖樣板 命名空間隔離的 config/routes.rb： 12Blorgh::Engine.routes.draw doend 命名空間隔離的 lib/blorgh/engine.rb： 12345module Blorgh class Engine &lt; ::Rails::Engine isolate_namespace Blorgh endend 此外，--mountable 選項透過將以下內容加到虛擬應用程式的路由檔案 test/dummy/config/routes.rb，告訴產生器將引擎掛載到位於 test/dummy 的虛擬測試應用程式中： 1mount Blorgh::Engine =&gt; \"/blorgh\" 2.1 引擎內部2.1.1 關鍵檔案在這個全新引擎的根目錄有個 blorgh.gemspec 檔案。當你稍後將引擎掛載到應用程式中時，你將在 Rails 應用程式的 Gemfile 中使用此行進行操作： 1gem 'blorgh', path: 'engines/blorgh' 不要忘記像往常一樣執行 bundle install。透過在 Gemfile 中指定它作為一個 gem，Bundler 將載入它，解析此 blorgh.gemspec 檔案並載入 lib 目錄中的一個名為 lib/blorgh.rb 的檔案。這個檔案載入了 blorgh/engine.rb 檔案（位於 lib/blorgh/engine.rb）並定義了一個名為 Blorgh 的基本模組。 1234require \"blorgh/engine\"module Blorghend 有些引擎選擇使用這個檔案為其引擎提供全域配置選項。這是一個比較好的想法，所以如果你想提供配置選項，那麼定義引擎 module 的檔案就是完美的選擇。把方法放到模組裡面就可以了。 lib/blorgh/engine.rb 是引擎的基底類別： 12345module Blorgh class Engine &lt; ::Rails::Engine isolate_namespace Blorgh endend 透過繼承 Rails::Engine 類別，這個 gem 會通知 Rails 在指定路徑上有一個引擎，並且將引擎正確地掛載到應用程式，執行諸如將引擎的 app 目錄加到模型、Mailer、控制器和視圖的載入路徑。 這裡的 isolate_namespace 方法值得特別注意。這個呼叫負責將控制器、模型、路由和其他東西隔離到自己的命名空間中，使其遠離應用程式內部的類似元件。沒有這個，引擎的元件就有可能「洩漏」到應用程式，造成不必要的中斷，或者重要的引擎元件可能會被應用程式中類似名稱的東西覆蓋。這種衝突的其中一個例子就是輔助方法。在不呼叫 isolate_namespace 的情況下，引擎的輔助方法將被包含在應用程式的控制器中。 高度推薦在 Engine 類別定義中保留 isolate_namespace。如果沒有它，引擎中產生的類別可能 會與應用程式發生衝突。 此命名空間的隔離意思是透過呼叫 bin/rails g model 產生的模型，如 bin/rails g model article，名稱不是 Article，而是具有命名空間的名稱 Blorgh::Article。另外，模型的資料表也具有命名空間，成為 blorgh_articles，而不僅僅是 articles。與模型命名空間類似，一個名為 ArticlesController 的控制器變成了 Blorgh::ArticlesController，並且該控制器的視圖不會在 app/views/articles，而是 app/views/blorgh/articles。Mailer 也具有命名空間。 最後，路由也被隔離在引擎內。這是命名空間中最重要的部分之一，稍後將在本指南的路由部分中進行討論。 2.1.2 app 目錄在 app 目錄中有標準的 assets、controllers、helpers、mailers、models 和 views 目錄，你應該已從應用程式對這些目錄瞭若指掌。helpers、mailers 和 models 目錄是空的，因此在本節中沒有描述它們。當我們編寫引擎時，我們將在未來的章節中更深入地研究模型。 在 app/assets 目錄中，有 images、javascripts 和 stylesheets 目錄，你應該早已熟悉這些目錄，因為它們與應用程式類似。然而，這裡的一個不同之處在於，每個目錄都包含一個帶有引擎名稱的子目錄。因為這個引擎具有命名空間，它的靜態資源也應該如此。 在 app/controllers 目錄中有一個 blorgh 目錄，其中包含了一個名為 application_controller.rb 的檔案。該檔案將為引擎的控制器提供任何公用功能。blorgh 目錄是存放引擎的其它控制器的地方。透過將它們放在這個命名空間的目錄中，可以防止它們與其它引擎甚至是應用程式中的同名控制器發生衝突。 引擎內的 ApplicationController 類別命名就像一個 Rails 應用程式，以便更容易將應用程式轉換為引擎。 因為 Ruby 不斷尋找的方式，你可能會遇到一種狀況，你的控制器繼承自主應用程式控制器，而不是你的引擎應用程式控制器。Ruby 能夠解析 ApplicationController 常數，因此不會觸發自動載入機制。有關更多詳細資訊，請查看自動載入和重新載入常數指南中的常數什麼時候不被忽略章節。預防這種狀況發生最好的方法是使用 require_dependency 來確保引擎的應用程式控制器已被載入。例如： 12345678# app/controllers/blorgh/articles_controller.rb:require_dependency \"blorgh/application_controller\"module Blorgh class ArticlesController &lt; ApplicationController ... endend 不要使用 require，因為它會中斷開發環境中類別的自動重新載入，使用 require_dependency 確保類別以正確的方式載入和卸除。 最後，app/views目錄中有一個 layouts 資料夾，其中包含了一個檔案在 blorgh/application.html.erb。該檔案允許你指定引擎的佈局。如果此引擎要作為獨立引擎使用，那麼你可以在此檔案中加入任何對佈局的客製化，而不是應用程式的 app/views/layouts/application.html.erb 檔案。 如果不希望對引擎的使用者強制佈局，那麼可以刪除此檔案並在引擎的控制器中引用不同的佈局。 2.1.3 bin 目錄這個目錄包含一個 bin/rails 檔案，它讓你能夠像在應用程式中一樣使用 rails 子指令和產生器。也就是說，你可以很容易地透過執行這樣的指令來產生新的控制器和模型： 1$ bin/rails g model 請記住，在 Engine 類別中具有 isolate_namespace 的引擎內部使用這些指令產生的任何東西，都將具有命名空間。 2.1.4 test 目錄test 目錄是用來存放引擎測試的地方。為了測試引擎，在 test/dummy 中嵌入了一個精簡版的 Rails 應用程式。這個應用程式會將引擎掛載到 test/dummy/config/routes.rb 檔案： 123Rails.application.routes.draw do mount Blorgh::Engine =&gt; \"/blorgh\"end 該行將引擎掛載到 /blorgh 路徑上，這將使應用程式僅能透過該路徑存取它。 在測試目錄裡面有 test/integration 目錄，引擎的整合測試應該放在這裡。也可以在 test 目錄中建立其它目錄。例如，你可能希望為模型測試建立一個 test/models 目錄。 3. 提供引擎功能本指南涵蓋的引擎提供了送交文章和評論的功能，遵循與入門指南類似的思路，並伴隨一些新的觀點。 3.1 產生 Article 資源產生部落格引擎的第一件事是 Article 模型和相關的控制器。要快速建立這個，你可以使用 Rails 鷹架產生器。 1$ bin/rails generate scaffold article title:string text:text 該指令會輸出以下資訊： 12345678910111213141516171819202122232425262728293031invoke active_recordcreate db/migrate/[timestamp]_create_blorgh_articles.rbcreate app/models/blorgh/article.rbinvoke test_unitcreate test/models/blorgh/article_test.rbcreate test/fixtures/blorgh/articles.ymlinvoke resource_route route resources :articlesinvoke scaffold_controllercreate app/controllers/blorgh/articles_controller.rbinvoke erbcreate app/views/blorgh/articlescreate app/views/blorgh/articles/index.html.erbcreate app/views/blorgh/articles/edit.html.erbcreate app/views/blorgh/articles/show.html.erbcreate app/views/blorgh/articles/new.html.erbcreate app/views/blorgh/articles/_form.html.erbinvoke test_unitcreate test/controllers/blorgh/articles_controller_test.rbinvoke helpercreate app/helpers/blorgh/articles_helper.rbinvoke test_unitcreate test/application_system_test_case.rbcreate test/system/articles_test.rbinvoke assetsinvoke jscreate app/assets/javascripts/blorgh/articles.jsinvoke csscreate app/assets/stylesheets/blorgh/articles.cssinvoke csscreate app/assets/stylesheets/scaffold.css 鷹架產生器所做的第一件事是呼叫 active_record 產生器，它為資源產生遷移和模型。但是請注意，遷移被命名為 create_blorgh_articles，而不是常見的 create_articles。這是由於 Blorgh::Engine 類別的定義中呼叫 isolate_namespace 方法造成的。這裡的模型也具有命名空間，由於 Engine 類別中呼叫 isolate_namespace，所以放在 app/models/blorgh/article.rb 而不是 app/models/article.rb。 接下來，為此模型呼叫 test_unit 產生器，在 test/models/blorgh/article_test.rb（而不是 test/models/article_test.rb）產生一個模型測試，並在 test/fixtures/blorgh/articles.yml（而不是 test/fixtures/articles.yml）產生測試資料。 然後，插入一行資源路由到引擎的 config/routes.rb 檔案。這一行只是 resources :articles，將引擎的 config/routes.rb 檔案變成這樣： 123Blorgh::Engine.routes.draw do resources :articlesend 這裡請注意，路由是被定義在 Blorgh::Engine 物件上，而不是 YourApp::Application 類別。這是為了使引擎路由被限制在引擎本身，並且如測試目錄部分所示可以掛載在特定點上。它還會使引擎的路由與應用程式內的路由隔離。本指南的路由部分有詳細的說明。 接下來，scaffold_controller 產生器被呼叫，產生一個名為 Blorgh::ArticlesController（在 app/controllers/blorgh/articles_controller.rb）的控制器及其相關視圖在 app/views/blorgh/articles。此產生器還為控制器產生測試（test/controllers/blorgh/articles_controller_test.rb）和輔助方法（app/helpers/blorgh/articles_helper.rb）。 這個產生器建立的所有東西都具有命名空間。控制器的類別被定義在 Blorgh 模組： 12345module Blorgh class ArticlesController &lt; ApplicationController ... endend ArticlesController 類別繼承自 Blorgh::ApplicationController，而不是應用程式的 ApplicationController。 app/helpers/blorgh/articles_helper.rb 中的輔助方法也具有命名空間： 12345module Blorgh module ArticlesHelper ... endend 這有助於防止與任何其它可能具有文章資源的引擎或應用程式發生衝突。 最後，產生了兩個靜態資源檔案：app/assets/javascripts/blorgh/articles.js 和 app/assets/stylesheets/blorgh/articles.css。稍後你會看到如何使用這些東西。 你可以透過在引擎的根目錄執行 bin/rails db:migrate 來執行由鷹架產生器產生的遷移，然後在 test/dummy 中執行 rails server 來查看引擎的內容。當你開啟 http://localhost:3000/blorgh/articles 時，將看到已產生的預設鷹架。點看看吧！你剛剛產生了你的第一個引擎的第一個功能。 如果你更喜歡使用主控台，也可以像 Rails 應用程式一樣使用 rails console。記住：Article 模型是具有命名空間的，因此要引用它，你必須稱呼它為 Blorgh::Article。 12&gt;&gt; Blorgh::Article.find(1)=&gt; #&lt;Blorgh::Article id: 1 ...&gt; 最後一件事是這個引擎的 articles 資源應該是引擎的根。每當有人進入掛載引擎的根路徑時，應該顯示文章列表。如果將此行插入引擎內的 config/routes.rb 檔案中，便可以實現這一點： 1root to: \"articles#index\" 現在人們只需要到引擎的根目錄來查看所有文章，而不是訪問 /articles。意思是現在你只需要去 http://localhost:3000/blorgh，而不是 http://localhost:3000/blorgh/articles。 3.2 產生 Comments 資源現在，引擎可以建立新的文章，那麼加上評論功能也是有意義的。為此，你需要建立評論模型、評論控制器，然後修改文章鷹架以顯示評論並允許人們建立新評論。 從應用程式根目錄執行模型產生器。告訴它產生一個 Comment 模型，資料表有兩欄：integer 型別的 article_id 和 text 型別的 text 欄位。 1$ bin/rails generate model Comment article_id:integer text:text 這將輸出以下內容： 123456invoke active_recordcreate db/migrate/[timestamp]_create_blorgh_comments.rbcreate app/models/blorgh/comment.rbinvoke test_unitcreate test/models/blorgh/comment_test.rbcreate test/fixtures/blorgh/comments.yml 該產生器呼叫將產生它所需的必要模型檔案，將檔案放在命名空間 blorgh 目錄下，並建立一個名為 Blorgh::Comment 的模型類別。現在執行遷移來建立我們的 blorgh_comments 資料表： 1$ bin/rails db:migrate 要在文章上顯示評論，編輯 app/views/blorgh/articles/show.html.erb 並在「編輯」連結前加上此行： 12&lt;h3&gt;Comments&lt;/h3&gt;&lt;%= render @article.comments %&gt; 這一行需要在 Blorgh::Article 模型中定義一個 has_many 關聯的評論，不過現在還沒有。要定義它，開啟 app/models/blorgh/article.rb 並將這一行加到模型中： 1has_many :comments 將模型變成： 12345module Blorgh class Article &lt; ApplicationRecord has_many :comments endend 因為 has_many 是在 Blorgh 模組的一個類別中定義的，Rails 會知道你想為這些物件使用 Blorgh::Comment 模型，所以不需要在這裡指定使用 :class_name 選項。 接下來，需要有一個表單，以便可以在文章上建立評論。要加上它，在 app/views/blorgh/articles/show.html.erb 中呼叫呈現 `@article.comments` 的下方加上這一行： 1&lt;%= render \"blorgh/comments/form\" %&gt; 接下來，這一行將呈現的部分視圖需要存在。建立一個新目錄在 app/views/blorgh/comments，並且建立一個名為 _form.html.erb 的新檔案，該檔案包含這些內容以便建立所需的部分視圖： 12345678&lt;h3&gt;New comment&lt;/h3&gt;&lt;%= form_with(model: [@article, @article.comments.build], local: true) do |form| %&gt; &lt;p&gt; &lt;%= form.label :text %&gt;&lt;br&gt; &lt;%= form.text_area :text %&gt; &lt;/p&gt; &lt;%= form.submit %&gt;&lt;% end %&gt; 送交此表單時，它將嘗試對引擎內的 /articles/:article_id/comments 路由執行 POST 請求。此路由目前不存在，但是可以透過將 config/routes.rb 中的 resources :articles 更改為以下幾行來建立： 123resources :articles do resources :commentsend 這會為評論建立一個表單所需要的巢狀路由。 路由現在已經存在了，但是此路由所去的控制器還不存在。要建立它，從應用程式根目錄執行這個指令： 1$ bin/rails g controller comments 該指令會輸出以下資訊： 123456789101112create app/controllers/blorgh/comments_controller.rbinvoke erb exist app/views/blorgh/commentsinvoke test_unitcreate test/controllers/blorgh/comments_controller_test.rbinvoke helpercreate app/helpers/blorgh/comments_helper.rbinvoke assetsinvoke jscreate app/assets/javascripts/blorgh/comments.jsinvoke csscreate app/assets/stylesheets/blorgh/comments.css 該表單會向 /articles/:article_id/comments 發出 POST 請求，對應到 Blorgh::CommentsController 中的 create 動作。這個動作需要被建立，可以透過在 app/controllers/blorgh/comments_controller.rb 的類別定義中放入以下幾行來完成： 1234567891011def create @article = Article.find(params[:article_id]) @comment = @article.comments.create(comment_params) flash[:notice] = \"Comment has been created!\" redirect_to articles_pathendprivate def comment_params params.require(:comment).permit(:text) end 這是讓新評論表單運作所需的最後一步。然而，顯示評論還不太正確。如果你現在要建立評論，則會看到此錯誤： 1234Missing partial blorgh/comments/_comment with &#123;:handlers=&gt;[:erb, :builder],:formats=&gt;[:html], :locale=&gt;[:en, :en]&#125;. Searched in: *\"/Users/ryan/Sites/side_projects/blorgh/test/dummy/app/views\" *\"/Users/ryan/Sites/side_projects/blorgh/app/views\" 引擎無法找到呈現評論所需的部分視圖。Rails 會先尋找應用程式的（test/dummy）app/views目錄，然後在引擎的 app/views 目錄中尋找。當找不到它時，便會拋出這個錯誤。引擎知道要尋找 blorgh/comments/_comment，因為它接收的模型物件是來自 Blorgh::Comment 類別。 目前，這個部分視圖僅負責呈現評論文字。在 app/views/blorgh/comments/_comment.html.erb 建立新一個檔案，並將此行放入其中： 1&lt;%= comment_counter + 1 %&gt;. &lt;%= comment.text %&gt; comment_counter 區域變數是由呼叫 &lt;%= render @article.comments %&gt; 給我們的，它會自動定義並在迭代每個評論時遞增計數器。在這個例子中，它用於在每個評論建立時顯示一個小數字。 完成了部落格引擎的評論功能。現在是時候在應用程式中使用它了。 4. 安裝到應用程式在應用程式中使用引擎非常簡單。本節會介紹如何將引擎掛載到應用程式和所需的初始設定，以及將引擎連結到由應用程式提供的 User 類別，以便為引擎中的文章和評論提供所有權。 4.1 掛載引擎首先，需要在應用程式的 Gemfile 中指定引擎。如果沒有應用程式可以方便地進行測試，可以像這樣在引擎目錄外使用 rails new 指令產生一個： 1$ rails new unicorn 通常，可以像一般的 gem 一樣，透過在 Gemfile 內將引擎指定在內來完成。 1gem 'devise' 但是，因為你正在本機上開發 blorgh 引擎，你需要在 Gemfile 指定 :path 選項： 1gem 'blorgh', path: 'engines/blorgh' 然後執行 bundle 來安裝 gem。 如先前所述，透過將 gem 放在 Gemfile 中，它將會在 Rails 載入時被載入。它會先從引擎載入 lib/blorgh.rb，然後是 lib/blorgh/engine.rb，它是定義引擎主要功能的檔案。 要讓引擎的功能可以從應用程式存取，需要將它掛載到應用程式的 config/routes.rb 檔案： 1mount Blorgh::Engine, at: \"/blog\" 這一行會將引擎掛載到應用程式中的 /blog。當應用程式以 rails server 執行時，可以在 http://localhost:3000/blog 上訪問它。 其他引擎，如 Devise，透過讓你在路由中指定自訂輔助方法（例如 devise_for）來處理這一點。這些輔助方法完成相同的事，將引擎的部分功能掛載到預先定義可客製化的路徑上。 4.2 安裝引擎引擎包含需要在應用程式資料庫中建立的 blorgh_articles 和 blorgh_comments 資料表的遷移，以便引擎的模型可以正確查詢它們。要將這些遷移複製到應用程式中，請從 Rails 引擎的 test/dummy 目錄執行以下指令： 1$ bin/rails blorgh:install:migrations 如果你有多個需要複製遷移的引擎，請改用 railties:install:migrations： 1$ bin/rails railties:install:migrations 第一次執行這個指令時，將複製引擎中的所有遷移。下次執行時，它只會複製尚未被複製的遷移。第一次執行指令會輸出以下資訊： 12Copied migration [timestamp_1]_create_blorgh_articles.blorgh.rb from blorghCopied migration [timestamp_2]_create_blorgh_comments.blorgh.rb from blorgh 第一個時間戳記（[timestamp_1]）將是目前時間，第二個時間戳記（[timestamp_2]）將是目前時間加上一秒。之所以這樣做是為了在應用程式中任何現有的遷移之後執行引擎的遷移。 要在應用程式中執行這些遷移，只需執行：bin/rails db:migrate。當透過 http://localhost:3000/blog 訪問引擎時，文章會是空的。這是因為在應用程式建立的資料表與引擎內建立的資料表不同。繼續，玩玩新掛載的引擎吧。你會發現它和只有一個引擎時是相同的。 如果你只想從一個引擎執行遷移，可以透過指定 SCOPE 來完成： 1bin/rails db:migrate SCOPE=blorgh 如果你想在刪除引擎之前還原引擎的遷移，這可能很有用。要還原 blorgh 引擎的所有遷移，你可以執行以下指令： 1bin/rails db:migrate SCOPE=blorgh VERSION=0 4.3 使用應用程式提供的類別4.3.1 使用應用程式提供的模型引擎建立後，可能需要使用應用程式中的特定類別來提供引擎和應用程式之間的連結。以 blorgh 引擎的情況來說，讓文章和評論有作者會很有意義。 一個典型的應用程式可能有一個 User 類別，用於表示文章或評論的作者。但可能會出現這樣的情況，應用程式以不同名稱命名此類別，如 Person。因此，引擎不應該明確的為 User 類別寫死關聯。 為了在這種情況下保持簡單，應用程式將有一個名為 User 的類別，來表示應用程式的使用者（我們將進一步進行配置）。它可以在應用程式中使用這個指令產生： 1$ bin/rails g model user name:string 需要在這裡執行 bin/rails db:migrate 指令，以確保我們的應用程式有 users 資料表供將來使用。 同樣地，為了簡單起見，文章表單會有一個名為 author_name 的新文字欄位，使用者可以選擇放置他們的名字。引擎將使用這個名稱建立一個新的 User 物件或者尋找一個擁有該名稱的物件。引擎會將文章與找到或建立的 User 物件建立關聯。 首先，author_name 文字欄位需要被加到引擎內的 app/views/blorgh/articles/_form.html.erb 部分視圖。可以在 title 欄位上方加入以下程式碼： 1234&lt;div class=\"field\"&gt; &lt;%= form.label :author_name %&gt;&lt;br&gt; &lt;%= form.text_field :author_name %&gt;&lt;/div&gt; 接下來，我們需要更新 Blorgh::ArticleController#article_params 方法來允許新的表單參數： 123def article_params params.require(:article).permit(:title, :text, :author_name)end Blorgh::Article 模型應該有一些程式碼將 author_name 欄位轉換為一個實際的 User 物件，並在儲存文章前將其關聯為該文章的 author。它還需要為此欄位設定一個 attr_accessor，以便為其定義設值（setter）方法和取值（getter）方法。 為此，你需要在 app/models/blorgh/article.rb 為 author_name 加上 attr_accessor、作者的關聯和 before_validation 呼叫。author 關聯會暫時寫死到 User 類別。 123456789attr_accessor :author_namebelongs_to :author, class_name: \"User\"before_validation :set_authorprivate def set_author self.author = User.find_or_create_by(name: author_name) end 透過用 User 類別表示 author 關聯的物件，在引擎和應用程式之間建立了一個連結。需要有一種方法將 blorgh_articles 資料表中的記錄與 users 資料表中的記錄關聯起來。因為該關聯名為 author，所以應該在 blorgh_articles 資料表中加上 author_id 欄位。 要產生這個新欄位，請在引擎中執行這個指令： 1$ bin/rails g migration add_author_id_to_blorgh_articles author_id:integer 由於遷移的名稱和後面的欄位說明，Rails 會自動知道你想要將欄位加到特定資料表，並將其寫入遷移中。因此不用手動編寫遷移。 這個遷移需要在應用程式上執行。為此，首先必須使用這個指令複製它： 1$ bin/rails blorgh:install:migrations 請注意，這裡只複製了一個遷移。這是因為前兩次遷移已經在第一次執行這個指令時被複製了。 123NOTE Migration [timestamp]_create_blorgh_articles.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.NOTE Migration [timestamp]_create_blorgh_comments.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.Copied migration [timestamp]_add_author_id_to_blorgh_articles.blorgh.rb from blorgh 使用以下指令執行遷移： 1$ bin/rails db:migrate 現在，一切都已經到位，我們完成了作者（用 users 資料表中的記錄表示）與文章（用引擎的 blorgh_articles 資料表中的記錄表示）的關聯。 最後，作者的名稱應該會顯示在文章頁面。在 app/views/blorgh/articles/show.html.erb 內的「標題」輸出上方加上以下程式碼： 1234&lt;p&gt; &lt;b&gt;Author:&lt;/b&gt; &lt;%= @article.author.name %&gt;&lt;/p&gt; 4.3.2 使用應用程式提供的控制器預設情況下，由於 Rails 控制器通常會透過繼承 ApplicationController 共享程式碼，例如身份驗證和存取 session 變數。然而，Rails 引擎的作用域與主應用程式是隔離的，因此每個引擎的 ApplicationController 都具有獨立的命名空間。獨立的命名空間可避免程式碼衝突，但是引擎的控制器常常需要存取主應用程式的 ApplicationController 中的方法。提供存取的簡單方法是讓引擎具有命名空間的 ApplicationController 繼承自主應用程式的 ApplicationController。對於我們的 Blorgh 引擎，可以透過以下改變 app/controllers/blorgh/application_controller.rb 來完成： 1234module Blorgh class ApplicationController &lt; ::ApplicationController endend 所以，在做出這個改變之後，他們可以訪問主應用程序的ApplicationController，就好像它們是主應用程序的一部分。預設情況下，引擎的控制器繼承自 Blorgh::ApplicationController。因此透過上述修改，它們將能夠存取主應用程式的 ApplicationController，就好像它們是主應用程式的一部分。 此修改的前提是，引擎需要執行在具有 ApplicationController 的 Rails 應用程式。 4.4 設定引擎本節介紹如何讓 User 類別成為可配置的，然後介紹引擎的基本配置注意事項。 4.4.1 在應用程式中設定配置下一步是讓引擎可以客製化在應用程式中所使用的 User 類別。如先前所述，該類別並非總是 User。為了使這個配置可客製化，引擎將有一個名為 author_class 的配置，它將用於指定哪個類別代表應用程式中的使用者。 要定義此配置，你應該在引擎的 Blorgh 模組中使用 mattr_accessor。將此行加到引擎內的 lib/blorgh.rb 中： 1mattr_accessor :author_class 這個方法的工作原理與 attr_accessor 和 cattr_accessor 類似，會根據指定名稱為模組提供設值（setter）方法和取值（getter）方法。使用時直接呼叫 Blorgh.author_class 即可。 下一步是將 Blorgh::Article 模型切換到這個新設定。修改這個模型（app/models/blorgh/article.rb）的 belongs_to 關聯： 1belongs_to :author, class_name: Blorgh.author_class Blorgh::Article 模型中的 set_author 方法也應該使用此類別： 1self.author = Blorgh.author_class.constantize.find_or_create_by(name: author_name) 為了避免每次都要對 author_class 結果呼叫 constantize，我們可以在 lib/blorgh.rb 檔案中覆寫 Blorgh 模組的 author_class 取值（getter）方法，在回傳結果之前呼叫 constantize： 123def self.author_class @@author_class.constantizeend 此時，上述的 set_author 程式碼將變為： 1self.author = Blorgh.author_class.find_or_create_by(name: author_name) 修改後的結果更為簡短，行為更加明確。author_class 方法應該總是回傳 Class 物件。 因為修改後的 author_class 方法回傳 Class 而不是 String，我們還需要修改 Blorgh::Article 模型中的 belongs_to 定義： 1belongs_to :author, class_name: Blorgh.author_class.to_s 要在應用程式設定此配置，應該使用初始化程式。透過初始化程式，配置會在應用程式啟動且呼叫引擎的模型前完成設定，這可能取決於現有的配置設定。 在安裝 blorgh 引擎的應用程式中，建立一個新的初始化程式在 config/initializers/blorgh.rb，並放入以下內容： 1Blorgh.author_class = \"User\" 重要的是這裡使用字串版本的類別，而不是直接使用類別。如果我們直接使用類別，Rails 會嘗試載入該類別並引用相關資料表。如果資料表不存在，可能會導致問題產生。因此，應該使用字串，然後在引擎中透過 constantize 將其轉換為類別。 接下來嘗試新增一篇文章。你會發現過程和之前相同，不過這次引擎使用的是 config/initializers/blorgh.rb 內配置設定的類別。 現在，不用在意使用者類別到底是什麼，只需要確認使用者類別是否實作所需的 API。引擎只要求使用者類別實作了 find_or_create_by 方法，此方法回傳了使用者類別的物件，以便在建立文章時與其相關聯。當然，這個物件應該有某種可以被引用的識別碼。 4.4.2 引擎基本配置有時候你可能會想在引擎中使用初始化程式、國際化或其它配置選項。這些事情是可以的，因為 Rails 引擎和 Rails 應用程式共享很多相同的功能。事實上，Rails 應用程式的功能實際上是由引擎提供的功能的超集合！ 如果你希望使用初始化程式（載入引擎前應該執行的程式碼），儲存的位置是在它的 config/initializers 資料夾。此目錄的功能在配置指南的初始化程式章節有說明，並且與應用程式中的 config/initializers 目錄完全相同。如果你想使用標準的初始化程式，也是一樣的。 對於語系設定，只需將語系檔案放在 config/locales 目錄，如同在應用程式中一樣。 5. 測試引擎當引擎建立後，會在 test/dummy 中建立一個小型的虛擬應用程式。這個應用程式被用作引擎的裝載點，使引擎測試非常簡單。你可以透過在目錄中產生控制器、模型或視圖來擴充此應用程式，然後用它們來測試你的引擎。 test 目錄和典型的 Rails 測試環境一樣，支援單元測試、功能測試和整合測試。 5.1 功能測試在編寫功能測試時，一件值得考慮的事是測試會在 test/dummy 應用程式上執行，而不是引擎。這是由測試環境的設定決定的，引擎需要裝載在應用程式才能測試其主要功能，尤其是控制器。也就是說，如果你在控制器的功能測試中像這樣為控制器編寫一個典型的 GET 請求： 12345678910module Blorgh class FooControllerTest &lt; ActionDispatch::IntegrationTest include Engine.routes.url_helpers def test_index get foos_url ... end endend 它的功能還無法正確運作。這是因為應用程式不知道如何將這些請求傳遞到引擎，除非你明確的告訴它如何處理。為此，你必須在程式中將 @routes 實例變數設定為引擎的路由： 1234567891011121314module Blorgh class FooControllerTest &lt; ActionDispatch::IntegrationTest include Engine.routes.url_helpers setup do @routes = Engine.routes end def test_index get foos_url ... end endend 這告訴應用程式你想對此控制器的 index 動作執行一個 GET 請求，但你想使用引擎的路由，而不是應用程式的路由。 這也確保了引擎的 URL 輔助方法能夠在測試中正常運作。 6. 改進引擎功能本節介紹如何在 Rails 主應用程式中加入或覆寫引擎的 MVC 功能。 6.1 覆寫模型和控制器在 Rails 主應用程式中，可以透過打開類別來擴充引擎模型和控制器類別（因為模型和控制器類別只是繼承 Rails 特定功能的 Ruby 類別）。透過打開類別，可以根據主應用程式的需求重新定義引擎的類別。通常會透過裝飾器模式來實作。 對於簡單的類別修改，可以使用 Class#class_eval。對於複雜的類別修改，可以考慮使用 ActiveSupport::Concern。 6.1.1 使用裝飾器和載入代碼時的注意事項因為這些裝飾器沒有被 Rails 應用程式本身引用，Rails 的自動載入系統不會載入你的裝飾器。也就是說，你需要自己載入它們。 以下是執行此操作的一些範例程式碼： 123456789101112# lib/blorgh/engine.rbmodule Blorgh class Engine &lt; ::Rails::Engine isolate_namespace Blorgh config.to_prepare do Dir.glob(Rails.root + \"app/decorators/**/*_decorator*.rb\").each do |c| require_dependency(c) end end endend 這不僅適用於裝飾器，也適用於任何加入到引擎中但未被主應用程式引用的東西。 6.1.2 使用 Class#class_eval 實作裝飾器模式加入 Article#time_since_created： 1234567# MyApp/app/decorators/models/blorgh/article_decorator.rbBlorgh::Article.class_eval do def time_since_created Time.current - created_at endend 12345# Blorgh/app/models/article.rbclass Article &lt; ApplicationRecord has_many :commentsend 覆寫 Article#summary： 1234567# MyApp/app/decorators/models/blorgh/article_decorator.rbBlorgh::Article.class_eval do def summary \"#&#123;title&#125; - #&#123;truncate(text)&#125;\" endend 12345678# Blorgh/app/models/article.rbclass Article &lt; ApplicationRecord has_many :comments def summary \"#&#123;title&#125;\" endend 6.1.3 使用 ActiveSupport::Concern 實作裝飾器模式使您可以顯著模塊化您的代碼。使用 Class#class_eval 非常適合簡單的調整，但是對於更複雜的類別修改，你可能需要考慮使用 ActiveSupport::Concern。ActiveSupport::Concern 能管理互相關聯相依模組和類別執行時的載入順序，讓你可以放心模組化你的程式碼。 加入 Article#time_since_created 並覆寫 Article#summary： 12345678910111213# MyApp/app/models/blorgh/article.rbclass Blorgh::Article &lt; ApplicationRecord include Blorgh::Concerns::Models::Article def time_since_created Time.current - created_at end def summary \"#&#123;title&#125; - #&#123;truncate(text)&#125;\" endend 12345# Blorgh/app/models/article.rbclass Article &lt; ApplicationRecord include Blorgh::Concerns::Models::Articleend 1234567891011121314151617181920212223242526272829# Blorgh/lib/concerns/models/article.rbmodule Blorgh::Concerns::Models::Article extend ActiveSupport::Concern # 'included do' 內的程式碼可以在被載入的地方（article.rb）執行，而不是在 # 模組內（blorgh/concerns/models/article）被執行。 included do attr_accessor :author_name belongs_to :author, class_name: \"User\" before_validation :set_author private def set_author self.author = User.find_or_create_by(name: author_name) end end def summary \"#&#123;title&#125;\" end module ClassMethods def some_class_method 'some class method string' end endend 6.2 覆寫視圖當 Rails 在尋找要呈現的視圖時，它首先會在應用程式的 app/views 目錄中尋找。如果找不到，接著就會在所有引擎的 app/views目錄中尋找。 當應用程式要呈現 Blorgh::ArticlesController 的 index 動作的視圖時，它會先在應用程式中尋找 app/views/blorgh/articles/index.html.erb 檔案。如果找不到，接著會在引擎中尋找。 你可以透過在應用程式中建立 app/views/blorgh/articles/index.html.erb 檔案來覆寫這個視圖。然後可以完全改變這個視圖輸出的內容。 現在試著建立 app/views/blorgh/articles/index.html.erb 檔案並放入以下內容： 12345678&lt;h1&gt;Articles&lt;/h1&gt;&lt;%= link_to \"New Article\", new_article_path %&gt;&lt;% @articles.each do |article| %&gt; &lt;h2&gt;&lt;%= article.title %&gt;&lt;/h2&gt; &lt;small&gt;By &lt;%= article.author %&gt;&lt;/small&gt; &lt;%= simple_format(article.text) %&gt; &lt;hr&gt;&lt;% end %&gt; 6.3 路由預設情況下，引擎與應用程式的路由是隔離的。這是透過在 Engine 類別中呼叫 isolate_namespace 完成的。也就是說，應用程式及其引擎可以具有相同名稱的路由，並且它們不會發生衝突。 在 config/routes.rb 檔案中，可以在 Engine 類別上定義引擎的路由： 123Blorgh::Engine.routes.draw do resources :articlesend 因為路由是隔離的，如果你想從應用程式中連結到引擎的某個位置時，必須使用引擎的路由代理方法。呼叫一般路由方法如 articles_path 可能會產生非預期的連結，因為應用程式和引擎可能都定義了這個輔助方法。 例如，就以下範例來說，如果是從應用程式呈現樣板，就會指向應用程式的 articles_path，如果是從引擎呈現樣板，則會指向引擎的 articles_path： 1&lt;%= link_to \"Blog articles\", articles_path %&gt; 要確保使用的是引擎的 articles_path 路由輔助方法，我們必須透過與引擎相同名稱的路由代理方法來呼叫這個輔助方法。 1&lt;%= link_to \"Blog articles\", blorgh.articles_path %&gt; 如果你想用類似的方式在引擎內引用應用程式，可以使用 main_app 輔助方法： 1&lt;%= link_to \"Home\", main_app.root_path %&gt; 如果你在引擎中使用上述程式碼，它會總是指向應用程式的根目錄。若不使用 main_app 「路由代理」方法，它可能會指向引擎或應用程式的根目錄，取決於從何處呼叫它。 如果嘗試從引擎中呈現的樣板使用應用程式的路由輔助方法，可能會導致呼叫未定義的方法。如果遇到此類問題，請確保你沒有嘗試在引擎內沒有 main_app 前綴的情況下呼叫應用程式的路由輔助方法。 6.4 靜態資源引擎內的資源與完整應用程式的工作方式相同。由於引擎類別繼承自 Rails::Engine，應用程式會知道在引擎的 app/assets 和 lib/assets 目錄中尋找靜態資源。 和引擎的所有其它元件一樣，靜態資源應該具有命名空間。也就是說，如果你有一個名為 style.css 的靜態資源，它應該被放在 app/assets/stylesheets/[engine name]/style.css，而不是 app/assets/stylesheets/style.css。如果靜態資源不具有命名空間，主應用程式可能會有一個相同名稱的靜態資源，在這種情況下，應用程式的靜態資源會具有較高的優先權，引擎的靜態資源將被忽略。 想像一下，你有一個靜態資源位於 app/assets/stylesheets/blorgh/style.css，要在應用程式中載入此檔案，只需使用 stylesheet_link_tag 並引用靜態資源即可： 1&lt;%= stylesheet_link_tag \"blorgh/style.css\" %&gt; 你也可以使用 Asset Pipeline 的 require 語法來載入引擎中的靜態資源： 123/* *= require blorgh/style*/ 記住，若要使用 Sass 或 CoffeeScript 等語言，你應該將相關函式庫加到引擎的 .gemspec。 6.5 獨立的靜態資源和預先編譯有時候，主應用程式不需要載入引擎的靜態資源。例如，你建立了僅存在於引擎中的管理功能。在這種情況下，主應用程式不需要載入 admin.css 或 admin.js。只有 gem 的管理後台才需要這些靜態資源。主應用程式在其樣式表中載入 blorgh/admin.css 是沒有意義的。在這種情況下，你應該明確定義這些需要預先編譯的靜態資源。這會告訴 Sprockets 在觸發 bin/rails assets:precompile 時加入你的引擎靜態資源。 你可以在 engine.rb 定義需要預先編譯的靜態資源： 123initializer \"blorgh.assets.precompile\" do |app| app.config.assets.precompile += %w( admin.js admin.css )end 更多相關資訊，請參閱 Asset Pipeline 指南。 6.6 其它相依 Gem引擎的相依套件應該在引擎跟目錄下的 .gemspec 檔案中指定。因為我們可能會以 gem 的方式安裝引擎。如果在引擎的 Gemfile 指定相依套件，那麼 gem install 將無法識別這些相依關係，因此它們不會被安裝，從而導致引擎發生故障。 要指定當 gem install 時應該和引擎一起安裝的相依套件，只需要在引擎中 .gemspec 檔案的 Gem::Specification 區塊內指定： 1s.add_dependency \"moo\" 還可以像這樣指定僅用於開發環境的相依套件： 1s.add_development_dependency \"moo\" 在應用程式內執行 bundle install 時，這兩種相依套件都會被安裝。用於開發環境的相依套件只有在執行引擎測試時才會使用。 注意，如果要在引擎載入時立即載入相依套件，你應該在引擎初始化前就載入它們。例如： 1234567require 'other_engine/engine'require 'yet_another_engine/engine'module MyEngine class Engine &lt; ::Rails::Engine endend 所以當你過早載入某些框架時（例如，ActiveRecord::Base），你就違反了使用 Rails 應用程式的使用慣例 7. Active Support 的 on_load HookActive Support 是 Ruby on Rails 元件，負責提供 Ruby 語言擴充套件和公用程式。 Rails 程式碼通常可以在應用程式載入時引用。Rails 負責這些框架的載入順序，所以當你過早載入某些框架時（例如 ActiveRecord::Base），就違反了 Rails 應用程式的使用慣例。此外，透過在應用程式啟動時載入如 ActiveRecord::Base 等程式碼，你正在載入整個框架，這可能會降低啟動時間，並可能導致載入順序與應用程式啟動發生衝突。 on_load API 能夠讓我們在初始化的流程中掛載你所需要的功能，而不違反 Rails 所制定的規則。這也將緩解啟動效能下降並避免衝突。 8. 什麼是 on_load Hook？由於 Ruby 是動態語言，因此某些程式碼會導致載入相關的 Rails 元件。以此程式碼片段為例： 1ActiveRecord::Base.include(MyActiveRecordHelper) 當這段程式碼片段被載入時，發現有 ActiveRecord::Base，因此 Ruby 會去尋找該常數的定義並載入它。這將導致整個 Active Record 框架在啟動時被載入。 ActiveSupport.on_load 是一種延遲載入程式碼的機制，直到真正需要時才載入。上述代碼可以修改為： 1ActiveSupport.on_load(:active_record) &#123; include MyActiveRecordHelper &#125; 新的程式碼片段會在 ActiveRecord::Base 載入後才載入 MyActiveRecordHelper。 9. 它是如何運作的？在 Rails 框架中，載入特定函式庫時會呼叫這些 hook。例如，當 ActionController::Base 被載入時，會呼叫 :action_controller_base hook。也就是說，ActiveSupport.on_load 呼叫設定用的 :action_controller_base hook 會在 ActionController::Base 環境中被呼叫。（因此 self 是 ActionController::Base 的實例變數）。 10. 修改程式碼，使用 on_load Hook修改程式碼很簡單。如果你有一行引用 Rails 框架的程式碼，例如 ActiveRecord::Base，你可以將該程式碼包裝在 on_load hook 中。 10.1 範例 11ActiveRecord::Base.include(MyActiveRecordHelper) 改為 1ActiveSupport.on_load(:active_record) &#123; include MyActiveRecordHelper &#125; # self 在這裡指的是 ActiveRecord::Base，所以可以直接呼叫 #include 10.2 範例 21ActionController::Base.prepend(MyActionControllerHelper) 改為 1ActiveSupport.on_load(:action_controller_base) &#123; prepend MyActionControllerHelper &#125; # self 在這裡指的是 ActionController::Base，所以可以直接呼叫 #prepend 10.3 範例 31ActiveRecord::Base.include_root_in_json = true 改為 1ActiveSupport.on_load(:active_record) &#123; self.include_root_in_json = true &#125; # self 在這裡指的是 ActiveRecord::Base 11. 可用的 Hook這些是可以在程式碼中使用的 hook。 要接上以下某個類別的初始化過程，請使用可用的 hook。 類別 可用的 Hook ActionCable action_cable ActionController::API action_controller_api ActionController::API action_controller ActionController::Base action_controller_base ActionController::Base action_controller ActionController::TestCase action_controller_test_case ActionDispatch::IntegrationTest action_dispatch_integration_test ActionDispatch::SystemTestCase action_dispatch_system_test_case ActionMailer::Base action_mailer ActionMailer::TestCase action_mailer_test_case ActionView::Base action_view ActionView::TestCase action_view_test_case ActiveJob::Base active_job ActiveJob::TestCase active_job_test_case ActiveRecord::Base active_record ActiveSupport::TestCase active_support_test_case i18n i18n 12. 配置 Hook這些是可用的配置 hook。它們並沒有涉及到任何特定的框架，而是在整個應用程式中執行。 Hook 使用案例 before_configuration 第一個執行的配置區塊。在所有初始化程式執行前呼叫。 before_initialize 第二個執行的配置區塊。框架初始化前呼叫。 before_eager_load 第三個執行的配置區塊。config.eager_load 設為 false 時不執行。 after_initialize 最後執行的配置區塊。框架初始化完成後呼叫。 12.1 範例1config.before_configuration &#123; puts 'I am called before any initializers' &#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://calvertyang.github.io/tags/Ruby-on-Rails/"},{"name":"Rails Engine","slug":"Rails-Engine","permalink":"https://calvertyang.github.io/tags/Rails-Engine/"}]},{"title":"在 Heroku 使用 Active Storage","slug":"active-storage-on-heroku","date":"2018-05-22T03:34:34.000Z","updated":"2018-05-22T03:37:41.000Z","comments":true,"path":"2018/05/22/active-storage-on-heroku/","link":"","permalink":"https://calvertyang.github.io/2018/05/22/active-storage-on-heroku/","excerpt":"原文：HEROKU BLOG — Rails 5.2 Active Storage: Previews, Poppler, and Solving Licensing Pitfalls 上個月剛剛發佈的 Rails 5.2 有一個重要的新功能：Active Storage。Active Storage 支援各種後端服務（如 AWS S3），為 Active Record 模型提供檔案上傳和附件功能。雖然有像 Paperclip 這樣的函式庫來做類似的工作，但這是 Rails 第一次發佈這樣的功能。在 Heroku，我們認為雲端儲存是最佳實作規範，所以我們確保它能在我們的平台上執行。在這篇文章中，我們將分享如何準備發佈 Rails 5.2，以及如何在部署的應用程式中使用新的 Active Storage 功能。","text":"原文：HEROKU BLOG — Rails 5.2 Active Storage: Previews, Poppler, and Solving Licensing Pitfalls 上個月剛剛發佈的 Rails 5.2 有一個重要的新功能：Active Storage。Active Storage 支援各種後端服務（如 AWS S3），為 Active Record 模型提供檔案上傳和附件功能。雖然有像 Paperclip 這樣的函式庫來做類似的工作，但這是 Rails 第一次發佈這樣的功能。在 Heroku，我們認為雲端儲存是最佳實作規範，所以我們確保它能在我們的平台上執行。在這篇文章中，我們將分享如何準備發佈 Rails 5.2，以及如何在部署的應用程式中使用新的 Active Storage 功能。 信任但要驗證在 Heroku，信任是我們的第一價值。當我們得知 Active Storage 隨著 Rails 5.2 發佈時，我們開始嘗試使用它的所有功能。Active Storage 其中一個最便利的功能就是能夠預覽 PDF 和影片。PDF 或影片的小截圖將從檔案中擷取並呈現在頁面上，而不是透過文字連結到資源。 測試版的 Rails 5.2 使用了熱門的開源工具 FFmpeg 和 MuPDF 來產生影片和 PDF 預覽。透過我們的安全及法務部門審查了這些新的二進位相依檔案，我們發現 MuPDF 採用 AGPL 授權條款，並且需要商業許可才能使用。如果我們在預設情況下簡單地將 MuPDF 加到 Rails 5.2+ 的應用程式中，我們的許多客戶會不知道他們需要購買 MuPDF 才能在商業上使用它。 AGPL 授權條款的限制在 2017 年 9 月引起公眾關注。為了準備 5.2 版本，我們的工程師 Terence Lee 致力於更新 Active Storage，以便 PDF 預覽功能也可以使用沒有商業許可的開源後端程式。我們在 2018 年 2 月向 Rails 提交了一個 PR，介紹採用 poppler PDF 作為 MuPDF 的替代方案的能力。該 PR 大約在 1 個月後被合併，現在任何 Rails 5.2 使用者，無論是否在 Heroku，都無需購買商業許可即可呈現 PDF 預覽。 展示在 Heroku 使用 Active Storage如果你已經有實作 Active Storage 的應用程式，則可以跳轉到我們開發中心的 Active Storage 文件。 或者，你可以使用我們的應用程式範例。這是一個 Rails 5.2 應用程式，它是數位布告欄，允許使用者張貼影片、PDF 和圖片。你可以在 Github 檢視原始碼或用 Heroku 按鈕部署應用程式： 注意：這個應用程式範例需要付費的 S3 附加元件。 以下是該應用程式的範例影片。 當你開啟首頁時，選擇適當的資源檔，然後送出表單。在影片中，mp4 檔案被上傳到 S3，然後透過 ffmpeg 幫助 Rails 產生預覽。很簡約。 在 Heroku 使用 Active Storage如果你使用按鈕部署應用程式範例，它已經透過 app.json 設定能在 Heroku 上運作，但是，如果你有自己的應用程式想要部署，你要如何設定它以便在 Heroku 上運作？ 根據開發中心的 Active Storage 文件，你將需要一個檔案儲存服務，讓你所有的 dynos 都可以與其溝通。該範例使用名為 Bucketeer 的 Heroku S3 附加元件，但你也可以使用現有的 S3 憑證。 馬上開始，請將 S3 的 AWS gem 加到 Gemfile，如果你要修改圖片，請加入 Mini Magick： 12gem \"aws-sdk-s3\", require: falsegem 'mini_magick', '~&gt; 4.8' 更新 Gemfile 後別忘了 $ bundle install。 接下來，在你的 config/storage.yml 檔案中加入一個 amazon 選項來指向 S3 設定，在這個範例中我們使用了由 Bucketeer 設定的配置： 123456amazon: service: S3 access_key_id: &lt;%= ENV['BUCKETEER_AWS_ACCESS_KEY_ID'] %&gt; secret_access_key: &lt;%= ENV['BUCKETEER_AWS_SECRET_ACCESS_KEY'] %&gt; region: &lt;%= ENV['BUCKETEER_AWS_REGION'] %&gt; bucket: &lt;%= ENV['BUCKETEER_BUCKET_NAME'] %&gt; 然後確保你的應用程式設定為在生產環境中使用 :amazon 儲存配置： 1config.active_storage.service = :amazon 如果你忘記了這一步，預設的儲存是使用 :local 將檔案儲存到磁碟。這不是處理生產環境中上傳檔案的可擴展方式。如果你不小心將它部署到 Heroku，首先它會顯示檔案已上傳，但是如果你執行超過一個 dyno，他們會在隨機的請求中消失。當重新啟動 dynos 時，這些檔案將完全消失。你可以在開發中心取得有關 Heroku 的臨時磁碟的更多資訊。 最後，要使其在生產環境中運作的最後一件事是安裝一個客制的建置套件，它將安裝用來產生資源預覽的二進位相依檔案 ffmpeg 和 poppler： 1$ heroku buildpacks:add -i 1 https://github.com/heroku/heroku-buildpack-activestorage-preview 一但你完成了，就可以部署到 Heroku！ 將 Active Storage 加到現有應用程式如果你的應用程式還沒有 Active Storage，可以把它加入。首先，你需要執行以下指令啟用 Active Storage： 1$ bin/rails active_storage:install 這會新增一個遷移，讓 Rails 追蹤上傳的檔案。 接下來，你需要一個模型來「附加」檔案。你可以使用現有模型或建立新模型。在應用程式範例中，使用了幾乎是空的 bulletin 模型： 1$ bin/rails generate scaffold bulletin 接下來，在應用程式上執行遷移： 1$ bin/rails db:migrate 在資料庫遷移後，更新模型讓 Rails 知道你打算讓它能夠附加檔案： 123class Bulletin &lt; ApplicationRecord has_one_attached :attachmentend 一旦完成，我們還需要三個部分：上傳附件的表單、儲存附件的控制器以及呈現附件的視圖。 如果你有一個現有的表單，你可以透過 file_field 視圖輔助方法加入一個附件欄位： 1&lt;%= form.file_field :attachment %&gt; 你可以在應用程式範例中看到帶有附件的表單範例。一旦有了表單，你將需要保存附件。 在這個應用程式範例中，首頁包含了表單和視圖。附件在 bulletin 控制器被儲存，然後將使用者導回主布告列表： 1234567def create @bulletin = Bulletin.new() @bulletin.attachment.attach(params[:bulletin][:attachment]) @bulletin.save! redirect_back(fallback_location: root_path)end 最後，在 welcome 視圖中，我們迭代每個布告項目，並根據我們的附件類型，以不同的方式呈現。 在 Active Storage 中，對於 PDF 和影片，只要系統安裝了正確的二進位檔案，previewable? 方法將回傳 true。對於圖片，如果安裝了 mini_magick，variable? 方法將回傳 true。如果這些都不是 true，那麼附件可能是一個最好在下載後查看的檔案。下面展示了我們如何表示該邏輯： 1234567891011121314&lt;ul class=\"no-bullet\"&gt; &lt;% @bulletin_list.each do |bulletin| %&gt; &lt;li&gt; &lt;% if bulletin.attachment.previewable? %&gt; &lt;%= link_to(image_tag(bulletin.attachment.preview(resize: \"200x200&gt;\")), rails_blob_path(bulletin.attachment, disposition: \"attachment\")) %&gt; &lt;% elsif bulletin.attachment.variable? %&gt; &lt;%= link_to(image_tag(bulletin.attachment.variant(resize: \"200x200\")), rails_blob_path(bulletin.attachment, disposition: \"attachment\"))%&gt; &lt;% else %&gt; &lt;%= link_to \"Download file\", rails_blob_path(bulletin.attachment, disposition: \"attachment\") %&gt; &lt;% end %&gt; &lt;/li&gt; &lt;% end %&gt;&lt;/ul&gt; 一旦你完成以上所有步驟，並將 Active Storage 設定為在生產環境中運作，使用者就可以輕鬆上傳和下載檔案。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://calvertyang.github.io/tags/Ruby-on-Rails/"},{"name":"Active Storage","slug":"Active-Storage","permalink":"https://calvertyang.github.io/tags/Active-Storage/"},{"name":"Heroku","slug":"Heroku","permalink":"https://calvertyang.github.io/tags/Heroku/"}]},{"title":"Active Storage 概要","slug":"active-storage-overview","date":"2018-05-18T04:00:33.000Z","updated":"2018-08-15T08:59:50.000Z","comments":true,"path":"2018/05/18/active-storage-overview/","link":"","permalink":"https://calvertyang.github.io/2018/05/18/active-storage-overview/","excerpt":"原文：Ruby on Rails Guides — Active Storage Overview Active Storage 是 Rails 5.2 所新增的功能，它可以讓你輕鬆的將檔案傳送到 Amazon S3、Google Cloud Storage 或 Microsoft Azure Storage 等雲端儲存服務，並將這些檔案附加到 Active Record。 支援一個主要雲端儲存服務，並在其它服務中建立鏡像以實現備援機制，它也提供了用於測試或本地部署的磁碟服務，但重點還是放在雲端儲存。 檔案可以從伺服器上傳到雲端或直接從客戶端上傳到雲端。","text":"原文：Ruby on Rails Guides — Active Storage Overview Active Storage 是 Rails 5.2 所新增的功能，它可以讓你輕鬆的將檔案傳送到 Amazon S3、Google Cloud Storage 或 Microsoft Azure Storage 等雲端儲存服務，並將這些檔案附加到 Active Record。 支援一個主要雲端儲存服務，並在其它服務中建立鏡像以實現備援機制，它也提供了用於測試或本地部署的磁碟服務，但重點還是放在雲端儲存。 檔案可以從伺服器上傳到雲端或直接從客戶端上傳到雲端。 閱讀本指南後，你將知道： 如何附加一或多個檔案到記錄。 如何刪除檔案。 如何連結到檔案。 如何使用變體（variant）來轉換圖片。 如何產生非圖片檔案的預覽圖，如 PDF 或影片。 如何繞過應用程式伺服器，直接從瀏覽器上傳檔案到儲存服務。 如何清理測試過程中儲存的檔案。 如何實作對其它雲端儲存服務的支援。 1. 什麼是 Active Storage?Active Storage 方便將檔案上傳到 Amazon S3、Google Cloud Storage 或 Microsoft Azure Storage 等雲端儲存服務，並將這些檔案附加到 Active Record 物件。它配備了本地磁碟服務以進行開發和測試，並支援將檔案鏡像到次要服務以進行備份和遷移。 使用 Active Storage，應用程式可以透過 ImageMagick 轉換上傳圖片，產生非圖片檔案（如 PDF 或影片）的預覽圖，並從任意檔案中提取中繼資料。 2. 安裝Active Storage 在應用程式資料庫中使用兩個名為 active_storage_blobs 和 active_storage_attachments 的資料表。建立新的應用程式（或將應用程式升級到 Rails 5.2），執行 rails active_storage:install 來產生用來建立這些資料表的遷移。使用 rails db:migrate 來執行遷移。 在 config/storage.yml 定義 Active Storage 服務。對應用程式使用的每個服務，提供一個名稱和必要的設定。下面的範例定義了三個名為 local、test 和 amazon 的服務： 123456789101112local: service: Disk root: &lt;%= Rails.root.join(\"storage\") %&gt;test: service: Disk root: &lt;%= Rails.root.join(\"tmp/storage\") %&gt;amazon: service: S3 access_key_id: \"\" secret_access_key: \"\" 透過設定 Rails.application.config.active_storage.service 告訴 Active Storage 要使用哪個服務。由於每個環境都可能使用不同的服務，因此建議在每個環境的基礎設定上進行。要在開發環境中使用先前範例中的磁碟服務，你可以將以下內容加到 config/environments/development.rb： 12# 在本地儲存檔案。config.active_storage.service = :local 要在生產環境使用 Amazon S3，你可以將以下內容加到 config/environments/production.rb： 12# 在 Amazon S3 儲存檔案。config.active_storage.service = :amazon 繼續閱讀來取得關於內建服務轉接器（如 Disk 和 S3）及其所需設定的更多資訊。 2.1. 磁碟服務在 config/storage.yml 定義磁碟服務： 123local: service: Disk root: &lt;%= Rails.root.join(\"storage\") %&gt; 2.2. Amazon S3 服務在 config/storage.yml 定義 S3 服務： 123456amazon: service: S3 access_key_id: \"\" secret_access_key: \"\" region: \"\" bucket: \"\" 將 aws-sdk-s3 gem 加到 Gemfile： 1gem \"aws-sdk-s3\", require: false Active Storage 的核心功能需要以下權限：s3:ListBucket、s3:PutObject、s3:GetObject 和 s3:DeleteObject。如果你設定了其它上傳選項，如 ACL 設定，則可能需要額外的權限。 如果你想使用環境變數、標準 SDK 設定檔、設定檔、IAM 實例設定檔或工作角色，則可以省略上面範例中的 access_key_id、secret_access_key 和 region 值。Amazon S3 服務支援 AWS SDK 文件中描述的所有認證選項。 2.3. Microsoft Azure Storage 服務在 config/storage.yml 定義 Azure Storage 服務： 12345azure: service: AzureStorage storage_account_name: \"\" storage_access_key: \"\" container: \"\" 將 azure-storage gem 加到 Gemfile： 1gem \"azure-storage\", require: false 2.4. Google Cloud Storage 服務在 config/storage.yml 定義 Google Cloud Storage 服務： 12345google: service: GCS credentials: &lt;%= Rails.root.join(\"path/to/keyfile.json\") %&gt; project: \"\" bucket: \"\" 可以選擇提供一個 Hash 憑證來取代密鑰路徑： 123456789101112131415google: service: GCS credentials: type: \"service_account\" project_id: \"\" private_key_id: &lt;%= Rails.application.credentials.dig(:gcs, :private_key_id) %&gt; private_key: &lt;%= Rails.application.credentials.dig(:gcs, :private_key) %&gt; client_email: \"\" client_id: \"\" auth_uri: \"https://accounts.google.com/o/oauth2/auth\" token_uri: \"https://accounts.google.com/o/oauth2/token\" auth_provider_x509_cert_url: \"https://www.googleapis.com/oauth2/v1/certs\" client_x509_cert_url: \"\" project: \"\" bucket: \"\" 將 google-cloud-storage gem 加到 Gemfile： 1gem \"google-cloud-storage\", \"~&gt; 1.8\", require: false 2.5. 鏡像服務你可以透過定義鏡像服務來讓多個服務保持同步。當檔案被上傳或刪除時，它會在所有鏡像服務中完成。鏡像服務可用來幫助生產環境中服務之間的遷移。你可以開始鏡像到新服務，將現有檔案從舊服務複製到新服務，然後全力投入新服務。根據上述定義你想要使用的每項服務，從鏡像服務中引用它們。 12345678910111213141516171819s3_west_coast: service: S3 access_key_id: \"\" secret_access_key: \"\" region: \"\" bucket: \"\"s3_east_coast: service: S3 access_key_id: \"\" secret_access_key: \"\" region: \"\" bucket: \"\"production: service: Mirror primary: s3_east_coast mirrors: - s3_west_coast 檔案由主服務提供。 與直接上傳功能不相容。 3. 將檔案附加到記錄3.1. has_one_attachedhas_one_attached 指令設定了記錄和檔案間的一對一關係。每個記錄可以附加一個檔案。 例如，假設你的應用程式有一個 User 模型。如果想讓每個使用者都有一個頭像，請這樣定義 User 模型： 123class User &lt; ApplicationRecord has_one_attached :avatarend 你可以建立一個帶有頭像的使用者： 123456789101112class SignupController &lt; ApplicationController def create user = User.create!(user_params) session[:user_id] = user.id redirect_to root_path end private def user_params params.require(:user).permit(:email_address, :password, :avatar) endend 呼叫 avatar.attach 將頭像附加到現有使用者： 1Current.user.avatar.attach(params[:avatar]) 呼叫 avatar.attached? 來確定特定使用者是否有頭像： 1Current.user.avatar.attached? 3.2. has_many_attachedhas_many_attached 指令設定了記錄和檔案間的一對多關係。每個記錄可以附加多個檔案。 例如，假設你的應用程式有一個 Message 模型。如果想讓每個訊息都有多張圖片，請這樣定義 Message 模型： 123class Message &lt; ApplicationRecord has_many_attached :imagesend 你可以建立一則帶有多張圖片的訊息： 1234567891011class MessagesController &lt; ApplicationController def create message = Message.create!(message_params) redirect_to message end private def message_params params.require(:message).permit(:title, :content, images: []) endend 呼叫 images.attach 將圖片附加到現有訊息： 1@message.images.attach(params[:images]) 呼叫 images.attached? 來確定特定訊息是否有圖片： 1@message.images.attached? 3.3 附加 File/IO 物件有時候你需要附加一個不是透過 HTTP 請求傳送的檔案。例如，你可能需要附加從磁碟上產生的檔案，或從使用者提交的網址下載的檔案。你可能也想在模型測試中附加檔案。要做到這一點，至少提供包含一個開啟 IO 物件和檔案名稱的 Hash： 1@message.image.attach(io: File.open('/path/to/file'), filename: 'file.pdf') 如果可能，最好提供內容類型。Active Storage 會嘗試從資料來確定檔案的內容類型。若辦不到，它將採用你提供的內容類型。 1@message.image.attach(io: File.open('/path/to/file'), filename: 'file.pdf', content_type: 'application/pdf') 如果你未提供內容類型，且 Active Storage 無法自動確定檔案的內容類型，則預設為 application/octet-stream。 譯者註：若使用 AJAX 來送出表單，可能會出現 No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. 的錯誤訊息，以 Amazon S3 為例，需要登入 AWS 後台修改 CORS 設定，設定範例如下： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;CORSConfiguration xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\"&gt;&lt;CORSRule&gt; &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt; &lt;AllowedMethod&gt;GET&lt;/AllowedMethod&gt; &lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt; &lt;AllowedHeader&gt;Authorization&lt;/AllowedHeader&gt;&lt;/CORSRule&gt;&lt;CORSRule&gt; &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt; &lt;AllowedMethod&gt;PUT&lt;/AllowedMethod&gt; &lt;AllowedMethod&gt;POST&lt;/AllowedMethod&gt; &lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt; &lt;AllowedHeader&gt;*&lt;/AllowedHeader&gt;&lt;/CORSRule&gt;&lt;/CORSConfiguration&gt; 4. 刪除檔案要從模型中刪除附件，請在附件上呼叫 purge。如果你的應用程式有設定使用 Active Job，刪除作業可以在背景完成。刪除作業會從儲存服務中刪除 blob 和檔案。 12345# 同步刪除頭像和實際資源檔案。user.avatar.purge# 透過 Active Job 非同步刪除相關模型和實際資源檔案。user.avatar.purge_later 5. 檔案連結為 blob 產生一個指向應用程式的永久連結。存取時，會返回一個重新導向到實際服務端點的連結。這種間接的方式將公開網址從實際網址分離開來，並允許例如鏡像不同服務中的附件以實現高可用性。重新導向連結的 HTTP 過期時間為 5 分鐘。 1url_for(user.avatar) 要建立下載連結，請使用 rails_blob_{path|url} 輔助方法。使用這個輔助方法可以讓你設定 disposition。 1rails_blob_path(user.avatar, disposition: \"attachment\") 如果你需要從控制器或視圖之外建立連結（背景作業、定時作業、等⋯），可以像這樣存取 rails_blob_path： 1Rails.application.routes.url_helpers.rails_blob_path(user.avatar, only_path: true) 6. 下載檔案如果需要在伺服器端處理 blob，例如，執行分析或進一步轉換時，可以用以下方式下載 blob 並取得二進位物件： 1binary = user.avatar.download 某些時候，您可能希望將其轉換為磁碟上的實體檔案，以便將檔案路徑傳遞給外部程式（如掃毒軟體、轉換程式、優化程式、壓縮程式等⋯）。在這種情況下，你可以在類別中引用 ActiveStorage::Downloading 模組，該模組提供了輔助方法直接下載檔案，避免將檔案儲存到記憶體中。ActiveStorage::Downloading 需要定義一個 blob 方法。 123456789101112131415class VirusScanner include ActiveStorage::Downloading attr_reader :blob def initialize(blob) @blob = blob end def scan download_blob_to_tempfile do |file| system 'scan_virus', file.path end endend 預設情況下，download_blob_to_tempfile 會在 Dir.tmpdir 中建立檔案。如果需要使用其它目錄，請在類別中覆寫 ActiveStorage::Downloading#tempdir： 123456789class VirusScanner include ActiveStorage::Downloading # ... private def tempdir '/path/to/tmp' endend 如果外部程式是獨立執行的程式，你可能也需要 chmod 該檔案及其目錄，因為 Tempfile 會將權限設定為 0600，其它用戶無法存取該檔案。 7. 轉換圖片要建立不同尺寸的圖片，請在 Blob 上呼叫 variant。你可以傳送任何 MiniMagick 所支援的轉換方式到此方法。 要啟用轉換功能，請將 mini_magick gem 加到 Gemfile： 1gem 'mini_magick' 當瀏覽器存取不同尺寸的圖片網址時，Active Storage 會將原始的 blob 延遲轉換為指定的格式，並導向到它新的服務位置。 1&lt;%= image_tag user.avatar.variant(resize: \"100x100\") %&gt; 8. 預覽檔案一些非圖片檔案可以被預覽：也就是說，他們可以用圖片來呈現。例如，可以透過擷取第一個影格來預覽影片檔。Active Storage 內建支援預覽影片和 PDF 文件。 1234567&lt;ul&gt; &lt;% @message.files.each do |file| %&gt; &lt;li&gt; &lt;%= image_tag file.preview(resize: \"100x100&gt;\") %&gt; &lt;/li&gt; &lt;% end %&gt;&lt;/ul&gt; 擷取預覽圖片需要第三方應用程式，用於影片的 ffmpeg 和用於 PDF 的 mutool。這些函式庫不是由 Rails 提供的。你必須自行安裝他們才能使用內建的預覽器。在安裝和使用第三方軟體前，請確定你了解這樣做所牽涉的許可。 9. 直接上傳Active Storage 及其包含的 JavaScript 函式庫支援從客戶端直接上傳到雲端。 9.1. 安裝直接上傳功能 在應用程式的 JavaScript 封裝載入 activestorage.js。使用 Asset Pipeline： 1//= require activestorage 使用 npm 套件： 12import * as ActiveStorage from \"activestorage\"ActiveStorage.start() 在檔案輸入欄位中註記直接上傳。 1&lt;%= form.file_field :attachments, multiple: true, direct_upload: true %&gt; 就是這樣！在表單提交後會開始上傳檔案。 9.2. 直接上傳功能的 JavaScript 事件 事件名稱 事件目標 事件資料（event.detail） 描述 direct-uploads:start &lt;form&gt; 無 已提交包含直接上傳欄位的表單。 direct-upload:initialize &lt;input&gt; {id, file} 表單提交後，處理每個檔案。 direct-upload:start &lt;input&gt; {id, file} 開始直接上傳。 direct-upload:before-blob-request &lt;input&gt; {id, file, xhr} 向你的應用程式請求直接上傳中繼資料之前。 direct-upload:before-storage-request &lt;input&gt; {id, file, xhr} 請求儲存檔案之前。 direct-upload:progress &lt;input&gt; {id, file, progress} 請求儲存檔案的進度。 direct-upload:error &lt;input&gt; {id, file, error} 發生錯誤。除非此事件被取消，否則將顯示提醒。 direct-upload:end &lt;input&gt; {id, file} 直接上傳已結束。 direct-uploads:end &lt;form&gt; 無 所有直接上傳都已結束。 9.3. 範例你可以使用這些事件來顯示上傳的進度。 在表單內顯示上傳的檔案： 1234567891011121314151617181920212223242526272829303132333435363738// direct_uploads.jsaddEventListener(\"direct-upload:initialize\", event =&gt; &#123; const &#123; target, detail &#125; = event const &#123; id, file &#125; = detail target.insertAdjacentHTML(\"beforebegin\", ` &lt;div id=\"direct-upload-$&#123;id&#125;\" class=\"direct-upload direct-upload--pending\"&gt; &lt;div id=\"direct-upload-progress-$&#123;id&#125;\" class=\"direct-upload__progress\" style=\"width: 0%\"&gt;&lt;/div&gt; &lt;span class=\"direct-upload__filename\"&gt;$&#123;file.name&#125;&lt;/span&gt; &lt;/div&gt; `)&#125;)addEventListener(\"direct-upload:start\", event =&gt; &#123; const &#123; id &#125; = event.detail const element = document.getElementById(`direct-upload-$&#123;id&#125;`) element.classList.remove(\"direct-upload--pending\")&#125;)addEventListener(\"direct-upload:progress\", event =&gt; &#123; const &#123; id, progress &#125; = event.detail const progressElement = document.getElementById(`direct-upload-progress-$&#123;id&#125;`) progressElement.style.width = `$&#123;progress&#125;%`&#125;)addEventListener(\"direct-upload:error\", event =&gt; &#123; event.preventDefault() const &#123; id, error &#125; = event.detail const element = document.getElementById(`direct-upload-$&#123;id&#125;`) element.classList.add(\"direct-upload--error\") element.setAttribute(\"title\", error)&#125;)addEventListener(\"direct-upload:end\", event =&gt; &#123; const &#123; id &#125; = event.detail const element = document.getElementById(`direct-upload-$&#123;id&#125;`) element.classList.add(\"direct-upload--complete\")&#125;) 加上樣式： 123456789101112131415161718192021222324252627282930313233343536373839/* direct_uploads.css */.direct-upload &#123; display: inline-block; position: relative; padding: 2px 4px; margin: 0 3px 3px 0; border: 1px solid rgba(0, 0, 0, 0.3); border-radius: 3px; font-size: 11px; line-height: 13px;&#125;.direct-upload--pending &#123; opacity: 0.6;&#125;.direct-upload__progress &#123; position: absolute; top: 0; left: 0; bottom: 0; opacity: 0.2; background: #0076ff; transition: width 120ms ease-out, opacity 60ms 60ms ease-in; transform: translate3d(0, 0, 0);&#125;.direct-upload--complete .direct-upload__progress &#123; opacity: 0.4;&#125;.direct-upload--error &#123; border-color: red;&#125;input[type=file][data-direct-upload-url][disabled] &#123; display: none;&#125; 9.4. 與函式庫或框架整合如果你想從 JavaScript 框架中使用直接上傳功能，或者想要整合自訂的拖放解決方案，可以使用 DirectUpload 類別來達成此目的。當從你的函式庫收到選擇的檔案後，實例化一個 DirectUpload 並呼叫它的 create 方法。當上傳完成時，create 會調用 callback。 12345678910111213141516171819202122232425262728293031323334353637import &#123; DirectUpload &#125; from \"activestorage\"const input = document.querySelector('input[type=file]')// 綁定到檔案放置 - 在父元素上使用 ondrop 或使用 Dropzone 之類的函式庫const onDrop = (event) =&gt; &#123; event.preventDefault() const files = event.dataTransfer.files; Array.from(files).forEach(file =&gt; uploadFile(file))&#125;// 綁定到正常的檔案選取input.addEventListener('change', (event) =&gt; &#123; Array.from(input.files).forEach(file =&gt; uploadFile(file)) // 你可以從輸入欄位清除選定的檔案 input.value = null&#125;)const uploadFile = (file) &#123; // 表單的檔案輸入欄位需要 direct_upload: true，它提供了 data-direct-upload-url const url = input.dataset.directUploadUrl const upload = new DirectUpload(file, url) upload.create((error, blob) =&gt; &#123; if (error) &#123; // 錯誤處理 &#125; else &#123; // 將適當名稱且值為 blob.signed_id 的隱藏輸入欄位加到表單中，以便 blob id 可以在 // 正常上傳流程中被傳送 const hiddenField = document.createElement('input') hiddenField.setAttribute(\"type\", \"hidden\"); hiddenField.setAttribute(\"value\", blob.signed_id); hiddenField.name = input.name document.querySelector('form').appendChild(hiddenField) &#125; &#125;)&#125; 如果你需要追蹤檔案上傳進度，可以傳送第三個參數給 DirectUpload 建構函數。在上傳過程中，DirectUpload 會呼叫物件的 directUploadWillStoreFileWithXHR 方法。然後，你可以在 XHR 上綁定自己的進度處理程式。 123456789101112131415161718192021222324252627import &#123; DirectUpload &#125; from \"activestorage\"class Uploader &#123; constructor(file, url) &#123; this.upload = new DirectUpload(this.file, this.url, this) &#125; upload(file) &#123; this.upload.create((error, blob) =&gt; &#123; if (error) &#123; // 錯誤處理 &#125; else &#123; // 將適當名稱且值為 blob.signed_id 的隱藏輸入欄位加到表單中，以便 blob id 可以在 // 正常上傳流程中被傳送 &#125; &#125;) &#125; directUploadWillStoreFileWithXHR(request) &#123; request.upload.addEventListener(\"progress\", event =&gt; this.directUploadDidProgress(event)) &#125; directUploadDidProgress(event) &#123; // 使用 event.loaded 和 event.total 來更新進度列 &#125;&#125; 10. 移除系統測試過程中儲存的檔案系統測試透過復原（Rollback）交易來清理測試資料。因為 destroy 永遠不會在對像上呼叫，所以附加的檔案永遠不會被清理。如果你想清除檔案，可以在 after_teardown callback 中完成。在此處操作可以確保測試過程中建立的連線都已完成，並且不會從 Active Storage 收到錯誤，表示無法找到檔案。 123456789101112class ApplicationSystemTestCase &lt; ActionDispatch::SystemTestCase driven_by :selenium, using: :chrome, screen_size: [1400, 1400] def remove_uploaded_files FileUtils.rm_rf(\"#&#123;Rails.root&#125;/storage_test\") end def after_teardown super remove_uploaded_files endend 如果你的系統測試驗證是否刪除帶有附件的模型，並且使用 Active Job，請將測試環境設定為使用行內佇列轉接器，以便立即執行清除工作，而不是在未來的某個時間執行。 你可能也想為測試環境使用單獨的服務定義，以便你的測試不會刪除在開發過程中建立的檔案。 12345# 使用行內作業處理，以便立即執行config.active_job.queue_adapter = :inline# 在測試環境中分開儲存檔案config.active_storage.service = :local_test 11. 實作支援其它雲端儲存服務如果你需要支援除了這些以外的雲端服務，則需要實作 Service。每個服務都透過實作上傳和下載檔案到雲端所需的方法，來擴充 ActiveStorage::Service。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://calvertyang.github.io/tags/Ruby-on-Rails/"},{"name":"Active Storage","slug":"Active-Storage","permalink":"https://calvertyang.github.io/tags/Active-Storage/"}]},{"title":"Electron API 範例","slug":"electron-api-demos","date":"2018-01-24T07:37:00.000Z","updated":"2018-05-21T07:58:31.000Z","comments":true,"path":"2018/01/24/electron-api-demos/","link":"","permalink":"https://calvertyang.github.io/2018/01/24/electron-api-demos/","excerpt":"","text":"因為最近在工作時需要使用 Electron，發現官方提供的 Electron API 應用程式範例很適合讓想入門的人了解一些基本 API 的用法以及實際執行的效果。 在 Github 上搜尋這個範例程式發現沒有正體中文版覺得有點可惜，於是就花了點時間來翻譯此範例程式。 原始碼可從 Github 下載，若有任何翻譯建議也歡迎提出。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://calvertyang.github.io/tags/Electron/"}]},{"title":"使用 RVG 繪圖","slug":"drawing-with-rvg","date":"2017-03-15T05:50:06.000Z","updated":"2018-08-09T08:03:20.000Z","comments":true,"path":"2017/03/15/drawing-with-rvg/","link":"","permalink":"https://calvertyang.github.io/2017/03/15/drawing-with-rvg/","excerpt":"原文：RMagick User’s Guide and Reference — Drawing with RVG 介紹RVG（Ruby 向量圖形）是 RMagick 的 Draw 類別的外觀，它提供了基於 W3C 推薦的可縮放向量圖形（Scalable Vector Graphics）的繪圖 API。 RVG 是一個可縮放向量繪圖函式庫。可縮放意味著圖形不是固定的像素尺寸。相同的圖形可以被呈現在螢幕上或列印出來。向量圖使用了幾何物件，如直線和圓。與點陣圖不同，向量圖在放大時不會「像素化」。 作為 RVG 函式庫的介紹，讓我們來看看如何畫出上面這隻小鴨。以下是完整的程式。 1234567891011121314151617181920212223242526272829303132333435363738require 'rvg/rvg'include MagickRVG::dpi = 72rvg = RVG.new(2.5.in, 2.5.in).viewbox(0,0,250,250) do |canvas| canvas.background_fill = 'white' canvas.g.translate(100, 150).rotate(-30) do |body| body.styles(:fill=&gt;'yellow', :stroke=&gt;'black', :stroke_width=&gt;2) body.ellipse(50, 30) body.rect(45, 20, -20, -10).skewX(-35) end canvas.g.translate(130, 83) do |head| head.styles(:stroke=&gt;'black', :stroke_width=&gt;2) head.circle(30).styles(:fill=&gt;'yellow') head.circle(5, 10, -5).styles(:fill=&gt;'black') head.polygon(30,0, 70,5, 30,10, 62,25, 23,20).styles(:fill=&gt;'orange') end foot = RVG::Group.new do |_foot| _foot.path('m0,0 v30 l30,10 l5,-10, l-5,-10 l-30,10z'). styles(:stroke_width=&gt;2, :fill=&gt;'orange', :stroke=&gt;'black') end canvas.use(foot).translate(75, 188).rotate(15) canvas.use(foot).translate(100, 185).rotate(-15) canvas.text(125, 30) do |title| title.tspan(\"duck|\").styles(:text_anchor=&gt;'end', :font_size=&gt;20, :font_family=&gt;'helvetica', :fill=&gt;'black') title.tspan(\"type\").styles(:font_size=&gt;22, :font_family=&gt;'times', :font_style=&gt;'italic', :fill=&gt;'red') end canvas.rect(249,249).styles(:stroke=&gt;'blue', :fill=&gt;'none') endrvg.draw.write('duck.gif') 摘要所有的繪圖都遵循相同的 3 個步驟： 建立一個 RVG 物件。指定最終圖片的寬度和高度。轉交程式碼區塊給 RVG.new 方法。 在程式區塊內，在 RVG 物件調用方法來指定背景，加入形狀、文字或點陣圖，或加入一組形狀、文字或點陣圖。 調用 draw 方法在背景繪出形狀、文字或點陣圖。 我將逐行介紹範例。","text":"原文：RMagick User’s Guide and Reference — Drawing with RVG 介紹RVG（Ruby 向量圖形）是 RMagick 的 Draw 類別的外觀，它提供了基於 W3C 推薦的可縮放向量圖形（Scalable Vector Graphics）的繪圖 API。 RVG 是一個可縮放向量繪圖函式庫。可縮放意味著圖形不是固定的像素尺寸。相同的圖形可以被呈現在螢幕上或列印出來。向量圖使用了幾何物件，如直線和圓。與點陣圖不同，向量圖在放大時不會「像素化」。 作為 RVG 函式庫的介紹，讓我們來看看如何畫出上面這隻小鴨。以下是完整的程式。 1234567891011121314151617181920212223242526272829303132333435363738require 'rvg/rvg'include MagickRVG::dpi = 72rvg = RVG.new(2.5.in, 2.5.in).viewbox(0,0,250,250) do |canvas| canvas.background_fill = 'white' canvas.g.translate(100, 150).rotate(-30) do |body| body.styles(:fill=&gt;'yellow', :stroke=&gt;'black', :stroke_width=&gt;2) body.ellipse(50, 30) body.rect(45, 20, -20, -10).skewX(-35) end canvas.g.translate(130, 83) do |head| head.styles(:stroke=&gt;'black', :stroke_width=&gt;2) head.circle(30).styles(:fill=&gt;'yellow') head.circle(5, 10, -5).styles(:fill=&gt;'black') head.polygon(30,0, 70,5, 30,10, 62,25, 23,20).styles(:fill=&gt;'orange') end foot = RVG::Group.new do |_foot| _foot.path('m0,0 v30 l30,10 l5,-10, l-5,-10 l-30,10z'). styles(:stroke_width=&gt;2, :fill=&gt;'orange', :stroke=&gt;'black') end canvas.use(foot).translate(75, 188).rotate(15) canvas.use(foot).translate(100, 185).rotate(-15) canvas.text(125, 30) do |title| title.tspan(\"duck|\").styles(:text_anchor=&gt;'end', :font_size=&gt;20, :font_family=&gt;'helvetica', :fill=&gt;'black') title.tspan(\"type\").styles(:font_size=&gt;22, :font_family=&gt;'times', :font_style=&gt;'italic', :fill=&gt;'red') end canvas.rect(249,249).styles(:stroke=&gt;'blue', :fill=&gt;'none') endrvg.draw.write('duck.gif') 摘要所有的繪圖都遵循相同的 3 個步驟： 建立一個 RVG 物件。指定最終圖片的寬度和高度。轉交程式碼區塊給 RVG.new 方法。 在程式區塊內，在 RVG 物件調用方法來指定背景，加入形狀、文字或點陣圖，或加入一組形狀、文字或點陣圖。 調用 draw 方法在背景繪出形狀、文字或點陣圖。 我將逐行介紹範例。 第 1 ~ 3 行12require 'rvg/rvg'include Magick 這只是平常用來載入 RVG 擴展的 Ruby 程式碼。為了少打一些字，我引入了 Magick 模組到物件的命名空間。 第 4 ~ 6 行123RVG::dpi = 72rvg = RVG.new(2.5.in, 2.5.in).viewbox(0,0,250,250) do |canvas| RVG::dpi 啟用了在 RVG 使用單位方法。當你將 RVG::dpi 設定為非 nil 值時，RVG 向整數和浮點數類別加入了許多轉換方法。這些方法允許你使用如英吋、毫米和厘米來指定測量單位。DPI 代表「每英吋點數」圖片解析度。這裡我設定 RVG::dpi 為 72，一個螢幕常用的數值。 RVG.new 需要 2 個參數。這些參數以像素指定最終圖片的寬度和高度。由於我定義了 RVG::dpi，我可以透過 in 轉換方法使用英吋指定這些數值。在 72dpi，最終圖片的邊長將會是 2.5 * 72 = 180 像素。 預設情況下，RVG 使用像素作為其測量單位，但由於我正在繪製一個可縮放的圖片，我不想限制自己的像素。viewbox 方法定義了一個具有邏輯單位的座標系。viewbox 需要 4 個參數，min_x、min_y、width 和 height。在第 6 行，我定義了我的座標系，它的原點在 (0,0)，寬度和高度為 250 單位。透過使用我自己的座標系，我可以稍後將圖片的尺寸更改為 5 英吋正方形或 1 英吋正方形，只需要更改 new 的參數。 預設座標系 預設情況下，RVG 座標系的原點在左上角。X 軸向右為正值，Y 軸向下為正值。上面的圖片顯示了該座標系的座標軸。我為範例圖片加上了淺藍色方格紙背景，以協助將坐標參數與圖片中的實際位置相關聯。只要記住，座標軸和方格紙背景實際上不是我產生的圖片的一部分。 RVG 類別是 RVG 定義的容器類別之一。容器物件可以包含圖形物件，如圓和線、文字、點陣圖及其他容器物件。最外面的容器永遠是 RVG 物件。我將加入所有組成鴨子的圖形物件到此容器。 我們通常會轉交一個程式區塊給容器建構方法。但是，在這裡我連接了 viewbox 到 new，所以 viewbox 負責產生並傳遞新的 RVG 實例到 canvas 參數。 第 7 行1canvas.background_fill = 'white' 預設情況下，RVG 圖形是繪製在透明背景上。當你想要顯示你的圖片在另一個圖片上時，這是很方便的。你可以透過為 background_fill= 屬性指定顏色來覆蓋預設背景顏色。這裡我設定背景顏色為「白色」。 第 9 ~ 13 行12345canvas.g.translate(100, 150).rotate(-30) do |body| body.styles(:fill=&gt;'yellow', :stroke=&gt;'black', :stroke_width=&gt;2) body.ellipse(50, 30) body.rect(45, 20, -20, -10).skewX(-35)end 這幾行做了很多事情，調用 7 個方法，所以讓我們一次介紹一個方法。 Groups（群組）Group 是 RVG 中的第二個容器類別。群組的目的是將一組座標系變形和一組樣式與群組中的圖形物件相關聯。要在另一個容器中建立群組物件，可調用容器上的 g 方法。如果程式區塊存在的話，g 方法會轉交給程式區塊。在這個範例中，沒有與 g 關聯的程式區塊，所以 g 返回了新群組。g 方法加入群組到其容器的內容。在這個範例中，群組的容器是在第 6 行建立的 canvas 物件。群組中的圖形物件會作為繪製容器的一部分被繪製。連接到 g 的 translate 和 rotate，透過新增坐標系變形來修改群組。 （那邊有一個程式區塊，但有個 2 方法調用在 g 和程式區塊間。我稍後會解釋。） Transforms（變形）我將使用這個群組來包含組成鴨子身體的橢圓和組成翅膀的矩形。我可以只指定 x 和 y 座標來定位這些形狀相對於原點的位置，但移動原點到我想繪製形狀的位置更容易。這是 translate 方法的目的。這個方法將原點移動到由其參數指定的（x,y）位置。我在群組物件上調用 translate，並且由群組的內容取得為此群組指定的座標系變形，橢圓和矩形將在相對於舊座標系原點的座標（100,150）上繪製。 另外，我想讓鴨子的身體向上傾斜，所以我使用 rotate 方法來旋轉座標軸。rotate 的參數是旋轉的角度。負數表示逆時針旋轉。 在平移及旋轉座標系後，座標軸看起來像這樣： 變形方法 有六種變形方法，除了 translate 和 rotate 外，還有 scale、skewX、skewY 和 matrix。當巢狀群組時，在內部群組上定義的任何變形都會被增加入外部變形。 Styles（樣式）回想一下，styles 方法修改了預設的群組樣式。styles 方法需要一個雜湊作為參數。雜湊的鍵是樣式名稱，雜湊的值為樣式值。在這個範例中，有三個樣式名稱。:fill 樣式將填充顏色設定為「黃色」。:stroke 樣式將邊框顏色設定為「黑色」。:stroke_width 樣式將邊框寬度設定為「2」。我想要樣式套用在全組內的所有物件，所以第 10 行我在新的群組物件上調用 style。 styles 方法是真正的主力。它幾乎在每個 RVG 的類別內都有定義，除了這三個之外還有許多其他樣式名稱。 Basic shapes（基本形狀）該群組包含了兩個基本形狀，一個橢圓和一個矩形。我使用 ellipse 方法將橢圓加入群組。ellipse 有四個參數，前兩個是在 x 軸及 y 軸上的半徑，是必要的。後兩個是中心點的 (x,y) 座標，當如同此處省略時，會預設為 (0,0)。我使用 rect 方法將矩形加入，它也有四個參數。前兩個是矩形的寬與高，後兩個是左上角的 (x,y) 座標。這兩個方法都會回傳自己本身，所以你可以連接其他方法給他們。 這是群組呈現時的樣子。橢圓以原點為中心，矩形的左上角稍微向上並且在原點的左邊。 形狀方法 有七種形狀方法，除了 ellipse 和 rect 外，還有 circle、line、path、polygon 和 polyline。你也可以把文字當成形狀。形狀可以加上邊框和填充顏色，也可以透過變形方法和 styles 方法進行修改。 SkewX（X 方向傾斜）每個人都知道翅膀看起來不像矩形！翅膀看起來像傾斜的平行四邊形。（嗯，在這個範例是這樣！）幸運的是，我們可以如同對容器一樣在形狀使用變形。skewX 方法讓我們很容易傾斜矩形。skewX 方法是另一個變形，它需要一個參數，傾斜 x 軸的角度。由於所有的形狀建構式包含 rect，都會回傳自己本身，我可以將 skewX 直接連接到 rect，並限制只有矩形有變形效果。結果如下所示。（我為翅膀座標系畫了座標軸。） 身體就是這樣。在繼續之前讓我們來完成其他瑣事。我之前說過容器建構式（如 g）會轉交給程式區塊如果存在的話。在這個範例，translate 和 rotate 方法介於 g 和程式區塊間。如果有相關聯的程式區塊，所有變形方法都會轉交過去，所以我可以很容易地將他們連接到容器建構式，並仍然使用程式區塊參數來定義群組內的圖形物件。方法連結是 RVG 常見的慣用方法，你會在範例中看到很多。 下一個群組繪製頭部。 第 15 ~ 20 行123456canvas.g.translate(130, 83) do |head| head.styles(:stroke=&gt;'black', :stroke_width=&gt;2) head.circle(30).styles(:fill=&gt;'yellow') head.circle(5, 10, -5).styles(:fill=&gt;'black') head.polygon(30,0, 70,5, 30,10, 62,25, 23,20).styles(:fill=&gt;'orange')end 這個部分與前一部分非常相似。我要定義一個群組來包含繪製鴨子頭部、眼睛和喙的圖形物件。首先，我使用平移方法來將原點移動到 (130,83)： 在第 16 行我在群組定義了 strok 和 stroke_width。在群組上定義的樣式會傳播到群組中的形狀，除非你覆蓋他們。要做到這一點，在形狀調用 styles。在這個群組，每個形狀都有自己的填充顏色。黃色的圓組成了頭部，circle 需要 3 個參數，第一個參數是圓的半徑，另外兩個參數是中心點的 (x,y) 座標。當如同此處省略時，會預設為 (0,0)。我使用一個小黑圓作為眼睛。 最後，我使用 polygon 方法來繪製鳥喙。此方法使用一系列的 (x,y) 座標繪製多邊形。如果最後一個座標不等於第一個，polygon 會暗中的加上它以關閉多邊形。同樣地，我使用 styles 將填充顏色設定為「橘色」。 第 22 ~ 25 行1234foot = RVG::Group.new do |_foot| _foot.path('m0,0 v30 l30,10 l5,-10, l-5,-10 l-30,10z'). styles(:stroke_width=&gt;2, :fill=&gt;'orange', :stroke=&gt;'black')end 這裡我透過直接調用 new 來建立一個群組，而不是在容器上調用 g 方法。這將建立一個不包含在畫布中的群組物件。你可以想像腳沒有附加到任何東西，像這樣： 第 26 ~ 27 行12canvas.use(foot).translate(75, 188).rotate(15)canvas.use(foot).translate(100, 185).rotate(-15) 要將群組加入到畫布，我使用 use 方法。use 方法可以接受任何容器或圖形物件作為參數。你還可以指定一個 (x,y) 座標來放置物件。然而，在這個範例中，我讓那些參數預設為 (0,0)，並使用 translate 來決定腳的位置。以下展示了左腳如何附加到鴨子上： 當然，鴨子在走路，所以我必須用 rotate 讓腳有點傾斜： 附加右腳很簡單，再次調用 use 但使用不同的參數來 translate 和 rotate： 第 29 ~ 34 行123456canvas.text(125, 30) do |title| title.tspan(\"duck|\").styles(:text_anchor=&gt;'end', :font_size=&gt;20, :font_family=&gt;'helvetica', :fill=&gt;'black') title.tspan(\"type\").styles(:font_size=&gt;22, :font_family=&gt;'times', :font_style=&gt;'italic', :fill=&gt;'red')end 我現在需要的是一個圖片標題。文字在 RVG 是 text 方法的工作。和形狀方法相同，text 可以與任何容器物件一起使用。text 本身是一個容器，除了它只能包含文字相關的物件。text 方法接受 2 或 3 個參數，一個 (x,y) 座標對和一個可選的字串。(x,y) 座標對定義目前文字開始呈現的位置，如果有一個字串參數，它將從目前文字位置開始被呈現。呈現文字會改變目前文字位置到文字的結尾。 在這個範例中，文字被作為一個容器，文字物件可以包含 tspan 物件。每個 tspan 可以指定它自己的樣式。預設情況下，每個 tspan 會從目前文字位置開始呈現。 同樣地，我可以使用 styles 改變文字外觀。我在這裡選擇字體、字體樣式（預設是「normal」）、以點計算的大小和顏色。 第 35 行1canvas.rect(249,249).styles(:stroke=&gt;'blue', :fill=&gt;'none') 就快完成了，我現在需要的是加上一個藍色邊框。（我現在要刪除方格紙背景，因為我們不再需要它。） 第 38 行1rvg.draw.write('duck.gif') 調用 draw 方法沒有佔用大量空間，只有 4 個字母，但是做了很多工作。draw 方法會遍歷我加到最外層 RVG 容器的所有圖形物件，並在背景繪製他們。繪製完成後，draw 將以 RMagick Image 物件的形式回傳圖像。你可以在圖像上使用任何 Image 類別方法，這裡我簡單地將圖像輸出為 GIF 檔案。 縮放圖片RVG 圖片真的可以縮放嗎？讓我們試試看。更改 RVG.new 調用讓圖片變成 4 倍大。邊長是 5 英吋： 1rvg = RVG.new(5.in, 5.in).viewbox(0,0,250,250) do |canvas| 不改變其他東西。再次執行程式，看看你得到什麼。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://calvertyang.github.io/tags/Ruby/"},{"name":"Rmagick","slug":"Rmagick","permalink":"https://calvertyang.github.io/tags/Rmagick/"}]},{"title":"如何在 Ubuntu 中為 vsftpd 設置虛擬帳號","slug":"how-to-setup-virtual-users-for-vsftpd-in-ubuntu","date":"2017-02-06T06:35:56.000Z","updated":"2018-05-21T07:58:00.000Z","comments":true,"path":"2017/02/06/how-to-setup-virtual-users-for-vsftpd-in-ubuntu/","link":"","permalink":"https://calvertyang.github.io/2017/02/06/how-to-setup-virtual-users-for-vsftpd-in-ubuntu/","excerpt":"","text":"以下是在 Ubunto 16.04 LTS 安裝 vsftpd 並設定虛擬帳號的步驟 安裝 vsftpd 12$ sudo apt-get update$ sudo apt-get install vsftpd 編輯設定檔 1$ sudo vim /etc/vsftpd.conf 以下設定僅供參考，可依實際使用情形調整（詳細設定及說明可查看 man vsftpd.conf） /etc/vsftpd.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102# 設定為 YES 表示 vsftpd 是以 standalone 的方式來啟動# 註：listen_ipv6 預設接受 IPv6 及 IPv4 連線，因此設定 listen_ipv6 為 YES 即可listen=NOlisten_ipv6=YES# 是否允許匿名者登入anonymous_enable=NO# 是否以實體用戶的方式登入 vsftpd 伺服器# 註：使用虛擬帳號時需要一個實體帳號local_enable=YES# 是否允許使用者上傳資料write_enable=YES# 建立新目錄與檔案的權限預設值local_umask=022# 若目錄下有 .message 檔案時，當使用者進入此目錄是否顯示該檔案的內容dirmessage_enable=YES# 是否使用本地時間use_localtime=YES# 是否將使用者上傳與下載檔案記錄起來xferlog_enable=YES# 是否支援主動式連線功能connect_from_port_20=YES# 使用者在指定秒數內都沒有命令動作時，是否強制離線idle_session_timeout=600# 是否將使用者限制在自己的家目錄之內chroot_local_user=YES# 用於 chroot 的空目錄路徑，此目錄不應被 ftp 使用者寫入secure_chroot_dir=/var/run/vsftpd/empty# pam 模組的名稱pam_service_name=vsftpd# RSA 加密的憑證檔案所在位置rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem# RSA 加密的私鑰檔案所在位置rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key# 是否啟動 SSL 支援ssl_enable=NO# 是否標示 vsftpd 使用 UTF-8 檔案系統utf8_filesystem=YES# 是否將目錄中的所有使用者和群組資訊顯示為 &quot;ftp&quot;hide_ids=YES# 限制同一時間可以同時連上 vsftpd 的用戶端數量max_clients=50# 限制同一時間同一個 IP 的最大連線數量max_per_ip=5# 是否支援被動式連線模式pasv_enable=YES# 設定被動式連線模式可用的連接埠範圍pasv_min_port=65400pasv_max_port=65410# 指定某個純文字檔作為使用者登入 vsftpd 伺服器時所顯示的歡迎訊息banner_file=/etc/vsftpd/banner_file# 是否同時產生 wu-ftpd 格式及 vsftpd 自有格式的記錄檔dual_log_enable=YES# vsftpd 格式記錄檔的所在位置vsftpd_log_file=/var/log/vsftpd.log# 是否支援 TCP Wrappers 的防火牆機制tcp_wrappers=YES# 這個選項允許根據各別用戶來覆蓋本設定檔中指定的任何設定user_config_dir=/etc/vsftpd/user_conf# 虛擬帳號是否將使用與本地用戶相同的權限virtual_use_local_privs=YES# 基於模板為每個虛擬帳號自動產生主目錄user_sub_token=$USER# 設定用戶家目錄local_root=/var/ftp/$USER# 是否允許用戶根目錄有寫入權限allow_writeable_chroot=YES# 若這個值設定為 YES 時，那麼任何實體帳號，均會被視為 guestguest_enable=YES# 指定訪客身份guest_username=vsftpd 設定虛擬帳號前仍須先建立一個實體帳號，虛擬帳號皆會使用此帳號登入 1$ sudo useradd --home /home/vsftpd --gid nogroup -m --shell /bin/false vsftpd 設定虛擬帳號由於要使用非實體帳號來登入，需另外建立帳號及密碼資料提供 vsftpd 作認證 1$ sudo vim /etc/vsftpd/virtual-user 建立帳密文件，格式為一行帳號、一行密碼 /etc/vsftpd/virtual-user1234user1user1_passworduser2user2_password 接著將帳密文件轉換成資料庫檔案（Berkeley DB 格式） 1$ sudo db_load -T -t hash -f /etc/vsftpd/virtual-user /etc/vsftpd/virtual-user.db 註：若出現 The program &#39;db_load&#39; is currently not installed. 訊息，則用以下指令安裝必要套件 1$ sudo apt-get install db-util 因設定檔內有使用了 user_config_dir 設定，可在此目錄內針對各使用者套用額外設定 1$ sudo mkdir /etc/vsftpd/user_conf 以下範例為限制 user2 僅擁有上傳權限 1$ sudo vim /etc/vsftpd/user_conf/user2 設定內容如下 /etc/vsftpd/user_conf/user21download_enable=NO 修改 vsftpd 認證設定 12$ sudo mv /etc/pam.d/vsftpd /etc/pam.d/vsftpd.old$ sudo vim /etc/pam.d/vsftpd 設定內容如下 /etc/pam.d/vsftpd12auth required pam_userdb.so db=/etc/vsftpd/virtual-useraccount required pam_userdb.so db=/etc/vsftpd/virtual-user 重啟服務 1$ sudo systemctl restart vsftpd 現在已可透過虛擬帳號登入囉！","categories":[{"name":"Server","slug":"Server","permalink":"https://calvertyang.github.io/categories/Server/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://calvertyang.github.io/tags/Linux/"}]},{"title":"在 Capistrano 自動化部署時使用 Ed25519 金鑰","slug":"capistrano-with-ed25519-keys","date":"2016-10-16T06:43:27.000Z","updated":"2018-05-21T07:58:00.000Z","comments":true,"path":"2016/10/16/capistrano-with-ed25519-keys/","link":"","permalink":"https://calvertyang.github.io/2016/10/16/capistrano-with-ed25519-keys/","excerpt":"","text":"原文：steigr — Capistrano with ED25519 keys 我最近將我的 Capistrano 自動化部署切換到了 Ed25519 金鑰。在正常運作之前我發現到一些奇怪的錯誤，部署使用者/代理程式無法登入到主機。在檢查 authorized_keys 檔案權限、本地 SSH 代理程式後，我開始用 Google 搜尋這個問題。結果是，net-ssh 版本小於 4 不支援 Ed25519 金鑰。 在 Gemfile 加入以下幾行，安裝所需的版本和 ruby gems 以啟用 Ed25519 金鑰支援： 1234gem 'bcrypt_pbkdf', group: :developmentgem 'rbnacl-libsodium', group: :developmentgem 'rbnacl', group: :developmentgem 'net-ssh', '~&gt; 4.0.0.beta', group: :development 確認 ruby 開發標頭檔，安裝到 rbnacl 及 rbnacl-libsodium 的 C 編譯器和相依開發標頭檔皆有原生擴充功能。 現在，deploy-agent@server&#39;s password: 訊息應該消失了。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://calvertyang.github.io/tags/Ruby-on-Rails/"},{"name":"Ed25519","slug":"Ed25519","permalink":"https://calvertyang.github.io/tags/Ed25519/"}]},{"title":"升級你的 SSH 金鑰！","slug":"upgrade_your_ssh_keys","date":"2016-10-05T05:53:00.000Z","updated":"2018-05-21T07:58:00.000Z","comments":true,"path":"2016/10/05/upgrade_your_ssh_keys/","link":"","permalink":"https://calvertyang.github.io/2016/10/05/upgrade_your_ssh_keys/","excerpt":"原文：Gert van Dijk — Upgrade your SSH keys! 無論你是軟體開發人員或系統管理員，我敢打賭你正在使用 SSH 金鑰。比起使用密碼來推送提交到 Github 或是管理 Unix 系統，透過 SSH 公開金鑰驗證是最佳的方法。然而，隨著時光飛逝，很多人都使用舊金鑰而沒有意識到需要產生一個新的來提供私密資料更好的保護。在這篇文章，我將示範如何平穩的轉換到 Ed25519 金鑰、你為什麼會想要它以及展示一些技巧和訣竅。 長話短說，使用 ssh-keygen -o -a 100 -t ed25519 來產生新的金鑰並指定一個高強度的通關密語，如果你需要平穩的轉換，請繼續往下閱讀。 我計劃發佈更多 SSH 技巧和訣竅，所以請關注我的部落格。這篇文章的重點是關於作為使用者公開金鑰驗證的 SSH 金鑰。 DSA 和 RSA 1024 位元已經廢止如果你已經使用預設選項建立金鑰超過四年，它可能不安全（RSA &lt; 2048 位元）。更糟的是，我最近看到了推特迷、同事和朋友還在使用 DSA 金鑰（OpenSSH 格式裡的 ssh-dss 類型）。那是一種類似於 RSA 的金鑰類型，但長度受限於 1024 位元且被推薦了很長一段時間。它顯然不安全，且被最近的 OpenSSH 版本以正當理由拒絕（請參見 7.0 更新日誌）。 難過的是，我看到關於如何重新啟用支援 DSA 金鑰的文章，而不是轉移到一種更安全的金鑰類型。真的，依照指示更改 PubkeyAcceptedKeyTypes 或 HostKeyAlgorithms 的設定是不明智的(host keys are for a later post)。取而代之，升級你的金鑰！","text":"原文：Gert van Dijk — Upgrade your SSH keys! 無論你是軟體開發人員或系統管理員，我敢打賭你正在使用 SSH 金鑰。比起使用密碼來推送提交到 Github 或是管理 Unix 系統，透過 SSH 公開金鑰驗證是最佳的方法。然而，隨著時光飛逝，很多人都使用舊金鑰而沒有意識到需要產生一個新的來提供私密資料更好的保護。在這篇文章，我將示範如何平穩的轉換到 Ed25519 金鑰、你為什麼會想要它以及展示一些技巧和訣竅。 長話短說，使用 ssh-keygen -o -a 100 -t ed25519 來產生新的金鑰並指定一個高強度的通關密語，如果你需要平穩的轉換，請繼續往下閱讀。 我計劃發佈更多 SSH 技巧和訣竅，所以請關注我的部落格。這篇文章的重點是關於作為使用者公開金鑰驗證的 SSH 金鑰。 DSA 和 RSA 1024 位元已經廢止如果你已經使用預設選項建立金鑰超過四年，它可能不安全（RSA &lt; 2048 位元）。更糟的是，我最近看到了推特迷、同事和朋友還在使用 DSA 金鑰（OpenSSH 格式裡的 ssh-dss 類型）。那是一種類似於 RSA 的金鑰類型，但長度受限於 1024 位元且被推薦了很長一段時間。它顯然不安全，且被最近的 OpenSSH 版本以正當理由拒絕（請參見 7.0 更新日誌）。 難過的是，我看到關於如何重新啟用支援 DSA 金鑰的文章，而不是轉移到一種更安全的金鑰類型。真的，依照指示更改 PubkeyAcceptedKeyTypes 或 HostKeyAlgorithms 的設定是不明智的(host keys are for a later post)。取而代之，升級你的金鑰！ 確定你目前的狀況列出你的所有金鑰： 1$ for keyfile in ~/.ssh/id_*; do ssh-keygen -l -f \"$&#123;keyfile&#125;\"; done | uniq DSA 或 RSA 1024 位元：不安全的 RSA 2048：建議更改 RSA 3072/4096：好極了，但是 Ed25519 有一些好處！ ECDSA：要看情況，建議更改 Ed25519：哇！太酷了！但是可以抵抗暴力破解嗎？ 平穩的轉換，我保證。你可能在想⋯「我用金鑰很久了，我不想現在到處更改。」很有道理，但你不需要到處更改！好消息是，你可以有多個金鑰在系統上，而且你的 SSH 客戶端會自動選擇正確的金鑰給正確的系統。 這是 SSH 協定的一部分，它可以提供多個金鑰，而伺服器會挑選一個，你的客戶端必須透過質詢證明來擁有私鑰。加入一些參數（-vvv）在 SSH 連線指令來觀看運作情形。此外，若有使用 SSH 金鑰管理器，你可以載入多個金鑰，它會識別所有金鑰。很簡單吧。 你會喜歡 Twisted Edwards curve最常見的金鑰類型是 RSA，也被稱為 ssh-rsa。它的相容性很好但也緩慢，若使用位元長度小於 2048 位元建立，具有潛在危險性。我們剛剛得知你的 SSH 客戶端可以處理多個金鑰，所以趕緊使用最新快速的橢圓曲線加密法，並享受它所提供非常緊湊的金鑰格式！ Ed25519 金鑰很短。非常短。如果你已經習慣了從系統複製多行字元到其它系統，你會對於它的大小感到驚喜。公鑰的長度僅有 68 個字元。驗證速度也比高強度的 RSA（3072+ 位元）更快。 Ed25519 金鑰可透過在 ssh-keygen 指令加上 -t ed25519 選項來產生。 Ed25519 是使用 Twisted Edwards curve 實作的 EdDSA。 增加對暴力破解密碼的抵抗當產生金鑰對時，會詢問你一個密碼短語來加密私鑰。若你將永遠失去私鑰，它應該保護他人冒充你，因為它會被密碼短語加密。要真正防止這種情況，應該確保防止密碼短語容易暴力破解。 OpenSSH 金鑰產生器提供了兩種選項，以抵抗暴力破解密碼：使用新的 OpenSSH 金鑰格式並增加金鑰推導函數的使用次數。它會降低解鎖金鑰的速度，但也防止了惡意使用者高效的暴力破解。在你的系統實驗推倒函數的使用次數，約從 100 次開始。在我的系統大約需要 1 秒來解密，且每天用金鑰管理器載入一次。在我看來，是可以接受的。 透過 ssh-keygen 使用 -o 選項並利用 bcrypt 所搭載的嶄新金鑰推導函數建立新的 RFC4716 金鑰格式。使用 -a &lt;num&gt; 選項指定推導函數的使用次數。 事實上，當建立一個 Ed25519 金鑰時，-o 選項看來是預設值。 OpenSSH 的手冊並沒有真正關於「新」格式的解釋。我發現 www.tedunangst.com 內的這篇文章非常有用：「新的 OpenSSH 金鑰格式及 bcrypt pbkdf」。 產生新的吸引人的 Ed25519 金鑰 提示：使用相同的密碼短語在你所有的金鑰類型來獲得更多便利性。（參見：知道多個金鑰的 SSH 客戶端。） 123456789$ ssh-keygen -o -a 100 -t ed25519Generating public/private ed25519 key pair.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/gert/.ssh/id_ed25519.Your public key has been saved in /home/gert/.ssh/id_ed25519.pub.The key fingerprint is:SHA256: [...] gert@hostnameThe key&apos;s randomart image is: [...] 注意那行「Your identification has been saved in /home/gert/.ssh/id_ed25519」。你現在的 RSA/DSA 金鑰都在相同的 ~/.ssh 資料夾內。如同其它金鑰，你可以複製在 ~/.ssh/id_ed25519.pub 的公鑰到目的主機以便驗證。 知道多個金鑰的 SSH 客戶端所有在預設路徑內的金鑰會被 SSH 客戶端應用程式自動偵測，包含透過 ssh-add 的 SSH 金鑰管理器。所以，如果你像以前一樣使用 ssh、scp、rsync 等應用程式⋯ 1$ ssh user@host 現在將提供多個公鑰給伺服器，伺服器會對匹配的項目要求證明所有權以便驗證。你日常使用的 ssh-add 指令不會改變，且自動找到 Ed25519 金鑰： 1234$ ssh-addEnter passphrase for /home/gert/.ssh/id_rsa:Identity added: /home/gert/.ssh/id_rsa (gert@hostname)Identity added: /home/gert/.ssh/id_ed25519 (gert@hostname) 它不僅找到這些金鑰，也載入它們僅透過輸入一次密碼短語（因為是相同的）！ 我們現在已經達成重要的目標。在沒有改變你任何的日常工作下，我們可以慢慢的更改原端主機上現有的設定來接受 Ed25519 金鑰。在此期間 RSA 金鑰仍然可運作。很棒對吧！？ 變更或設定密碼短語如果你害怕這會改變你的金鑰，別擔心。使用密碼短語加密的金鑰對私有部分，僅存在於你的本地機器上。只要你喜歡，可以經常改變它。這個建議是防止金鑰落入不法分子手中時遭到濫用。重複所有的金鑰檔案，以確保新的金鑰格式使用 100 次 bcrypt KDF： 1$ ssh-keygen -f ~/.ssh/id_rsa -p -o -a 100 升級你現在的 RSA 金鑰現在使用 Ed25519 在大多數情況下會（也應該）正常運作，但是舊式系統可能不支援。最好的應急辦法是使用高強度 RSA 金鑰對。 雖然 OpenSSH 客戶端支援多個 RSA 金鑰，它需要設定或命令列選項來指定路徑，所以相當容易出錯。取而代之，我建議你升級現有的金鑰，這樣做會讓事情變得簡單。根據你目前的 RSA 金鑰強度，你可以立即或悠閒的更新。 如果你仍然有弱的 RSA 金鑰，將它從標準路徑移出來並產生一個長度 4096 位元的新金鑰： 123$ mv ~/.ssh/id_rsa ~/.ssh/id_rsa_legacy$ mv ~/.ssh/id_rsa.pub ~/.ssh/id_rsa_legacy.pub$ ssh-keygen -t rsa -b 4096 -o -a 100 如果你使用金鑰管理器，手動將其指定到所有的金鑰： 1$ ssh-add ~/.ssh/id_rsa ~/.ssh/id_rsa_legacy ~/.ssh/id_ed25519 一旦你完成了所有遠端目標的更新，你可以回到便利的方式，讓它自動找到新的 RSA 和 Ed25519 金鑰；只要忽略金鑰檔案參數。 支援 Ed25519 的軟體自 OpenSSH 6.5 開始支援，在提供給工作站的 Unix 作業系統也已經採用。Ubuntu 14.04+、Debian 8+、CentOS/RedHat 7+ 等等都支援它了。（如果你有關於 Mac OS X 的詳細訊息，請留個訊息，無法快速搜尋到它）。某些軟體如自訂的桌面版金鑰管理器也許有幾個不喜歡新的金鑰的原因（見下文「我的 Gnome-keyring 不再運作」）。 順帶一提，Github 上也運作的很好。不幸的是，Launchpad 和 Gerrit 程式碼審查看來需要 RSA 金鑰。在 Windows 使用 PuTTY 嗎？見下文。 我的 Gnome-keyring 不再運作Gnome-keyring 被用在 Ubuntu Unity，無法讀取新的 RFC4716 格式金鑰，但回報成功。這是臭蟲。更多細節在我的 AskUbuntu Q&amp;A 文章。我建議停用 Gnome keyring 作為 SSH 金鑰管理器，改用普通的 OpenSSH 金鑰管理器來代替。 我在 Windows 使用 PuTTY抱歉，我沒有使用 PuTTY，但是首先要確定已經升級。根據願望清單項目建議，從 2015 年末版本開始支援 Ed25519。一般來說，我對於它實作的安全功能的速度不是太興奮。 這是最安全的 SSH 金鑰對？我們已經採取了一些重要措施，但是離最安全還很遠。在處理高保證環境時，如本文所述，因為在記憶體中保存著未加密的私鑰，我強烈反對使用金鑰。取而代之，使用安全硬體（智慧卡）來避免洩露金鑰甚至從記憶體轉存。它未涵蓋在此文章，主要是因為它需要你購買硬體，其次是因為依賴於設備的限制。一個很好的解決方案是利用可能已經內建在你電腦的可信賴平台模組，不過那肯定值得用其它文章來解說。","categories":[{"name":"Security","slug":"Security","permalink":"https://calvertyang.github.io/categories/Security/"}],"tags":[{"name":"SSH","slug":"SSH","permalink":"https://calvertyang.github.io/tags/SSH/"},{"name":"Ed25519","slug":"Ed25519","permalink":"https://calvertyang.github.io/tags/Ed25519/"}]},{"title":"使用 Mailboxer 實作站內信系統","slug":"use-the-mailboxer-to-implement-messaging-systems","date":"2015-05-19T17:34:00.000Z","updated":"2018-05-21T07:58:26.000Z","comments":true,"path":"2015/05/20/use-the-mailboxer-to-implement-messaging-systems/","link":"","permalink":"https://calvertyang.github.io/2015/05/20/use-the-mailboxer-to-implement-messaging-systems/","excerpt":"Mailboxer 是一個 Rails gem，為 social_stream 框架用來建立社群網路的一部分。它是具備一些通用方法的訊息系統，允許任何 model 擔任傳遞訊息的角色。 使用 Mailboxer，你可以與一或多個收件人建立對話（訊息會被歸納到寄件匣、收件匣及垃圾桶）並透過電子郵件發送通知。它甚至可以在不同 model 間發送訊息和附件！唯一的缺點是缺乏文件，所以我希望這邊文章是有幫助的。 我們要討論的範例程式為： 使用 Devise 做基本身份驗證 使用 Gravatar 讓使用者管理頭像 整合 Mailboxer 使用圖形介面來建立／回覆對話（使用 Bootstrap 樣式及 Chosen jQuery 插件） 顯示資料夾，並允許在它們之間輕鬆切換 允許將對話標示為已讀、放到垃圾桶或還原，也可以清理垃圾桶。 設定電子郵件通知 此範例將使用 Rails 4，但幾乎相同的解決方案也可以實作於 Rails 3.2（Mailboxer 不再支援 3.1 版）。 原始碼可以在 Github 找到。","text":"Mailboxer 是一個 Rails gem，為 social_stream 框架用來建立社群網路的一部分。它是具備一些通用方法的訊息系統，允許任何 model 擔任傳遞訊息的角色。 使用 Mailboxer，你可以與一或多個收件人建立對話（訊息會被歸納到寄件匣、收件匣及垃圾桶）並透過電子郵件發送通知。它甚至可以在不同 model 間發送訊息和附件！唯一的缺點是缺乏文件，所以我希望這邊文章是有幫助的。 我們要討論的範例程式為： 使用 Devise 做基本身份驗證 使用 Gravatar 讓使用者管理頭像 整合 Mailboxer 使用圖形介面來建立／回覆對話（使用 Bootstrap 樣式及 Chosen jQuery 插件） 顯示資料夾，並允許在它們之間輕鬆切換 允許將對話標示為已讀、放到垃圾桶或還原，也可以清理垃圾桶。 設定電子郵件通知 此範例將使用 Rails 4，但幾乎相同的解決方案也可以實作於 Rails 3.2（Mailboxer 不再支援 3.1 版）。 原始碼可以在 Github 找到。 前置準備假設我們要建立內部的私人訊息系統提供同事討論不同主旨。這個系統應該允許使用者與無數個收件人建立對話、提供通知系統並允許刪除舊的對話。 建立名為 Synergy 不含預設測試套件的 Rails 應用程式：1$ rails new Synergy -T 在你的 Gemfile 加入以下的 Gem（我會使用 Bootstrap，但你可以使用任何其它的 CSS 框架、自行設計或者跳過美化網站的步驟）： Gemfile1234[...]gem 'bootstrap-sass'gem 'kaminari'[...] 執行 12$ bundle install$ rails generate kaminari:views bootstrap3 然後加入 Bootstrap 檔案： app/assets/stylesheets/application.scss12@import \"bootstrap-sprockets\";@import \"bootstrap\"; app/assets/javascripts/application.js1//= require bootstrap-sprockets 接著調整 layout： app/views/layouts/application.html.erb123456789101112131415[...]&lt;div class=\"container\"&gt; &lt;% flash.each do |key, value| %&gt; &lt;div class=\"alert alert-&lt;%= key %&gt;\"&gt; &lt;%= value %&gt; &lt;/div&gt; &lt;% end %&gt; &lt;div class=\"page-header\"&gt; &lt;h1&gt;&lt;%= yield :page_header %&gt;&lt;/h1&gt; &lt;/div&gt; &lt;%= yield %&gt;&lt;/div&gt;[...] 讓我們新增 helper 來方便呈現頁面標題： app/helpers/application_helper.rb12345[...]def page_header(text) content_for(:page_header) &#123; text.to_s &#125;end[...] 身份驗證實作訊息功能之前，我們需要一個 model 來傳遞訊息。建立 User model： 12$ rails g model User name:string$ rake db:migrate 你可以使用任何類型的身份驗證，但我喜歡 Devise。Devise 的基本設定非常簡單，並有大量文件協助您進一步自訂設定。 加入新的 gem： Gemfile123[...]gem 'devise'[...] 並安裝它： 1$ bundle install 現在，我們可以利用 Devise 的產生器來幫我們做一些工作： 1$ rails generate devise:install 請務必閱讀安裝後的訊息來完成一些額外的步驟。具體來說，你需要為 development 和 production 調整 config.action_mailer.default_url_options 設定，因為它會被用來發送郵件給使用者（例如，幫助他們恢復遺忘的密碼）。請注意，電子郵件在 development 時不會發送，除非你在 config/environments/development.rb 設定 config.action_mailer.perform_deliveries = true。 這裡有關於如何設定 ActionMailer 的一些範例。 當你準備好後，執行以下指令使用 Devise 建立 User model： 12$ rails generate devise User$ rake db:migrate 你可能想要在套用變更前檢查指令產生的遷移檔，並加入更多欄位到資料表（啟用 Confirmable 或 Lockable 模組）。你還需要調整 model 內相應的設定。 最後，執行以下指令來複製 Devise 的 views 到你的專案，以便稍作修改： 1$ rails generate devise:views 要能夠讓使用者變更他們的名字，所以新增一個欄位到註冊表單： app/views/devise/registrations/new.html.erb123456[...]&lt;div class=\"field\"&gt; &lt;%= f.label :name %&gt;&lt;br /&gt; &lt;%= f.text_field :name %&gt;&lt;/div&gt;[...] 同樣的將此欄位加入 app/views/devise/registrations/edit.html.erb（或者將它重構為 partial），讓使用者可以在註冊時提供名字，並在稍後編輯它。 由於 Rails 4 引進了新的保護機制 Strong Parameters，需要設定允許 :name 參數可以傳遞： app/controllers/application_controller.rb12345678910[...]before_action :configure_permitted_parameters, if: :devise_controller?protected def configure_permitted_parameters devise_parameter_sanitizer.for(:sign_up) &lt;&lt; :name devise_parameter_sanitizer.for(:account_update) &lt;&lt; :name end[...] devise_controller?方法是由 Devise 提供。在這裡，我們允許建立及編輯帳號時傳遞 :name 屬性。如果你忘了這樣做，使用者將無法設定自己的名字。 此時，你也可以修改 view 的樣式。我不會涵蓋這一步驟，因為它不是太難且高度依賴於你的設定（無論你是不是使用 Bootstrap）。如果你決定使用 Bootstrap，Devise 所產生的訊息將不會有樣式。為了解決這個問題，使用 SASS @extend 方法，如下： app/assets/stylesheets/application.scss12345678[...].alert-notice &#123; @extend .alert-success;&#125;.alert-alert &#123; @extend .alert-warning;&#125; 整合 Mailboxer太好了，我們準備進行主要的任務－整合及設定 Mailboxer。 首先，加入新的 gem： Gemfile123[...]gem 'mailboxer'[...] 並安裝它： 1$ bundle install 產生和套用所有必要的遷移並建立初始化檔案： 12$ rails generate mailboxer:install$ rake db:migrate 查看 config/initializers/mailboxer.rb 檔案看你能修改哪些選項。現在，先維持檔案內的設定，稍後我們會設定寄送電子郵件通知。 需要稍作調整 model 來配置 Mailboxer 的功能： app/models/user.rb123[...]acts_as_messageable[...] 顯示對話如指南所建議，為 Mailboxer 建立圖形介面的最佳方法是建立兩個 controller：一個用於訊息，一個用於對話。獨立的訊息會被歸類為對話。稍後，你會看到對話可以是不同類型。 首先建立對話 controller： 1$ rails generate controller conversations app/controllers/conversations_controller.rb1234567891011121314class ConversationsController &lt; ApplicationController before_action :authenticate_user! before_action :get_mailbox def index @conversations = @mailbox.inbox.page(params[:page]) end private def get_mailbox @mailbox ||= current_user.mailbox endend 每個使用者都有自己的信箱，反過來說，又分為收件匣、寄件匣及垃圾桶。目前，我們先關注在收件匣就好。 authenticate_user!是 Devise 的一部分。我們只希望通過驗證的使用者存取應用程式，因此它設定為 before_action。如果使用者沒有通過驗證，他將被導向到登入頁面。 如你所見，我也使用了 kaminari 所提供的 page 方法。 新增路由（其它 controller 方法很快就會加入）： config/routes.rb123[...]resources :conversations, only: [:index, :show, :destroy][...] 並修改 view： app/views/conversations/index.html.erb1234567&lt;% page_header \"Your Conversations\" %&gt;&lt;ul class=\"list-group\"&gt; &lt;%= render partial: 'conversations/conversation', collection: @conversations %&gt;&lt;/ul&gt;&lt;%= paginate @conversations %&gt; page_header 是我們先前建立的 helper 方法。paginate 會顯示分頁控制項（只有超過一頁時會顯示）。 我們必須指定 partial 參數，因為 @conversations 是 Mailboxer::Conversation::ActiveRecord_Relation 的一個實例，因此 Rails 預設會在 mailboxer/conversations 目錄尋找 _conversation。 新增 partial： app/views/conversations/_conversation.html.erb123&lt;li class=\"list-group-item clearfix\"&gt; &lt;%= link_to conversation.subject, conversation_path(conversation) %&gt;&lt;/li&gt; 每個對話都有一個主旨和一些將被顯示於頁面上的訊息。 新增選單到 layout： app/views/layouts/application.html.erb123456789101112131415161718[...]&lt;nav class=\"navbar navbar-inverse\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;%= link_to 'Synergy', root_path, class: 'navbar-brand' %&gt; &lt;/div&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;% if user_signed_in? %&gt; &lt;li&gt;&lt;%= link_to 'Edit Profile', edit_user_registration_path %&gt;&lt;/li&gt; &lt;li&gt;&lt;%= link_to 'Your Conversations', conversations_path %&gt;&lt;/li&gt; &lt;li&gt;&lt;%= link_to 'Log Out', destroy_user_session_path, method: :delete %&gt;&lt;/li&gt; &lt;% else %&gt; &lt;li&gt;&lt;%= link_to 'Log In', new_user_session_path %&gt;&lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt;[...] user_signed_in? 方法以及大部分的路由都是由 Devise 提供。 接下來是 show 動作： app/controllers/conversations_controller.rb12345678910111213141516171819202122class ConversationsController &lt; ApplicationController before_action :authenticate_user! before_action :get_mailbox before_action :get_conversation, except: [:index] def index @conversations = @mailbox.inbox.page(params[:page]) end def show end private def get_mailbox @mailbox ||= current_user.mailbox end def get_conversation @conversation ||= @mailbox.conversations.find(params[:id]) endend 你可能知道，當查詢不到資料時會拋出例外錯誤。這就是我們想要的，但是應該要處理例外錯誤。為了簡單起見，我們使用 rescue_from 方法： app/controllers/application_controller.rb12345678910[...]rescue_from ActiveRecord::RecordNotFound do flash[:warning] = 'Resource not found.' redirect_back_or root_pathenddef redirect_back_or(path) redirect_to request.referer || pathend[...] 我們只是將使用者導向並顯示警告訊息。如果 referer 欄位沒有設定（例如，使用者安裝了插件清除此欄位），他們會被導向到 root_path。 接著，編輯 view： app/views/conversations/show.html.erb1234567891011121314151617&lt;% page_header \"Conversation\" %&gt;&lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt;&lt;%= @conversation.subject %&gt;&lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;div class=\"messages\"&gt; &lt;% @conversation.receipts_for(current_user).each do |receipt| %&gt; &lt;% message = receipt.message %&gt; &lt;%= message.sender.name %&gt; says at &lt;%= message.created_at.strftime(\"%F %T\") %&gt; &lt;%= message.body %&gt; &lt;% end %&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 我們呈現了每個訊息的寄件者的名字、建立時間及訊息內容。讓我們來修改一下 .messages 容器的樣式，讓它不要變得太高： app/assets/stylesheets/application.scss1234567[...].messages &#123; max-height: 400px; overflow-y: auto; margin-bottom: 1em; margin-top: 1em;&#125; 不錯，一些基本的 view 都已經存在了。然而，我們還缺乏了一些重要的東西： 使用者應該知道在和誰對話 使用者需要可以建立新的對話 使用者需要可以回覆對話 寄件匣和垃圾桶應該顯示在對話頁面 使用者應該能將對話標示為已讀 顯示使用者頭像雖然這和 Mailboxer 無關，我認為顯示頭像會讓我們的應用程式看起來更漂亮。然而，允許使用者直接上傳頭像到應用程式有點小題大作，讓我們使用 Gravatar 並透過 gravatar_image_tag 整合到 Rails。 加入新的 gem： Gemfile123[...]gem 'gravatar_image_tag'[...] 並執行 1$ bundle install 同樣的，新增 helper 來方便呈現頭像： app/helpers/application_helper.rb12345[...]def gravatar_for(user, size = 30, title = user.name) image_tag gravatar_image_url(user.email, size: size), title: title, class: 'img-rounded'end[...] 建立單獨的 partial 來呈現對話內收件人的頭像（除了目前的使用者）： app/views/conversations/_participants.html.erb12345&lt;% conversation.participants.each do |participant| %&gt; &lt;% unless participant == current_user %&gt; &lt;%= gravatar_for participant %&gt; &lt;% end %&gt;&lt;% end %&gt; 編輯以下的 view： app/views/conversations/show.html.erb1234567891011121314151617181920212223242526272829&lt;% page_header \"Conversation\" %&gt;&lt;p&gt;Chatting with &lt;%= render 'conversations/participants', conversation: @conversation %&gt;&lt;/p&gt;&lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt;&lt;%= @conversation.subject %&gt;&lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;div class=\"messages\"&gt; &lt;% @conversation.receipts_for(current_user).each do |receipt| %&gt; &lt;div class=\"media\"&gt; &lt;% message = receipt.message %&gt; &lt;div class=\"media-left\"&gt; &lt;%= gravatar_for message.sender, 45, message.sender.name %&gt; &lt;/div&gt; &lt;div class=\"media-body\"&gt; &lt;h6 class=\"media-heading\"&gt;&lt;%= message.sender.name %&gt; says at &lt;%= message.created_at.strftime(\"%F %T\") %&gt; &lt;/h6&gt; &lt;%= message.body %&gt; &lt;/div&gt; &lt;/div&gt; &lt;% end %&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; app/views/conversations/_conversation.html.erb12345&lt;li class=\"list-group-item clearfix\"&gt; &lt;%= link_to conversation.subject, conversation_path(conversation) %&gt; &lt;p&gt;&lt;%= render 'conversations/participants', conversation: conversation %&gt;&lt;/p&gt;&lt;/li&gt; 顯示對話內最後一則訊息及它的建立時間： app/views/conversations/_conversation.html.erb12345678910&lt;li class=\"list-group-item clearfix\"&gt; &lt;%= link_to conversation.subject, conversation_path(conversation) %&gt; &lt;p&gt;&lt;%= render 'conversations/participants', conversation: conversation %&gt;&lt;/p&gt; &lt;p&gt; &lt;%= conversation.last_message.body %&gt; &lt;small&gt;(&lt;span class=\"text-muted\"&gt;&lt;%= conversation.last_message.created_at.strftime(\"%F %T\") %&gt;&lt;/span&gt;)&lt;/small&gt; &lt;/p&gt;&lt;/li&gt; 我們已經完成頭像了。是時候讓使用者建立新的對話。 建立對話建立對話實際上意味著建立帶有主旨的新訊息（雖然這是可選的）。這表示需要新的 controller： 1$ rails generate controller messages app/controllers/messages_controller.rb12345678910111213class MessagesController &lt; ApplicationController before_action :authenticate_user! def new end def create recipients = User.where(id: params['recipients']) conversation = current_user.send_message(recipients, params[:message][:body], params[:message][:subject]).conversation flash[:success] = \"Message has been sent!\" redirect_to conversation_path(conversation) endend 在 create 動作內，尋找收件人（存放在 params[‘recipients’] 中）並利用 Mailboxer 的 send_message 方法，傳入收件人、訊息和主旨。稍後，我們將啟用電子郵件通知，以便讓使用者知道收到新訊息了。 現在來編輯 view： app/views/messages/new.html.erb1234567891011121314151617181920&lt;% page_header \"Start Conversation\" %&gt;&lt;%= form_tag messages_path, method: :post do %&gt; &lt;div class=\"form-group\"&gt; &lt;%= label_tag 'message[subject]', 'Subject' %&gt; &lt;%= text_field_tag 'message[subject]', nil, class: 'form-control', required: true %&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;%= label_tag 'message[body]', 'Message' %&gt; &lt;%= text_area_tag 'message[body]', nil, cols: 3, class: 'form-control', required: true %&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;%= label_tag 'recipients', 'Choose recipients' %&gt; &lt;%= select_tag 'recipients', recipients_options, multiple: true, class: 'form-control' %&gt; &lt;/div&gt; &lt;%= submit_tag 'Send', class: 'btn btn-primary' %&gt;&lt;% end %&gt; recipients_options 是 helper 方法，我們需要建立它： app/helpers/messages_helper.rb12345module MessagesHelper def recipients_options options_for_select(User.all.map &#123; |user| [user.name, user.id] &#125;) endend 別忘了設定路由： config/routes.rb123[...]resources :messages, only: [:new, :create][...] 接著在 conversations#index 頁面顯示「Start conversation」連結： app/views/conversations/index.html.erb1234&lt;% page_header \"Your Conversations\" %&gt;&lt;p&gt;&lt;%= link_to 'Start conversation', new_message_path, class: 'btn btn-lg btn-primary' %&gt;&lt;/p&gt;[...] 技術上來說，一切都已經就緒可以發佈你的第一則訊息。你可以傳遞給自己或是註冊另一個帳號來模擬有兩個使用者的情況。 然而，選擇收件人不是很方便。目前，已經呈現了基本的選擇欄位，但如果有很多使用者時，要在列表中找到某個人是很麻煩的。我們可以使用 Chosen 來強化這個欄位，它是讓下拉選單更加人性化的一個 jQuery 插件。有個 chosen-rails gem 可以輕鬆的將此插件整合到 Rails 應用程式。 將這個 gem 加到 Gemfile： Gemfile123[...]gem 'chosen-rails'[...] 我也指定了 sass-rails 與 coffee-rails 的版本，因為有與 application.scss 檔案相關的 bug： Gemfile12345[...]gem 'sass-rails', '~&gt; 4.0.5'gem 'coffee-rails', '~&gt; 4.1.0'gem 'jquery-turbolinks'[...] 同時也使用了 jquery-turbolinks gem，當使用 Turbolinks 時可恢復預設的 jQuery page load 事件。 別忘了執行 1$ bundle install 然後將 Chosen 加到 application.js 和 application.scss： app/assets/javascripts/application.js1234[...]//= require jquery.turbolinks//= require chosen-jquery[...] app/assets/stylesheets/application.scss123[...]@import \"chosen\";[...] 接著將 .chosen-it 類別加到我們的 select 標籤： app/views/messages/new.html.erb123456[...]&lt;div class=\"form-group\"&gt; &lt;%= label_tag 'recipients', 'Choose recipients' %&gt; &lt;%= select_tag 'recipients', recipients_options, multiple: true, class: 'form-control chosen-it' %&gt;&lt;/div&gt;[...] 並將所有此類別的元素都裝上 Chosen 的功能： app/assets/javascripts/messages.coffee12$ -&gt; $('.chosen-it').chosen() 現在重載伺服器，到 conversations/new 頁面，會發現嶄新的 select 標籤。這用起來更加方便，不是嗎？ 我們可以更進一步的在 select 標籤內使用者名字前顯示頭像。有個 Chosen 的擴充插件 Image-Select。只要將 ImageSelect.jquery.js 和 ImageSelect.css 放到你的專案並分別在 application.js 和 application.scss 引入。然後，稍微修改 helper 方法： app/helpers/messages_helper.rb12345module MessagesHelper def recipients_options options_for_select(User.all.map &#123; |user| [user.name, user.id, &#123; 'data-img-src' =&gt; gravatar_image_url(user.email, size: 50) &#125;] &#125;) endend 接著再重載伺服器並確認成果。非常棒！ 回覆對話現在，使用者可以建立對話，但是沒有辦法回覆！為了解決這個問題，我們需要另一個表單及 controller 方法，以及新的路由： app/views/conversations/show.html.erb1234567[...]&lt;%= form_tag reply_conversation_path(@conversation), method: :post do %&gt; &lt;div class=\"form-group\"&gt; &lt;%= text_area_tag 'body', nil, cols: 3, class: 'form-control', placeholder: 'Type something...', required: true %&gt; &lt;/div&gt; &lt;%= submit_tag \"Send Message\", class: 'btn btn-primary' %&gt;&lt;% end %&gt; 註：你也可以加入另一個文字欄位讓使用者新增主旨。 app/controllers/conversations_controller.rb1234567[...]def reply current_user.reply_to_conversation(@conversation, params[:body]) flash[:success] = 'Reply sent' redirect_to conversation_path(@conversation)end[...] Mailboxer 的 reply_to_conversation 方法讓回覆對話變得很輕鬆。它接受對話的回覆訊息、主旨（可選）及些許其他的參數。需要注意的是，如果對話被移動到垃圾桶（我們將在稍後處理），預設會被復原。可以去看看原始碼取得更多資訊。 config/routes.rb1234567[...]resources :conversations, only: [:index, :show, :destroy] do member do post :reply endend[...] 很好，基本的聊天系統已可啟動並執行！ 實作寄件匣及垃圾桶目前，我們只有顯示使用者的收件匣。然而，顯示寄件匣與垃圾桶是個好主意。 也許要決定該顯示哪個資料夾最簡單的方式是使用 GET 參數，所以讓我們來調整 controller： app/controllers/conversations_controller.rb1234567891011121314151617181920212223242526272829[...]before_action :get_box, only: [:inbox]def index if @box.eql? \"inbox\" @conversations = @mailbox.inbox elsif @box.eql? \"sent\" @conversations = @mailbox.sentbox else @conversations = @mailbox.trash end @conversations = @conversations.page(params[:page])end[...]private[...] def get_box if params[:box].blank? or ![\"inbox\", \"sent\", \"trash\"].include?(params[:box]) params[:box] = 'inbox' end @box = params[:box] end[...] 新的私有方法 get_box 用來取得所需的資料夾。 在 view 的地方，如果你使用的是 Bootstrap，我建議使用垂直導覽列來呈現資料夾。此外，目前所在的資料夾應該被高亮。建立 helper 方法來處理這個： app/helpers/conversations_helper.rb1234567module ConversationsHelper def mailbox_section(title, current_box, opts = &#123;&#125;) opts[:class] = opts.fetch(:class, '') opts[:class] += ' active' if title.downcase == current_box content_tag :li, link_to(title.capitalize, conversations_path(box: title.downcase)), opts endend 這個方法需要連結的標題（也會被用於 GET 的參數）、目前開啟的資料夾及要直接傳遞給 content_tag 方法的 hash 格式選項。然後檢查 opts 是否已有類別的屬性。沒有的話就設為空字串，並在目前的資料夾的類別附加 active 類別。 修改 view： app/views/conversations/index.html.erb123456789101112131415161718192021&lt;% page_header \"Your Conversations\" %&gt;&lt;p&gt;&lt;%= link_to 'Start conversation', new_message_path, class: 'btn btn-lg btn-primary' %&gt;&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-sm-3\"&gt; &lt;ul class=\"nav nav-pills nav-stacked\"&gt; &lt;%= mailbox_section 'inbox', @box %&gt; &lt;%= mailbox_section 'sent', @box %&gt; &lt;%= mailbox_section 'trash', @box %&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"col-sm-9\"&gt; &lt;ul class=\"list-group\"&gt; &lt;%= render partial: 'conversations/conversation', collection: @conversations %&gt; &lt;/ul&gt; &lt;%= paginate @conversations %&gt; &lt;/div&gt;&lt;/div&gt; 下一步是在每個尚未丟棄到垃圾桶的對話加入「Move to trash」按鈕。對於丟棄在垃圾桶的對話，應該顯示「Restore」按鈕。 app/views/conversations/_conversation.html.erb123456789101112131415161718&lt;li class=\"list-group-item clearfix\"&gt; &lt;%= link_to conversation.subject, conversation_path(conversation) %&gt; &lt;div class=\"btn-group-vertical pull-right\"&gt; &lt;% if conversation.is_trashed?(current_user) %&gt; &lt;%= link_to 'Restore', restore_conversation_path(conversation), class: 'btn btn-xs btn-info', method: :post %&gt; &lt;% else %&gt; &lt;%= link_to 'Move to trash', conversation_path(conversation), class: 'btn btn-xs btn-danger', method: :delete, data: &#123; confirm: 'Are you sure?' &#125; %&gt; &lt;% end %&gt; &lt;/div&gt; &lt;p&gt;&lt;%= render 'conversations/participants', conversation: conversation %&gt;&lt;/p&gt; &lt;p&gt; &lt;%= conversation.last_message.body %&gt; &lt;small&gt;(&lt;span class=\"text-muted\"&gt;&lt;%= conversation.last_message.created_at.strftime(\"%F %T\") %&gt;&lt;/span&gt;)&lt;/small&gt; &lt;/p&gt;&lt;/li&gt; 增加相應的方法： app/controllers/conversations_controller.rb12345678910111213[...]def destroy @conversation.move_to_trash(current_user) flash[:success] = 'The conversation was moved to trash.' redirect_to conversations_pathenddef restore @conversation.untrash(current_user) flash[:success] = 'The conversation was restored.' redirect_to conversations_pathend[...] move_to_trash 和 untrash 是由 Mailboxer 提供的兩個方法，從命名就能知道用途。 修改路由： config/routes.rb12345678[...]resources :conversations, only: [:index, :show, :destroy] do member do post :reply post :restore endend[...] 那麼「Empty trash」按鈕呢？很簡單： app/views/conversations/index.html.erb12345678910111213[...]&lt;div class=\"col-sm-9\"&gt; &lt;% if @box == 'trash' %&gt; &lt;p&gt;&lt;%= link_to 'Empty trash', empty_trash_conversations_path, class: 'btn btn-danger', method: :delete, data: &#123; confirm: 'Are you sure?' &#125; %&gt;&lt;/p&gt; &lt;% end %&gt; &lt;ul class=\"list-group\"&gt; &lt;%= render partial: 'conversations/conversation', collection: @conversations %&gt; &lt;/ul&gt; &lt;%= paginate @conversations %&gt;&lt;/div&gt;[...] 以及相應的方法： app/controllers/conversations_controller.rb1234567891011[...]before_action :get_conversation, except: [:index, :empty_trash][...]def empty_trash @mailbox.trash.each do |conversation| conversation.receipts_for(current_user).update_all(deleted: true) end flash[:success] = 'Your trash was cleaned!' redirect_to conversations_pathend[...] 並增加路由： config/routes.rb1234567891011[...]resources :conversations, only: [:index, :show, :destroy] do member do post :reply post :restore end collection do delete :empty_trash endend[...] 將對話標示為已讀讓我們允許使用者將對話標示為已讀。為了實作它，我們需要另外的方法、路由及按鈕： app/views/conversations/_conversation.html.erb12345678910111213[...]&lt;div class=\"btn-group-vertical pull-right\"&gt; &lt;% if conversation.is_trashed?(current_user) %&gt; &lt;%= link_to 'Restore', restore_conversation_path(conversation), class: 'btn btn-xs btn-info', method: :post %&gt; &lt;% else %&gt; &lt;%= link_to 'Move to trash', conversation_path(conversation), class: 'btn btn-xs btn-danger', method: :delete, data: &#123; confirm: 'Are you sure?' &#125; %&gt; &lt;% if conversation.is_unread?(current_user) %&gt; &lt;%= link_to 'Mark as read', mark_as_read_conversation_path(conversation), class: 'btn btn-xs btn-info', method: :post %&gt; &lt;% end %&gt; &lt;% end %&gt;&lt;/div&gt;[...] 這邊使用的 is_unread? 方法需要指定使用者。還有另一個相反的方法 is_read?。 app/controllers/conversations_controller.rb1234567[...]def mark_as_read @conversation.mark_as_read(current_user) flash[:success] = 'The conversation was marked as read.' redirect_to conversations_pathend[...] 最後，修改路由： config/routes.rb123456789101112[...]resources :conversations, only: [:index, :show, :destroy] do member do post :reply post :restore post :mark_as_read end collection do delete :empty_trash endend[...] 大功告成！ 註：你還可以優化 show 動作，讓對話被開啟時自動標示為已讀！ 電子郵件通知記住，Mailboxer 可以在使用者收到訊息時寄送電子郵件通知。此功能在 initializer 中啟用： config/initializers/mailboxer.rb12345678910111213Mailboxer.setup do |config| #Configures if you application uses or not email sending for Notifications and Messages config.uses_emails = true #Configures the default from for emails sent for Messages and Notifications config.default_from = \"no-reply@mailboxer.com\" #Configures the methods needed by mailboxer config.email_method = :mailboxer_email config.name_method = :name [...]end config.email_method 和 config.name_method 告訴 Mailboxer 如何分別取得電子郵件和名字。name 已經存在於我們的 User model，但是沒有 mailboxer_email。你可以嘗試改變這個值為 Devise 所提供的 email 方法，但是這會導致一個錯誤，因為 Mailboxer 會傳遞參數給它，包含收到的訊息。所以有兩個選擇，一個是重新定義此方法，或是建立一個新的。我會選擇第二個選項： app/models/user.rb12345[...]def mailboxer_email(object) emailend[...] 電子郵件通知已經啟用了（請確定有依照先前的指示設定 ActionMailer。另外，不要忘記，電子郵件在 development 時預設是不會發送的。） 補充：如何新增按鈕來寄送訊息給指定使用者這個功能可以很容易地完成！指定的使用者應該從「Start conversation」頁面上的下拉選單自動選取。我認為，最好的方式就是使用 GET 參數帶入指定的使用者。修改 MessagesController 如下： app/controllers/messages_controller.rb12345[...]def new @chosen_recipient = User.find_by(id: params[:to].to_i) if params[:to]end[...] 現在，@chosen_recipient 會有使用者的資料或是 nil。 接著修改 view： app/views/messages/new.html.erb123456[...]&lt;div class=\"form-group\"&gt; &lt;%= label_tag 'recipients', 'Choose recipients' %&gt; &lt;%= select_tag 'recipients', recipients_options(@chosen_recipient), multiple: true, class: 'form-control chosen-it' %&gt;&lt;/div&gt;[...] 我們傳遞了 @chosen_recipient 給 helper 方法。 app/helpers/messages_helper.rb12345[...]def recipients_options(chosen_recipient = nil) options_for_select(User.all.map &#123; |user| [user.name, user.id, &#123; 'data-img-src' =&gt; gravatar_image_url(user.email, size: 50) &#125;] &#125;, chosen_recipient.nil? ? nil : chosen_recipient.id)end[...] 這是更新後的 recipients_options helper 方法。將預設選取的選項帶入 options_for_select 的第二個參數即可！ 基本上，這樣就完成了！為了示範如何運作，新增一個使用者清單頁面並於每個使用者後方加上「Send message」按鈕。 config/routes.rb123[...]resources :users, only: [:index][...] 建立使用者 controller： 1$ rails generate controller users app/controllers/users_controller.rb12345class UsersController &lt; ApplicationController def index @users = User.order('created_at DESC').page(params[:page]) endend app/views/users/index.html.erb1234567891011121314&lt;% page_header \"Users\" %&gt;&lt;ul&gt; &lt;% @users.each do |user| %&gt; &lt;li&gt; &lt;strong&gt;&lt;%= user.name %&gt;&lt;/strong&gt; &lt;% unless current_user == user %&gt; &lt;%= link_to 'Send message', new_message_path(to: user.id), class: 'btn btn-default btn-sm' %&gt; &lt;% end %&gt; &lt;/li&gt; &lt;% end %&gt;&lt;/ul&gt;&lt;%= paginate @users %&gt; 調整 layout 加入使用者清單頁面連結： app/views/layouts/application.html.erb123[...]&lt;li&gt;&lt;%= link_to 'Users', users_path %&gt;&lt;/li&gt;[...] 到此，這個功能就完成囉！ 結論呼！討論了相當多，對吧？我們探討了 Mailboxer 的基本功能，包含了訊息、不同類型的對話、管理對話以及設定電子郵件通知。我們也整合了 Devise 到此應用程式並利用 Gravatar 讓頁面看起來更美觀。 希望本文對你有幫助。順帶一提，你可能會對 Mailboxer 維基上的這個頁面以及介紹 Mailboxer 基本功能的應用程式範例有興趣。 資料來源：Messaging with Rails and Mailboxer","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://calvertyang.github.io/tags/Ruby-on-Rails/"}]},{"title":"了解 GitHub Flow","slug":"understanding-the-github-flow","date":"2014-09-21T06:51:00.000Z","updated":"2018-05-21T07:58:00.000Z","comments":true,"path":"2014/09/21/understanding-the-github-flow/","link":"","permalink":"https://calvertyang.github.io/2014/09/21/understanding-the-github-flow/","excerpt":"","text":"原文：GitHub — Understanding the GitHub Flow GitHub Flow 是一個基於分支的輕量化工作流程，幫助團隊及專案定期的進行部署。 在進行一項專案時，任何時候你可能會有一堆不同功能或想法，有些已經準備好了，而另有些則沒有。分支的存在是為了幫助你管理這些工作流程。 當你在專案建立一個分支，代表建立了一個環境來測試你的新想法。在分支所做的修改不會影響 master 分支，所以可以自由的嘗試並提交修改。你可以放心，分支不會被合併，直到準備將它交由某位協同者來檢查。 進階提示整個 GitHub Flow 是基於分支，它是 Git 的一個核心概念。這裡只有一個規則：任何在 master 分支中的都是可部署的。 正因為如此，當在進行一個功能或修復時，分離新分支與 master 是非常重要的。分支名稱應該具有描述性（如 refactor-authentication、user-content-cache-key 或 make-retina-avatars），讓其他人知道哪些正在進行中。 一旦你的分支已經建立，是時候開始進行修改。無論你何時新增、修改或刪除檔案，你會提交更新並將它們加入分支。加入提交的過程讓你可以追蹤分支的工作進度。 提交也產生了一個透明的工作記錄，讓其他人可以了解你做了些什麼，以及原因。每個提交都有相關的提交訊息，用以解釋為什麼做了修改。此外，每個提交被視為一個修改的獨立個體。這使你在找到錯誤或決定朝不同方向時可以復原修改。 進階提示提交訊息是很重要的，尤其當 Git 追蹤你的修改並顯示這些提交於伺服器上。透過撰寫清楚的提交訊息，你可以更容易讓其他人了解並提供回饋。 Pull Requests 發起了關於提交的討論。因為它們緊密的與底層的 Git 儲存庫結合，任何人都可以清楚的看到如果他們接受你的請求，將會合併什麼修改。 在任何的開發過程中，你可以開啟一個 Pull Request：當你有些許或沒有程式碼，但想分享一些截圖或想法，當你卡住了，需要幫助或建議，或者當你準備好讓某人來檢查你的工作。在 Pull Request 訊息內使用 GitHub 的 @ 提及系統，可以要求某個人或團隊的回饋，無論他們身在何處。 進階提示Pull Requests 對於協作開源專案和管理共享儲存庫的修改很有用。如果你使用的是 Fork 及 Pull 模式，Pull Requests 提供了一個方法來通知專案維護者關於你所做的修改。如果你使用的是共享儲存庫模式，Pull Requests 協助在合併到 master 分支前的程式碼檢閱和討論關於修改的建議。 一旦 Pull Request 被開啟，檢閱修改的人或團隊可能會有問題或意見。也許是程式碼風格不符合專案指引、缺少單元測試，或者也許一切看起來都不錯且狀況良好。Pull Requests 旨在鼓勵這種類型的討論。 在討論及回饋關於你的提交時，你還可以繼續推送到你的分支。如果有人反應說你忘了做某件事，或者在程式碼中有錯誤，你可以在分支中修正它並推送修改。GitHub 會顯示你的新提交及任何可能會收到的額外回饋在統一的 Pull Request 頁面。 進階提示Pull Request 的意見都是用 Markdown 撰寫，所以你可以插入圖片和表情符號，使用預先格式化的文字區塊，及其他輕量化的格式。 一旦你的 Pull Request 進行了檢閱且分支通過測試，是時候將程式碼合併到 master 分支進行部署。如果你想在合併到 GitHub 儲存庫前測試東西，你可以先在本地進行合併。若你沒有推送到儲存庫的權限，這就派上用場了。 合併後，Pull Requests 保存了一筆程式碼的修改歷史記錄。因為他們是可搜尋的，可讓任何人回頭來了解為什麼及如何作出決定。 進階提示你可以透過將特定的關鍵字放入 Pull Request 訊息中，將問題與程式碼做關聯。當你的 Pull Request 被合併，相關的問題也將被關閉。舉例來說，輸入 Closes #32 將會關閉儲存庫中編號 32 的問題。欲了解更多資訊，請查看我們的幫助文章。","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://calvertyang.github.io/tags/GitHub/"},{"name":"GitHub Flow","slug":"GitHub-Flow","permalink":"https://calvertyang.github.io/tags/GitHub-Flow/"},{"name":"Workflow","slug":"Workflow","permalink":"https://calvertyang.github.io/tags/Workflow/"}]},{"title":"修正 FacebookSDK 使用 Advertising Identifier(IDFA) 造成的 App 退審","slug":"revised-app-rejected-because-of-idfa-in-facebooksdk","date":"2014-08-22T21:21:00.000Z","updated":"2016-11-01T01:11:05.000Z","comments":true,"path":"2014/08/23/revised-app-rejected-because-of-idfa-in-facebooksdk/","link":"","permalink":"https://calvertyang.github.io/2014/08/23/revised-app-rejected-because-of-idfa-in-facebooksdk/","excerpt":"","text":"這次 App 送審被 Apple 以違反 PLA 3.3.12 而退審，內容大致上是說 Advertising Identifier(IDFA) 僅可基於廣告目的使用於應用程式內，但審核團隊沒發現需用 IDFA 來呈現廣告的地方。 因送審的 App 內僅使用 iAd，而 iAd 是不需 AdSupport framework、ASIdentifierManager 或 Advertising Identifier 的，所以唯一的可能性就是第三方 Framework 使用了 IDFA。 Apple 在退審原因內提示可透過 strings 或 otool 指令來幫忙找出問題點，最終揪出兇手就是 FacebookSDK，在 FBUtility.m 引入了 AdSupport 並使用 advertisingIdentifier。 暫時的解決方法如下： git clone FacebookSDK 到本機 開啟 src/Core/FBUtility.m，將此行註解 1//#import &lt;AdSupport/AdSupport.h&gt; 將 123456789+ (NSString *)advertiserID &#123; NSString *advertiserID = nil; Class ASIdentifierManagerClass = [FBDynamicFrameworkLoader loadClass:@\"ASIdentifierManager\" withFramework:@\"AdSupport\"]; if ([ASIdentifierManagerClass class]) &#123; ASIdentifierManager *manager = [ASIdentifierManagerClass sharedManager]; advertiserID = [[manager advertisingIdentifier] UUIDString]; &#125; return advertiserID;&#125; 改為 123+ (NSString *)advertiserID &#123; return @\"\";&#125; 將 1234567891011121314+ (FBAdvertisingTrackingStatus)advertisingTrackingStatus &#123; if ([FBSettings restrictedTreatment] == FBRestrictedTreatmentYES) &#123; return AdvertisingTrackingDisallowed; &#125; FBAdvertisingTrackingStatus status = AdvertisingTrackingUnspecified; Class ASIdentifierManagerClass = [FBDynamicFrameworkLoader loadClass:@\"ASIdentifierManager\" withFramework:@\"AdSupport\"]; if ([ASIdentifierManagerClass class]) &#123; ASIdentifierManager *manager = [ASIdentifierManagerClass sharedManager]; if (manager) &#123; status = [manager isAdvertisingTrackingEnabled] ? AdvertisingTrackingAllowed : AdvertisingTrackingDisallowed; &#125; &#125; return status;&#125; 改為 123+ (FBAdvertisingTrackingStatus)advertisingTrackingStatus &#123; return AdvertisingTrackingDisallowed;&#125; 使用 scripts/build_framework.sh 重新打包 FacebookSDK。 返回原專案引用新打包的 FacebookSDK 重建 App 並送審。 註：若 App 內使用了 iAd 以外的廣告服務且廣告有正常顯示，應該不會因違反 PLA 3.3.12 而退審。 參考資料： Stack Overflow：app rejected because of advertisingIdentifier in Facebook SDK and Flurry SDK Github：Rejection for ASIdentifierManager","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://calvertyang.github.io/tags/iOS/"}]},{"title":"看懂 npm 語意化版本","slug":"npm-semantic-versioner","date":"2014-08-19T22:14:00.000Z","updated":"2017-02-06T07:08:58.000Z","comments":true,"path":"2014/08/20/npm-semantic-versioner/","link":"","permalink":"https://calvertyang.github.io/2014/08/20/npm-semantic-versioner/","excerpt":"","text":"npm(Node Package Manager) 採用語意化版本 2.0.0 規範，詳細的規範內容可查看 http://semver.org/。 使用 npm 管理套件時，你會注意到 package.json 內的套件版本有許多表示法，以下說明各表示法所代表的意思： 版本 說明 1.2.3 指定版本。需為完整的版號，包含主版號、次版號及修訂號。需注意的是，版本編譯資訊（Metadata）會被忽略，所以 1.2.3+build2012 滿足此條件。 &gt;1.2.3 大於指定版本。 &lt;1.2.3 小於指定版本。如果沒有預先發佈版在此版本範圍，則沒有預先發佈版會被允許，即使在技術上是「小於」。 &gt;=1.2.3 大於或等於。需注意的是，預先發佈版不等同其版本。因此 1.2.3-beta 不滿足此條件，但 2.3.0-beta 則會。 &lt;=1.2.3 小於或等於。在這種情況下，允許預先發佈版，所以 1.2.3-beta 滿足此條件。 1.2.3 - 2.3.4 等同於 &gt;=1.2.3 &lt;=2.3.4。 ~1.2.3 等同於 &gt;=1.2.3-0 &lt;1.3.0-0，當使用 ~ 符號時，支援預先發佈版，但不含次版號的變更（及其預先發佈版）。因此 1.3.0-beta 不滿足 ~1.2.3。 ^1.2.3 等同於 &gt;=1.2.3-0 &lt;2.0.0-0，當使用 ^ 符號時，支援任何次版號及修訂號的變更（含預先發佈版），但不含主版號的變更（及其預先發佈版）。因此 1.5.1 能滿足 ^1.2.3，而 1.2.2 及 2.0.0-beta 則不會。 ^0.1.3 等同於 0.1.3，與 0.1.3 版相容。0.x.x 版比較特殊，因為語意化版本規範規定 0.x.x 版不作任何穩定性保證，只有指定的版本被認為是有效的。 ~0.0.2 等同於 0.0.2，與 0.0.2 版相容。 ~1.2 等同於 &gt;=1.2.0-0 &lt;1.3.0-0，任何從 1.2 開始的版本。 ^1.2 等同於 &gt;=1.2.0-0 &lt;1.3.0-0，任何相容於從 1.2 開始的版本。 1.2.x 等同於 &gt;=1.2.0-0 &lt;1.3.0-0，任何從 1.2 開始的版本。 1.2.* 等同於 1.2.x。 1.2 等同於 1.2.x。 ~1 等同於 &gt;=1.0.0-0 &lt;2.0.0-0，任何從 1 開始的版本。 ^1 等同於 &gt;=1.0.0-0 &lt;2.0.0-0，任何相容於從 1 開始的版本。 1.x 等同於 &gt;=1.0.0-0 &lt;2.0.0-0，任何從 1 開始的版本。 1.* 等同於 1.x。 1 等同於 1.x。 * 任何版本。 x 等同於 *。 &quot;&quot; 空字串，等同於 *。 官方文件：The semantic versioner for npm","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://calvertyang.github.io/tags/Node-js/"},{"name":"npm","slug":"npm","permalink":"https://calvertyang.github.io/tags/npm/"},{"name":"SemVer","slug":"SemVer","permalink":"https://calvertyang.github.io/tags/SemVer/"}]},{"title":"SQL 及 MongoDB 集合(Aggregation)指令對應表","slug":"sql-to-aggregation-mapping-chart","date":"2013-11-15T19:10:00.000Z","updated":"2018-05-21T07:58:00.000Z","comments":true,"path":"2013/11/16/sql-to-aggregation-mapping-chart/","link":"","permalink":"https://calvertyang.github.io/2013/11/16/sql-to-aggregation-mapping-chart/","excerpt":"集合管線(aggregation pipeline)允許 MongoDB 提供原生集合功能，對應 SQL 中許多常見的資料集合操作。 下表列出了常見的 SQL 集合術語、功能及概念和相應的 MongoDB 集合運算元概觀。 SQL 術語、功能及概念 MongoDB 集合運算元 WHERE $match GROUP BY $group HAVING $match SELECT $project ORDER BY $sort LIMIT $limit SUM() $sum COUNT() $sum join 沒有直接對應的運算元，然而，$unwind 運算元允許有些類似的功能，但是與嵌入的欄位在文件內。","text":"集合管線(aggregation pipeline)允許 MongoDB 提供原生集合功能，對應 SQL 中許多常見的資料集合操作。 下表列出了常見的 SQL 集合術語、功能及概念和相應的 MongoDB 集合運算元概觀。 SQL 術語、功能及概念 MongoDB 集合運算元 WHERE $match GROUP BY $group HAVING $match SELECT $project ORDER BY $sort LIMIT $limit SUM() $sum COUNT() $sum join 沒有直接對應的運算元，然而，$unwind 運算元允許有些類似的功能，但是與嵌入的欄位在文件內。 範例(Examples)下表列出了 SQL 集合語句和相應的 MongoDB 語句的快速參考。在表格中的範例假定有下列條件： SQL 範例假設有兩張資料表 orders 及 order_lineitem，透過 order_lineitem.order_id 及 orders.id 資料行相連結。 MongoDB 範例假設一個名為 orders 的集合，包含的文件原型如下： 12345678&#123; cust_id: \"abc123\", ord_date: ISODate(\"2012-11-02T17:04:11.102Z\"), status: 'A', price: 50, items: [ &#123; sku: \"xxx\", qty: 25, price: 1 &#125;, &#123; sku: \"yyy\", qty: 25, price: 1 &#125; ]&#125; MongoDB 語句中集合內的文件的欄位名稱在集合操作時以 $ 字元為字首。 計算 orders 所有資料數 SQL 架構語句 12SELECT COUNT(*) AS countFROM orders MongoDB 架構語句 1234db.orders.aggregate( [ &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;] ) 加總 orders 的 price 欄位 SQL 架構語句 12SELECT SUM(price) AS totalFROM orders MongoDB 架構語句 1234db.orders.aggregate( [ &#123; $group: &#123; _id: null, total: &#123; $sum: \"$price\" &#125; &#125; &#125;] ) 對不同的 cust_id 加總 price 欄位 SQL 架構語句 1234SELECT cust_id, SUM(price) AS totalFROM ordersGROUP BY cust_id MongoDB 架構語句 1234db.orders.aggregate( [ &#123; $group: &#123; _id: \"$cust_id\", total: &#123; $sum: \"$price\" &#125; &#125; &#125;] ) 對不同的 cust_id 加總 price 欄位，並依照加總排序 SQL 架構語句 12345SELECT cust_id, SUM(price) AS totalFROM ordersGROUP BY cust_idORDER BY total MongoDB 架構語句 12345db.orders.aggregate( [ &#123; $group: &#123; _id: \"$cust_id\", total: &#123; $sum: \"$price\" &#125; &#125; &#125;, &#123; $sort: &#123; total: 1 &#125; &#125;] ) 對不同的 cust_id 及 ord_date 分組，加總 price 欄位 SQL 架構語句 12345SELECT cust_id, ord_date, SUM(price) AS totalFROM ordersGROUP BY cust_id, ord_date MongoDB 架構語句 12345db.orders.aggregate( [ &#123; $group: &#123; _id: &#123; cust_id: \"$cust_id\", ord_date: \"$ord_date\" &#125;, total: &#123; $sum: \"$price\" &#125; &#125; &#125;] ) 對於 cust_id 的多筆資料，返回 cust_id 和相應的資料數 SQL 架構語句 1234SELECT cust_id, count(*)FROM ordersGROUP BY cust_idHAVING count(*) &gt; 1 MongoDB 架構語句 12345db.orders.aggregate( [ &#123; $group: &#123; _id: \"$cust_id\", count: &#123; $sum: 1 &#125; &#125; &#125;, &#123; $match: &#123; count: &#123; $gt: 1 &#125; &#125; &#125;] ) 對不同的 cust_id 及 ord_date 分組，加總 price 欄位，並只返回總和大於 250 的資料 SQL 架構語句 123456SELECT cust_id, ord_date, SUM(price) AS totalFROM ordersGROUP BY cust_id, ord_dateHAVING total &gt; 250 MongoDB 架構語句 123456db.orders.aggregate( [ &#123; $group: &#123; _id: &#123; cust_id: \"$cust_id\", ord_date: \"$ord_date\" &#125;, total: &#123; $sum: \"$price\" &#125; &#125; &#125;, &#123; $match: &#123; total: &#123; $gt: 250 &#125; &#125; &#125;] ) 對 status 為 A 的不同的 cust_id 加總 price 欄位 SQL 架構語句 12345SELECT cust_id, SUM(price) as totalFROM ordersWHERE status = 'A'GROUP BY cust_id MongoDB 架構語句 12345db.orders.aggregate( [ &#123; $match: &#123; status: 'A' &#125; &#125;, &#123; $group: &#123; _id: \"$cust_id\", total: &#123; $sum: \"$price\" &#125; &#125; &#125;] ) 對 status 為 A 的不同的 cust_id 加總 price 欄位，並只返回總和大於 250 的資料 SQL 架構語句 123456SELECT cust_id, SUM(price) as totalFROM ordersWHERE status = 'A'GROUP BY cust_idHAVING total &gt; 250 MongoDB 架構語句 123456db.orders.aggregate( [ &#123; $match: &#123; status: 'A' &#125; &#125;, &#123; $group: &#123; _id: \"$cust_id\", total: &#123; $sum: \"$price\" &#125; &#125; &#125;, &#123; $match: &#123; total: &#123; $gt: 250 &#125; &#125; &#125;] ) 對不同的 cust_id 加總與 orders 相應的 order_lineitem 的 qty 欄位 SQL 架構語句 123456SELECT cust_id, SUM(li.qty) as qtyFROM orders o, order_lineitem liWHERE li.order_id = o.idGROUP BY cust_id MongoDB 架構語句 12345db.orders.aggregate( [ &#123; $unwind: \"$items\" &#125;, &#123; $group: &#123; _id: \"$cust_id\", qty: &#123; $sum: \"$items.qty\" &#125; &#125; &#125;] ) 計算不同的 cust_id 及 ord_date 分組數量 SQL 架構語句 1234SELECT COUNT(*)FROM (SELECT cust_id, ord_date FROM orders GROUP BY cust_id, ord_date) as DerivedTable MongoDB 架構語句 12345db.orders.aggregate( [ &#123; $group: &#123; _id: &#123; cust_id: \"$cust_id\", ord_date: \"$ord_date\" &#125; &#125; &#125;, &#123; $group: &#123; _id: null, count: &#123; $sum: 1 &#125; &#125; &#125;] )","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://calvertyang.github.io/tags/SQL/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://calvertyang.github.io/tags/NoSQL/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://calvertyang.github.io/tags/MongoDB/"}]},{"title":"SQL 及 MongoDB 基本指令對應表","slug":"sql-to-mongodb-mapping-chart","date":"2013-11-14T03:46:00.000Z","updated":"2018-05-21T07:58:00.000Z","comments":true,"path":"2013/11/14/sql-to-mongodb-mapping-chart/","link":"","permalink":"https://calvertyang.github.io/2013/11/14/sql-to-mongodb-mapping-chart/","excerpt":"由於新專案採用了 Node.js 開發且使用 MongoDB 作為儲存媒介，所以動手翻譯了官方文件方便查閱相關指令用法。 術語和概念(Terminology and Concepts)下表列出了各種 SQL 和相應的 MongoDB 的術語和概念。 SQL 術語/概念 MongoDB 術語/概念 資料庫(database) 資料庫(database) 資料表(table) 集合(collection) 資料列(row) 文件(document) 或 BSON 文件 資料行(column) 欄位(field) 索引(index) 索引(index) 資料表連結(table joins) 嵌入式文件及連結(embedded documents and linking) 主索引鍵(primary key)指定任意一個或多個欄位組合為主索引鍵，資料內容須唯一不可重複。 主索引鍵(primary key)在 MongoDB，主索引鍵會自動設定到 _id 欄位。 彙總(aggregation)，例如：group by 彙總管線(aggregation pipeline)參閱 SQL 至彙總(Aggregation)對應表. 可執行檔案(Executables)下表列出了 MySQL / Oracle 可執行檔案和相應的 MongoDB 的可執行檔案。 MySQL / Oracle MongoDB 資料庫伺服器(Database Server) mysqld / oracle mongod 資料庫用戶端(Database Client) mysql / sqlplus mongo","text":"由於新專案採用了 Node.js 開發且使用 MongoDB 作為儲存媒介，所以動手翻譯了官方文件方便查閱相關指令用法。 術語和概念(Terminology and Concepts)下表列出了各種 SQL 和相應的 MongoDB 的術語和概念。 SQL 術語/概念 MongoDB 術語/概念 資料庫(database) 資料庫(database) 資料表(table) 集合(collection) 資料列(row) 文件(document) 或 BSON 文件 資料行(column) 欄位(field) 索引(index) 索引(index) 資料表連結(table joins) 嵌入式文件及連結(embedded documents and linking) 主索引鍵(primary key)指定任意一個或多個欄位組合為主索引鍵，資料內容須唯一不可重複。 主索引鍵(primary key)在 MongoDB，主索引鍵會自動設定到 _id 欄位。 彙總(aggregation)，例如：group by 彙總管線(aggregation pipeline)參閱 SQL 至彙總(Aggregation)對應表. 可執行檔案(Executables)下表列出了 MySQL / Oracle 可執行檔案和相應的 MongoDB 的可執行檔案。 MySQL / Oracle MongoDB 資料庫伺服器(Database Server) mysqld / oracle mongod 資料庫用戶端(Database Client) mysql / sqlplus mongo 範例(Examples)下表列出了各種 SQL 語句和相應的 MongoDB 語句。在表格中的範例假定有下列條件： SQL 範例假設是名為 users 的資料表 MongoDB 範例假設是名為 users 的集合，包含的文件原型如下： 123456&#123; _id: ObjectID(\"509a8fb2f3f4948bd2f983a0\"), user_id: \"abc123\", age: 55, status: 'A'&#125; 建立及修改資料表(Create and Alter)下面列出了關於資料表層級操作的各種 SQL 語句和相應的 MongoDB 語句。 SQL 架構語句 12345678CREATE TABLE users ( id MEDIUMINT NOT NULL AUTO_INCREMENT, user_id Varchar(30), age Number, status char(1), PRIMARY KEY (id)) MongoDB 架構語句在第一次插入資料操作時透過隱含方式建立。若未指定 _id 欄位，則會自動建立主索引鍵 _id。 12345db.users.insert( &#123; user_id: \"abc123\", age: 55, status: \"A\" &#125; ) 然而，你也可以明確地建立一個集合： 1db.createCollection(\"users\") 參閱 insert() 和 db.createCollection() 取得更多資訊。 SQL 架構語句 12ALTER TABLE usersADD join_date DATETIME MongoDB 架構語句集合不描述或強制其文件結構，即在集合層級沒有結構上的改變。然而，在文件層級，update() 操作可以透過 $set 運算元加入欄位到已存在的文件。 12345db.users.update( &#123; &#125;, &#123; $set: &#123; join_date: new Date() &#125; &#125;, &#123; multi: true &#125;) 參閱 Data Modeling Concepts、update() 及 $set 取得更多改變集合中文件結構的更多資訊。 SQL 架構語句 12ALTER TABLE usersDROP COLUMN join_date MongoDB 架構語句集合不描述或強制其文件結構，即在集合層級中沒有結構上的改變。然而，在文件層級，update() 操作可以透過 $unset 運算元從文件移除欄位。 12345db.users.update( &#123; &#125;, &#123; $unset: &#123; join_date: \"\" &#125; &#125;, &#123; multi: true &#125;) 參閱 Data Modeling Concepts、update() 及 $unset 取得更多改變集合中文件結構的更多資訊。 SQL 架構語句 12CREATE INDEX idx_user_id_ascON users(user_id) MongoDB 架構語句 1db.users.ensureIndex( &#123; user_id: 1 &#125; ) 參閱 ensureIndex() 及 indexes 取得更多資訊。 SQL 架構語句 123CREATE INDEX idx_user_id_asc_age_descON users(user_id, age DESC) MongoDB 架構語句 1db.users.ensureIndex( &#123; user_id: 1, age: -1 &#125; ) 參閱 ensureIndex() 及 indexes 取得更多資訊。 SQL 架構語句 1DROP TABLE users MongoDB 架構語句 1db.users.drop() 參閱 drop() 取得更多資訊。 插入(Insert)下面列出了關於插入資料到資料表的各種 SQL 語句和相應的 MongoDB 語句。 SQL 架構語句 12345678INSERT INTO users( user_id, age, status)VALUES ( \"bcd001\", 45, \"A\") MongoDB 架構語句 12345db.users.insert( &#123; user_id: \"bcd001\", age: 45, status: \"A\"&#125; ) 參閱 insert() 取得更多資訊。 選擇(Select)下面列出了關於從資料表讀取資料的各種 SQL 語句和相應的 MongoDB 語句。 SQL 架構語句 12SELECT *FROM users MongoDB 架構語句 1db.users.find() 參閱 find() 取得更多資訊。 SQL 架構語句 12SELECT id, user_id, statusFROM users MongoDB 架構語句 1234db.users.find( &#123; &#125;, &#123; user_id: 1, status: 1 &#125;) 參閱 find() 取得更多資訊。 SQL 架構語句 12SELECT user_id, statusFROM users MongoDB 架構語句 1234db.users.find( &#123; &#125;, &#123; user_id: 1, status: 1, _id: 0 &#125;) 參閱 find() 取得更多資訊。 SQL 架構語句 123SELECT *FROM usersWHERE status = \"A\" MongoDB 架構語句 123db.users.find( &#123; status: \"A\" &#125;) 參閱 find() 取得更多資訊。 SQL 架構語句 123SELECT user_id, statusFROM usersWHERE status = \"A\" MongoDB 架構語句 1234db.users.find( &#123; status: \"A\" &#125;, &#123; user_id: 1, status: 1, _id: 0 &#125;) 參閱 find() 取得更多資訊。 SQL 架構語句 123SELECT *FROM usersWHERE status != \"A\" MongoDB 架構語句 123db.users.find( &#123; status: &#123; $ne: \"A\" &#125; &#125;) 參閱 find() 及 $ne 取得更多資訊。 SQL 架構語句 1234SELECT *FROM usersWHERE status = \"A\"AND age = 50 MongoDB 架構語句 1234db.users.find( &#123; status: \"A\", age: 50 &#125;) 參閱 find() 及 $and 取得更多資訊。 SQL 架構語句 1234SELECT *FROM usersWHERE status = \"A\"OR age = 50 MongoDB 架構語句 1234db.users.find( &#123; $or: [ &#123; status: \"A\" &#125; , &#123; age: 50 &#125; ] &#125;) 參閱 find() 及 $or 取得更多資訊。 SQL 架構語句 123SELECT *FROM usersWHERE age &gt; 25 MongoDB 架構語句 123db.users.find( &#123; age: &#123; $gt: 25 &#125; &#125;) 參閱 find() 及 $gt 取得更多資訊。 SQL 架構語句 123SELECT *FROM usersWHERE age &lt; 25 MongoDB 架構語句 123db.users.find( &#123; age: &#123; $lt: 25 &#125; &#125;) 參閱 find() 及 $lt 取得更多資訊。 SQL 架構語句 1234SELECT *FROM usersWHERE age &gt; 25AND age &lt;= 50 MongoDB 架構語句 123db.users.find( &#123; age: &#123; $gt: 25, $lte: 50 &#125; &#125;) 參閱 find()、$gt 及 $lte 取得更多資訊。 SQL 架構語句 123SELECT *FROM usersWHERE user_id like \"%bc%\" MongoDB 架構語句 123db.users.find( &#123; user_id: /bc/ &#125;) 參閱 find() 及 $regex 取得更多資訊。 SQL 架構語句 123SELECT *FROM usersWHERE user_id like \"bc%\" MongoDB 架構語句 123db.users.find( &#123; user_id: /^bc/ &#125;) 參閱 find() 及 $regex 取得更多資訊。 SQL 架構語句 1234SELECT *FROM usersWHERE status = \"A\"ORDER BY user_id ASC MongoDB 架構語句 1db.users.find( &#123; status: \"A\" &#125; ).sort( &#123; user_id: 1 &#125; ) 參閱 find() 及 sort() 取得更多資訊。 SQL 架構語句 1234SELECT *FROM usersWHERE status = \"A\"ORDER BY user_id DESC MongoDB 架構語句 1db.users.find( &#123; status: \"A\" &#125; ).sort( &#123; user_id: -1 &#125; ) 參閱 find() 及 sort() 取得更多資訊。 SQL 架構語句 12SELECT COUNT(*)FROM users MongoDB 架構語句 1db.users.count() 或 1db.users.find().count() 參閱 find() 及 count() 取得更多資訊。 SQL 架構語句 12SELECT COUNT(user_id)FROM users MongoDB 架構語句 1db.users.count( &#123; user_id: &#123; $exists: true &#125; &#125; ) 或 1db.users.find( &#123; user_id: &#123; $exists: true &#125; &#125; ).count() 參閱 find()、count() 及 $exists 取得更多資訊。 SQL 架構語句 123SELECT COUNT(*)FROM usersWHERE age &gt; 30 MongoDB 架構語句 1db.users.count( &#123; age: &#123; $gt: 30 &#125; &#125; ) 或 1db.users.find( &#123; age: &#123; $gt: 30 &#125; &#125; ).count() 參閱 find()、count() 及 $gt 取得更多資訊。 SQL 架構語句 12SELECT DISTINCT(status)FROM users MongoDB 架構語句 1db.users.distinct( \"status\" ) 參閱 find() 及 distinct() 取得更多資訊。 SQL 架構語句 123SELECT *FROM usersLIMIT 1 MongoDB 架構語句 1db.users.findOne() 或 1db.users.find().limit(1) 參閱 find()、findOne() 及 limit() 取得更多資訊。 SQL 架構語句 1234SELECT *FROM usersLIMIT 5SKIP 10 MongoDB 架構語句 1db.users.find().limit(5).skip(10) 參閱 find()、limit() 及 skip() 取得更多資訊。 SQL 架構語句 123EXPLAIN SELECT *FROM usersWHERE status = \"A\" MongoDB 架構語句 1db.users.find( &#123; status: \"A\" &#125; ).explain() 參閱 find() 及 explain() 取得更多資訊。 修改資料(Update Records)下面列出了關於修改現有資料表內資料的各種 SQL 語句和相應的 MongoDB 語句。 SQL 架構語句 123UPDATE usersSET status = \"C\"WHERE age &gt; 25 MongoDB 架構語句 12345db.users.update( &#123; age: &#123; $gt: 25 &#125; &#125;, &#123; $set: &#123; status: \"C\" &#125; &#125;, &#123; multi: true &#125;) 參閱 update()、$gt 及 $set 取得更多資訊。 SQL 架構語句 123UPDATE usersSET age = age + 3WHERE status = \"A\" MongoDB 架構語句 12345db.users.update( &#123; status: \"A\" &#125; , &#123; $inc: &#123; age: 3 &#125; &#125;, &#123; multi: true &#125;) 參閱 update()、$inc 及 $set 取得更多資訊。 刪除資料(Delete Records)下面列出了關於從資料表刪除資料的各種 SQL 語句和相應的 MongoDB 語句。 SQL 架構語句 12DELETE FROM usersWHERE status = \"D\" MongoDB 架構語句 1db.users.remove( &#123; status: \"D\" &#125; ) 參閱 remove() 取得更多資訊。 SQL 架構語句 1DELETE FROM users MongoDB 架構語句 1db.users.remove( ) 參閱 remove() 取得更多資訊。 參考資料：SQL to MongoDB Mapping Chart","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://calvertyang.github.io/tags/SQL/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://calvertyang.github.io/tags/NoSQL/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://calvertyang.github.io/tags/MongoDB/"}]},{"title":"如何在 CentOS 6 安裝 Redis","slug":"how-to-install-redis-in-centos-6","date":"2013-11-05T20:45:00.000Z","updated":"2017-02-06T07:13:24.000Z","comments":true,"path":"2013/11/06/how-to-install-redis-in-centos-6/","link":"","permalink":"https://calvertyang.github.io/2013/11/06/how-to-install-redis-in-centos-6/","excerpt":"","text":"Redis 是一個開源、遵守 BSD 授權、先進的鍵值對儲存庫。它通常被稱為資料結構伺服器，因為值可以是字串(String)、雜湊(Hash)、列表(List)、集合(Set)及序列集合(Sorted Set)等類型。 下載並解壓縮 123$ wget http://download.redis.io/redis-stable.tar.gz$ tar -zxvf redis-stable.tar.gz$ cd redis-stable 編譯並測試是否可安裝 12$ make$ make test 若出現訊息，代表系統尚未安裝 tcl 123456cd src &amp;&amp; make testmake[1]: Entering directory `/tmp/redis-stable/src'You need tcl 8.5 or newer in order to run the Redis testmake[1]: *** [test] Error 1make[1]: Leaving directory `/tmp/redis-stable/src'make: *** [test] Error 2 tcl 安裝步驟，詳見官方文件 安裝 redis 1234567891011$ make installcd src &amp;&amp; make installmake[1]: Entering directory '/tmp/redis-stable/src'Hint: To run 'make test' is a good idea ;)mkdir -p /usr/local/bin INSTALL install INSTALL install INSTALL install INSTALL install INSTALL installmake[1]: Leaving directory `/tmp/redis-stable/src' 到此，redis 便安裝完畢了，redis 包含了以下幾個部分： redis-server: is the Redis Server itself. redis-cli: is the command line interface utility to talk with Redis. redis-benchmark: is used to check Redis performances. redis-check-aof 及 redis-check-dump: are useful in the rare event of corrupted data files. 啟動 redis最簡單的啟動方式為直接執行 redis-server 且不含任何參數。 1234567$ redis-server[12182] 06 Nov 13:58:15.841 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf[12182] 06 Nov 13:58:15.842 * Max number of open files set to 10032......[12182] 06 Nov 13:58:15.843 # Server started, Redis version 2.6.16[12182] 06 Nov 13:58:15.843 * The server is now ready to accept connections on port 6379 若要啟動 redis 並帶入設定檔，只需將設定檔的完整路徑帶入即可，如：redis-server /etc/redis.conf 接著加入設定將 redis 作為服務於開機時啟動建立工作目錄 1$ sudo mkdir /var/redis 從 utils 資料夾複製啟動腳本到 /etc/init.d/ 1$ sudo cp utils/redis_init_script /etc/init.d/redis 編輯啟動腳本，根據需求修改 REDIS_PORT 1sudo vi /etc/init.d/redis 複製預設設定檔 1sudo cp redis.conf /etc/redis.conf 需修改以下幾個項目 daemonize: 設定為 yes 讓 redis 可背景執行，預設為 no port: 根據需求修改連接埠，預設為 6379 loglevel: 根據需求修改要記錄的訊息等級，預設為 notice logfile: 設定要放置記錄檔的位置，預設為標準輸出(stdout) 不會保留記錄於檔案內 dir: 將工作目錄設定為 /var/redis (此設定非常重要) 最後，將啟動腳本加入開機執行 1sudo update-rc.d redis defaults 現在你可以透過以下指令啟動 redis 1service redis start","categories":[{"name":"Server","slug":"Server","permalink":"https://calvertyang.github.io/categories/Server/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://calvertyang.github.io/tags/Linux/"},{"name":"Redis","slug":"Redis","permalink":"https://calvertyang.github.io/tags/Redis/"}]},{"title":"Mac OS X 延長 SSD 壽命","slug":"mac-os-x-ssd-performance-optimization","date":"2013-10-26T04:28:00.000Z","updated":"2017-02-06T07:09:16.000Z","comments":true,"path":"2013/10/26/mac-os-x-ssd-performance-optimization/","link":"","permalink":"https://calvertyang.github.io/2013/10/26/mac-os-x-ssd-performance-optimization/","excerpt":"","text":"由於有時候會重灌電腦，所以在這記錄一下重灌之後要延長 SSD 所做的步驟。 關閉 Time Machine 的本機備份模式如果有開啟 Time Machine 功能，當備份磁碟無法使用時，系統還是會每小時建立快照摒除存在本機硬碟，使用以下指令可以禁止系統在本地端備份檔案1$ sudo tmutil disablelocal 往後也可以使用以下的指令重新開啟這個功能1$ sudo tmutil enablelocal 設定 noatime 掛載Unix like 的作業系統，會在每次存取檔案時修改 Access time 的屬性，可以令如 Spotlight 的程式找到最近存取的檔案。但是每次存取檔案時皆會對硬碟寫入資料，對有存取次數限制的 SSD 來說便會縮短壽命，以下的步驟可以取消記錄存取時間。 在家目錄建立 com.disk.noatime.plist 檔案，內容如下： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt;&lt;key&gt;Label&lt;/key&gt;&lt;string&gt;com.disk.noatime&lt;/string&gt;&lt;key&gt;ProgramArguments&lt;/key&gt;&lt;array&gt;&lt;string&gt;mount&lt;/string&gt;&lt;string&gt;-vuwo&lt;/string&gt;&lt;string&gt;noatime&lt;/string&gt;&lt;string&gt;/&lt;/string&gt;&lt;/array&gt;&lt;key&gt;RunAtLoad&lt;/key&gt;&lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt; 搬移檔案到 LaunchDaemons 資料夾 1$ sudo mv ~/com.disk.noatime.plist /Library/LaunchDaemons/ 變更 com.disk.noatime.plist 檔案擁有者 1$ sudo chown root:wheel /Library/LaunchDaemons/com.disk.noatime.plist 重開機後，於終端機內輸入 mount 看到 noatime 代表已使用 noatime 掛載 12$ mount/dev/disk0s2 on / (hfs, local, journaled, noatime) 變更睡眠時資料儲存位置當系統進入睡眠狀態時，OS X 預設將資料保存於記憶體內，另外再將記憶體資料寫入硬碟，防止電腦沒電時資料遺失。假設記憶體有 8 GB，代表睡眠時若電腦電力不足都會將 8 GB 資料寫入硬碟，長期下來 SSD 的壽命將會大打折扣，因此我們要變更睡眠時的資料存放位置，改為只存於記憶體中，但若是電腦沒電時，資料便會遺失。 透使用下列指令設定睡眠時只存在記憶體 1$ sudo pmset -a hibernatemode 0 刪除在硬碟上的睡眠備份檔 1$ sudo rm /var/vm/sleepimage 若要改回預設的模式，則輸入1$ sudo pmset -a hibernatemode 3 輸入下列指令可以查看目前模式1$ sudo pmset -g | grep hibernatemode hibernatemode 0 建立一個空檔案，防止系統再產生 sleepimage建立檔案1$ sudo touch /var/vm/sleepimage 防止系統修改此檔案1$ chflags uchg /var/vm/sleepimage","categories":[{"name":"Mac","slug":"Mac","permalink":"https://calvertyang.github.io/categories/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://calvertyang.github.io/tags/Mac/"}]},{"title":"使用 jQuery Validation Plugin 驗證元素陣列","slug":"jquery-validation-plugin-for-array-of-elements","date":"2013-10-19T17:52:00.000Z","updated":"2017-02-06T07:09:22.000Z","comments":true,"path":"2013/10/20/jquery-validation-plugin-for-array-of-elements/","link":"","permalink":"https://calvertyang.github.io/2013/10/20/jquery-validation-plugin-for-array-of-elements/","excerpt":"","text":"有時候我們會需要驗證表單中的元素陣列，例如：1234567891011121314151617181920212223242526272829&lt;form id=\"userDataForm\" name=\"userDataForm\" method=\"post\" action=\"\"&gt; &lt;!-- User 1 --&gt; &lt;input type=\"text\" id=\"userName1\" name=\"userName[]\" /&gt; &lt;input type=\"text\" id=\"userAddress1\" name=\"userAddress[]\" /&gt; &lt;select id=\"sex1\" name=\"sex[]\"&gt; &lt;option value=\"\"&gt;- 請選擇 -&lt;/option&gt; &lt;option value=\"1\"&gt;男&lt;/option&gt; &lt;option value=\"0\"&gt;女&lt;/option&gt; &lt;/select&gt; … &lt;!-- User 2 --&gt; &lt;input type=\"text\" id=\"userName2\" name=\"userName[]\" /&gt; &lt;input type=\"text\" id=\"userAddress2\" name=\"userAddress[]\" /&gt; &lt;select id=\"sex2\" name=\"sex[]\"&gt; &lt;option value=\"\"&gt;- 請選擇 -&lt;/option&gt; &lt;option value=\"1\"&gt;男&lt;/option&gt; &lt;option value=\"0\"&gt;女&lt;/option&gt; &lt;/select&gt; … &lt;!-- User N --&gt; &lt;input type=\"text\" id=\"userNameN\" name=\"userName[]\" /&gt; &lt;input type=\"text\" id=\"userAddressN\" name=\"userAddress[]\" /&gt; &lt;select id=\"sexN\" name=\"sex[]\"&gt; &lt;option value=\"\"&gt;- 請選擇 -&lt;/option&gt; &lt;option value=\"1\"&gt;男&lt;/option&gt; &lt;option value=\"0\"&gt;女&lt;/option&gt; &lt;/select&gt; …&lt;/form&gt; 現在，使用 jQuery Validation Plugin 來驗證此表單。驗證條件為使用者必須填寫各輸入欄位，驗證語法如下：123456789101112131415161718&lt;script src=\"jquery.js\"&gt;&lt;/script&gt;&lt;script src=\"jquery.validate.js\"&gt;&lt;/script&gt;&lt;script&gt;$(function() &#123; $(\"#userDataForm\").validate(&#123; rules: &#123; \"userName[]\": \"required\", \"userAddress[]\": \"required\", \"sex[]\": \"required\" &#125;, messages: &#123; \"userName[]\": \"請輸入姓名\", \"userAddress[]\": \"請輸入地址\", \"sex[]\": \"請選擇性別\" &#125; &#125;);&#125;);&lt;/script&gt; 使用以上的語法會遇到的問題是 jquery.validate.js 僅有驗證 userName 及 userAddress 陣列的第一個元素，所以我們需要對此插件做點小修改。 開啟 jquery.validate.js，可以找到名為 checkForm 的方法，內容如下：jquery.validate.js1234567checkForm: function() &#123; this.prepareForm(); for ( var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++ ) &#123; this.check( elements[i] ); &#125; return this.valid();&#125; 將此方法修改為如下的內容後，便會驗證陣列中的所有元素。jquery.validate.js1234567891011121314checkForm: function() &#123; this.prepareForm(); for ( var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++ ) &#123; if ( this.findByName( elements[i].name ).length != undefined &amp;&amp; this.findByName( elements[i].name ).length &gt; 1 ) &#123; for ( var j = 0; j &lt; this.findByName( elements[i].name ).length; j++ ) &#123; this.check( this.findByName( elements[i].name )[j] ); &#125; &#125; else &#123; this.check( elements[i] ); &#125; &#125; return this.valid();&#125; 參考資料：JQuery Validation for Array of Input Elements","categories":[{"name":"Programming","slug":"Programming","permalink":"https://calvertyang.github.io/categories/Programming/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://calvertyang.github.io/tags/JavaScript/"}]},{"title":"為 Ngnix 建立自行簽章的憑證","slug":"creating-a-self-signed-ssl-certificate-for-nginx","date":"2013-10-17T02:01:00.000Z","updated":"2018-05-21T07:58:00.000Z","comments":true,"path":"2013/10/17/creating-a-self-signed-ssl-certificate-for-nginx/","link":"","permalink":"https://calvertyang.github.io/2013/10/17/creating-a-self-signed-ssl-certificate-for-nginx/","excerpt":"必要條件產生憑證需要 OpenSSL 類別庫，請先確認系統是否已安裝 OpenSSL。 若尚未安裝，可透過以下方式安裝： Mac OS X 使用 Homebrew 安裝 1$ brew install openssl Windows 可到此網站下載安裝檔：OpenSSL for Windows Ubuntu/Debian Linux 1$ sudo apt-get install openssl RedHat/CentOS Linux 1$ sudo yum install openssl","text":"必要條件產生憑證需要 OpenSSL 類別庫，請先確認系統是否已安裝 OpenSSL。 若尚未安裝，可透過以下方式安裝： Mac OS X 使用 Homebrew 安裝 1$ brew install openssl Windows 可到此網站下載安裝檔：OpenSSL for Windows Ubuntu/Debian Linux 1$ sudo apt-get install openssl RedHat/CentOS Linux 1$ sudo yum install openssl 步驟一：建立存放憑證的資料夾12$ mkdir /etc/nginx/ssl$ cd /etc/nginx/ssl 步驟二：建立伺服器私鑰及憑證建立伺服器私鑰開始建立伺服器私鑰。過程中，將會提示輸入密碼，請牢記此密碼，若忘記或遺失該密碼，將無法存取憑證。1$ sudo openssl genrsa -des3 -out server.key 2048 以下為建立私鑰時可能會看到的訊息123456Generating RSA private key, 2048 bit long modulus....................+++..............................................................+++e is 65537 (0x10001)Enter pass phrase for server.key:Verifying - Enter pass phrase for server.key: 建立伺服器憑證建立時會詢問私鑰密碼，若密碼不正確便無法建立憑證。建立憑證時，最重要的欄位為 Common Name。請在此輸入網域名稱，若沒有網域名稱則輸入網站 IP。並請不要填寫 challenge password 及 optional company name 欄位。 1$ sudo openssl req -new -key server.key -out server.csr 以下為建立憑證時可能會看到的訊息1234567891011121314151617181920Enter pass phrase for server.key:You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &apos;.&apos;, the field will be left blank.-----Country Name (2 letter code) [AU]: TWState or Province Name (full name) [Some-State]: TaipeiLocality Name (eg, city) []: TaipeiOrganization Name (eg, company) [Internet Widgits Pty Ltd]: Example IncOrganizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []: example.comEmail Address []: admin@example.comPlease enter the following &apos;extra&apos; attributesto be sent with your certificate requestA challenge password []:An optional company name []: 步驟三：移除伺服器私鑰密碼(Passphrase)雖然密碼可提供高度的安全性，但若有人重載 nginx 則會產生問題。在 nginx 崩潰或需要重新啟動時，永遠都需要輸入密碼才能使網頁伺服器上線。1$ sudo cp server.key server.key.origin 1$ sudo openssl rsa -in server.key.org -out server.key 步驟四：為憑證簽章可以自行指定該憑證有效期限，在此範例中憑證為 1 年後到期。1$ sudo openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt 現在所需的憑證已產生完畢！ 步驟五：設定憑證開啟 nginx 設定檔，加入以下設定，請記得將 server_name 改為網域名稱或 IP。 12345678910# HTTPS serverserver &#123; listen 443; server_name example.com; ssl on; ssl_certificate /etc/nginx/ssl/server.crt; ssl_certificate_key /etc/nginx/ssl/server.key;&#125; 重新啟動 nginx1$ sudo /etc/init.d/nginx restart 前往 https://domain_name 將會看到自行簽章的憑證。","categories":[{"name":"Server","slug":"Server","permalink":"https://calvertyang.github.io/categories/Server/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://calvertyang.github.io/tags/Linux/"},{"name":"SSL","slug":"SSL","permalink":"https://calvertyang.github.io/tags/SSL/"},{"name":"Nginx","slug":"Nginx","permalink":"https://calvertyang.github.io/tags/Nginx/"}]}]}
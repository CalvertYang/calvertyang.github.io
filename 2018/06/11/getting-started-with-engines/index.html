<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Calvert&#39;s tech blog">
  <meta name="keyword" content="calvert ruby rails ror rubyonrails">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Rails Engine 入門 | Calvert&#39;s murmur
    
  </title>
  <link href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" rel="stylesheet" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrcode.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i = 0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-44933497-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-44933497-2');
  </script>


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Calvert's murmur</span>
    </a>

    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/categories/" class="item-link">Categories</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>

    
      <div id="search-form-wrap">
        <form class="search-form">
          <input type="text" class="ins-search-input search-form-input" placeholder="搜尋" />
          <button type="submit" class="search-form-submit">
            <span class="fa fa-search"></span>
          </button>
        </form>
        <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想找什麼..." />
      <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>
<script>
  (function (window) {
    var INSIGHT_CONFIG = {
      TRANSLATION: {
        POSTS: '文章',
        PAGES: '頁面',
        CATEGORIES: '分類',
        TAGS: '標籤',
        UNTITLED: '無標題',
      },
      ROOT_URL: '/',
      CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
  })(window);
</script>
<script src="/js/insight.js"></script>

      </div>
    

    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/categories/" class="menu-link">Categories</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Rails Engine 入門</h2>
  <p class="post-date">2018-06-11</p>
  <div class="arrow-down">
    <a href="javascript:;" target="_blank" rel="noopener"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><blockquote>
<p>原文：<strong>Ruby on Rails Guides</strong> — <a href="http://guides.rubyonrails.org/engines.html" target="_blank" rel="noopener">Getting Started with Engines</a></p>
</blockquote>
<p><code>Rails::Engine</code> 允許你包裝特定的 Rails 應用程式或功能子集，並與其他應用程式共享或在更大的封裝應用程式中。每個 <code>Rails::Application</code> 都只是一個引擎，它允許簡單的功能及應用程式共享。</p>
<p>任何 <code>Rails::Engine</code> 也是一個 <code>Rails::Railtie</code>，所以在 railties 可用的相同方法（如 <code>rake_tasks</code> 和 <code>generators</code>）和配置選項也可用於引擎。</p>
<p>在本指南中，你將瞭解引擎以及如何透過乾淨且非常易於使用的介面，為主應用程式提供附加功能。</p>
<a id="more"></a>

<p>閱讀本指南後，你將知道：</p>
<ul>
<li>是什麼構成了引擎。</li>
<li>如何產生引擎。</li>
<li>如何為引擎建立功能。</li>
<li>如何將引擎掛載到應用程式中。</li>
<li>如何在應用程式中覆寫引擎功能。</li>
<li>透過載入和配置 Hook 避免載入 Rails 框架。</li>
</ul>
<h3 id="1-什麼是引擎？"><a href="#1-什麼是引擎？" class="headerlink" title="1. 什麼是引擎？"></a>1. 什麼是引擎？</h3><p>引擎可以看成是為主應用程式提供功能的微型應用程式。Rails 應用程式實際上只是一個「增壓」引擎，<code>Rails::Application</code> 類別繼承了許多來自 <code>Rails::Engine</code> 的行為。</p>
<p>因此，引擎和應用程式可以被認為是幾乎相同的東西，只有存在細微的差異，你將在本指南中看到。引擎和應用程式也共享一個公用的結構。</p>
<p>引擎也與外掛程式密切相關。兩者共享一個公用的 <code>lib</code> 目錄結構，並且都是使用 <code>rails plugin new</code> 產生器產生的。不同之處在於，引擎被 Rails 視為一個「完整外掛程式」（如傳遞給產生器指令的 <code>--full</code> 選項所示）。我們實際上會在此處使用 <code>--mountable</code> 選項，其中包含 <code>--full</code> 的所有功能，甚至更多。本指南全文將這些「完整外掛程式」簡稱為「引擎」。引擎<strong>可以</strong>是外掛程式，外掛程式<strong>可以</strong>是引擎。</p>
<p>將在本指南中建立的引擎稱為「blorgh」。此引擎將為其主應用程式提供部落格功能，允許建立新文章和評論。在本指南的開頭，你將獨自在引擎內工作，但在後面的章節中，你將看到如何將其掛載到應用程式中。</p>
<p>引擎也可以與主應用程式隔離。意思是應用程式可以擁有路由輔助方法提供的路徑，如 <code>articles_path</code>，並使用一個也提供了名為 <code>articles_path</code> 路徑的引擎，而且兩者不會發生衝突。除此之外，控制器、模型和資料表名稱也具有命名空間。本指南稍後將介紹如何執行此操作。</p>
<p>重要的是在任何時候牢記這一點，應用程式應該<strong>總是</strong>優先於其引擎。應用程式是對其環境中發生的事情有最終決定權的物件。引擎應該只是加強它，而不是徹底改變它。</p>
<p>查看其他引擎的範例，查看 <a href="https://github.com/plataformatec/devise" target="_blank" rel="noopener">Devise</a>，一個為其父應用程式提供身份驗證的引擎，或 <a href="https://github.com/thredded/thredded" target="_blank" rel="noopener">Thredded</a>，一個提供論壇功能的引擎。還有 <a href="https://github.com/spree/spree" target="_blank" rel="noopener">Spree</a> 提供電子商務平台，以及 <a href="https://github.com/refinery/refinerycms" target="_blank" rel="noopener">Refinery CMS</a>，一個 CMS 引擎。</p>
<p>最後，如果沒有 James Adam、Piotr Sarnacki、Rails 核心團隊和其他一些人的工作，引擎是不可能實現的。如果你見過他們，別忘了說聲謝謝！</p>
<h3 id="2-產生一個引擎"><a href="#2-產生一個引擎" class="headerlink" title="2. 產生一個引擎"></a>2. 產生一個引擎</h3><p>要產生引擎，你需要執行外掛程式產生器並根據需求將選項傳遞給它。對於「blorgh」範例，你需要建立一個「可掛載的」引擎，在終端機中執行此指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rails plugin new blorgh --mountable</span><br></pre></td></tr></table></figure>

<p>輸入以下內容即可看到外掛程式產生器的完整選項清單：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rails plugin --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p><code>--mountable</code> 選項告訴產生器你想建立一個「可掛載的」且命名空間隔離的引擎。此產生器將提供與 <code>--full</code> 選項相同的骨架結構。<code>--full</code> 選項告訴產生器你想建立一個引擎，包含提供以下內容的骨架結構：</p>
<ul>
<li><p>一個 <code>app</code> 目錄樹</p>
</li>
<li><p>一個 <code>config/routes.rb</code> 檔案：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rails.application.routes.draw <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一個在 <code>lib/blorgh/engine.rb</code> 的檔案，其功能與標準 Rails 應用程式的 <code>config/application.rb</code> 檔案相同：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Blorgh</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> &lt; ::<span class="title">Rails::Engine</span></span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>--mountable</code> 選項會加入 <code>--full</code> 選項：</p>
<ul>
<li><p>靜態資源清單檔案（<code>application.js</code> 和 <code>application.css</code>）</p>
</li>
<li><p>一個具有命名空間的 <code>ApplicationController</code></p>
</li>
<li><p>一個具有命名空間的 <code>ApplicationHelper</code></p>
</li>
<li><p>引擎的佈局視圖樣板</p>
</li>
<li><p>命名空間隔離的 <code>config/routes.rb</code>：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blorgh::Engine.routes.draw <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>命名空間隔離的 <code>lib/blorgh/engine.rb</code>：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Blorgh</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> &lt; ::<span class="title">Rails::Engine</span></span></span><br><span class="line">    isolate_namespace Blorgh</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>此外，<code>--mountable</code> 選項透過將以下內容加到虛擬應用程式的路由檔案 <code>test/dummy/config/routes.rb</code>，告訴產生器將引擎掛載到位於 <code>test/dummy</code> 的虛擬測試應用程式中：</p>
  <figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount Blorgh::Engine =&gt; <span class="string">"/blorgh"</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-引擎內部"><a href="#2-1-引擎內部" class="headerlink" title="2.1 引擎內部"></a>2.1 引擎內部</h4><h5 id="2-1-1-關鍵檔案"><a href="#2-1-1-關鍵檔案" class="headerlink" title="2.1.1 關鍵檔案"></a>2.1.1 關鍵檔案</h5><p>在這個全新引擎的根目錄有個 <code>blorgh.gemspec</code> 檔案。當你稍後將引擎掛載到應用程式中時，你將在 Rails 應用程式的 <code>Gemfile</code> 中使用此行進行操作：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="string">'blorgh'</span>, <span class="symbol">path:</span> <span class="string">'engines/blorgh'</span></span><br></pre></td></tr></table></figure>

<p>不要忘記像往常一樣執行 <code>bundle install</code>。透過在 <code>Gemfile</code> 中指定它作為一個 gem，Bundler 將載入它，解析此 <code>blorgh.gemspec</code> 檔案並載入 <code>lib</code> 目錄中的一個名為 <code>lib/blorgh.rb</code> 的檔案。這個檔案載入了 <code>blorgh/engine.rb</code> 檔案（位於 <code>lib/blorgh/engine.rb</code>）並定義了一個名為 <code>Blorgh</code> 的基本模組。</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">"blorgh/engine"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Blorgh</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>有些引擎選擇使用這個檔案為其引擎提供全域配置選項。這是一個比較好的想法，所以如果你想提供配置選項，那麼定義引擎 <code>module</code> 的檔案就是完美的選擇。把方法放到模組裡面就可以了。</p>
</blockquote>
<p><code>lib/blorgh/engine.rb</code> 是引擎的基底類別：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Blorgh</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> &lt; ::<span class="title">Rails::Engine</span></span></span><br><span class="line">    isolate_namespace Blorgh</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>透過繼承 <code>Rails::Engine</code> 類別，這個 gem 會通知 Rails 在指定路徑上有一個引擎，並且將引擎正確地掛載到應用程式，執行諸如將引擎的 <code>app</code> 目錄加到模型、Mailer、控制器和視圖的載入路徑。</p>
<p>這裡的 <code>isolate_namespace</code> 方法值得特別注意。這個呼叫負責將控制器、模型、路由和其他東西隔離到自己的命名空間中，使其遠離應用程式內部的類似元件。沒有這個，引擎的元件就有可能「洩漏」到應用程式，造成不必要的中斷，或者重要的引擎元件可能會被應用程式中類似名稱的東西覆蓋。這種衝突的其中一個例子就是輔助方法。在不呼叫 <code>isolate_namespace</code> 的情況下，引擎的輔助方法將被包含在應用程式的控制器中。</p>
<blockquote>
<p><strong>高度</strong>推薦在 <code>Engine</code> 類別定義中保留 <code>isolate_namespace</code>。如果沒有它，引擎中產生的類別<strong>可能</strong> 會與應用程式發生衝突。</p>
</blockquote>
<p>此命名空間的隔離意思是透過呼叫 <code>bin/rails g model</code> 產生的模型，如 <code>bin/rails g model article</code>，名稱不是 <code>Article</code>，而是具有命名空間的名稱 <code>Blorgh::Article</code>。另外，模型的資料表也具有命名空間，成為 <code>blorgh_articles</code>，而不僅僅是 <code>articles</code>。與模型命名空間類似，一個名為 <code>ArticlesController</code> 的控制器變成了 <code>Blorgh::ArticlesController</code>，並且該控制器的視圖不會在 <code>app/views/articles</code>，而是 <code>app/views/blorgh/articles</code>。Mailer 也具有命名空間。</p>
<p>最後，路由也被隔離在引擎內。這是命名空間中最重要的部分之一，稍後將在本指南的<a href="http://guides.rubyonrails.org/engines.html#routes" target="_blank" rel="noopener">路由</a>部分中進行討論。</p>
<h5 id="2-1-2-app-目錄"><a href="#2-1-2-app-目錄" class="headerlink" title="2.1.2 app 目錄"></a>2.1.2 app 目錄</h5><p>在 app 目錄中有標準的 <code>assets</code>、<code>controllers</code>、<code>helpers</code>、<code>mailers</code>、<code>models</code> 和 <code>views</code> 目錄，你應該已從應用程式對這些目錄瞭若指掌。<code>helpers</code>、<code>mailers</code> 和 <code>models</code> 目錄是空的，因此在本節中沒有描述它們。當我們編寫引擎時，我們將在未來的章節中更深入地研究模型。</p>
<p>在 <code>app/assets</code> 目錄中，有 <code>images</code>、<code>javascripts</code> 和 <code>stylesheets</code> 目錄，你應該早已熟悉這些目錄，因為它們與應用程式類似。然而，這裡的一個不同之處在於，每個目錄都包含一個帶有引擎名稱的子目錄。因為這個引擎具有命名空間，它的靜態資源也應該如此。</p>
<p>在 <code>app/controllers</code> 目錄中有一個 <code>blorgh</code> 目錄，其中包含了一個名為 <code>application_controller.rb</code> 的檔案。該檔案將為引擎的控制器提供任何公用功能。<code>blorgh</code> 目錄是存放引擎的其它控制器的地方。透過將它們放在這個命名空間的目錄中，可以防止它們與其它引擎甚至是應用程式中的同名控制器發生衝突。</p>
<blockquote>
<p>引擎內的 <code>ApplicationController</code> 類別命名就像一個 Rails 應用程式，以便更容易將應用程式轉換為引擎。</p>
</blockquote>
<blockquote>
<p>因為 Ruby 不斷尋找的方式，你可能會遇到一種狀況，你的控制器繼承自主應用程式控制器，而不是你的引擎應用程式控制器。Ruby 能夠解析 <code>ApplicationController</code> 常數，因此不會觸發自動載入機制。有關更多詳細資訊，請查看<a href="http://guides.rubyonrails.org/autoloading_and_reloading_constants.html" target="_blank" rel="noopener">自動載入和重新載入常數</a>指南中的<a href="http://guides.rubyonrails.org/autoloading_and_reloading_constants.html#when-constants-aren-t-missed" target="_blank" rel="noopener">常數什麼時候不被忽略</a>章節。預防這種狀況發生最好的方法是使用 <code>require_dependency</code> 來確保引擎的應用程式控制器已被載入。例如：</p>
</blockquote>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/controllers/blorgh/articles_controller.rb:</span></span><br><span class="line">require_dependency <span class="string">"blorgh/application_controller"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Blorgh</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ArticlesController</span> &lt; ApplicationController</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>不要使用 <code>require</code>，因為它會中斷開發環境中類別的自動重新載入，使用 <code>require_dependency</code> 確保類別以正確的方式載入和卸除。</p>
<p>最後，<code>app/views</code>目錄中有一個 <code>layouts</code> 資料夾，其中包含了一個檔案在 <code>blorgh/application.html.erb</code>。該檔案允許你指定引擎的佈局。如果此引擎要作為獨立引擎使用，那麼你可以在此檔案中加入任何對佈局的客製化，而不是應用程式的 <code>app/views/layouts/application.html.erb</code> 檔案。</p>
<p>如果不希望對引擎的使用者強制佈局，那麼可以刪除此檔案並在引擎的控制器中引用不同的佈局。</p>
<h5 id="2-1-3-bin-目錄"><a href="#2-1-3-bin-目錄" class="headerlink" title="2.1.3 bin 目錄"></a>2.1.3 bin 目錄</h5><p>這個目錄包含一個 <code>bin/rails</code> 檔案，它讓你能夠像在應用程式中一樣使用 <code>rails</code> 子指令和產生器。也就是說，你可以很容易地透過執行這樣的指令來產生新的控制器和模型：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/rails g model</span><br></pre></td></tr></table></figure>

<p>請記住，在 <code>Engine</code> 類別中具有 <code>isolate_namespace</code> 的引擎內部使用這些指令產生的任何東西，都將具有命名空間。</p>
<h5 id="2-1-4-test-目錄"><a href="#2-1-4-test-目錄" class="headerlink" title="2.1.4 test 目錄"></a>2.1.4 test 目錄</h5><p><code>test</code> 目錄是用來存放引擎測試的地方。為了測試引擎，在 <code>test/dummy</code> 中嵌入了一個精簡版的 Rails 應用程式。這個應用程式會將引擎掛載到 <code>test/dummy/config/routes.rb</code> 檔案：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rails.application.routes.draw <span class="keyword">do</span></span><br><span class="line">  mount Blorgh::Engine =&gt; <span class="string">"/blorgh"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>該行將引擎掛載到 <code>/blorgh</code> 路徑上，這將使應用程式僅能透過該路徑存取它。</p>
<p>在測試目錄裡面有 <code>test/integration</code> 目錄，引擎的整合測試應該放在這裡。也可以在 <code>test</code> 目錄中建立其它目錄。例如，你可能希望為模型測試建立一個 <code>test/models</code> 目錄。</p>
<h3 id="3-提供引擎功能"><a href="#3-提供引擎功能" class="headerlink" title="3. 提供引擎功能"></a>3. 提供引擎功能</h3><p>本指南涵蓋的引擎提供了送交文章和評論的功能，遵循與<a href="http://guides.rubyonrails.org/getting_started.html" target="_blank" rel="noopener">入門指南</a>類似的思路，並伴隨一些新的觀點。</p>
<h4 id="3-1-產生-Article-資源"><a href="#3-1-產生-Article-資源" class="headerlink" title="3.1 產生 Article 資源"></a>3.1 產生 Article 資源</h4><p>產生部落格引擎的第一件事是 <code>Article</code> 模型和相關的控制器。要快速建立這個，你可以使用 Rails 鷹架產生器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/rails generate scaffold article title:string text:text</span><br></pre></td></tr></table></figure>

<p>該指令會輸出以下資訊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">invoke  active_record</span><br><span class="line">create    db/migrate/[timestamp]_create_blorgh_articles.rb</span><br><span class="line">create    app/models/blorgh/article.rb</span><br><span class="line">invoke    test_unit</span><br><span class="line">create      <span class="built_in">test</span>/models/blorgh/article_test.rb</span><br><span class="line">create      <span class="built_in">test</span>/fixtures/blorgh/articles.yml</span><br><span class="line">invoke  resource_route</span><br><span class="line"> route    resources :articles</span><br><span class="line">invoke  scaffold_controller</span><br><span class="line">create    app/controllers/blorgh/articles_controller.rb</span><br><span class="line">invoke    erb</span><br><span class="line">create      app/views/blorgh/articles</span><br><span class="line">create      app/views/blorgh/articles/index.html.erb</span><br><span class="line">create      app/views/blorgh/articles/edit.html.erb</span><br><span class="line">create      app/views/blorgh/articles/show.html.erb</span><br><span class="line">create      app/views/blorgh/articles/new.html.erb</span><br><span class="line">create      app/views/blorgh/articles/_form.html.erb</span><br><span class="line">invoke    test_unit</span><br><span class="line">create      <span class="built_in">test</span>/controllers/blorgh/articles_controller_test.rb</span><br><span class="line">invoke    helper</span><br><span class="line">create      app/helpers/blorgh/articles_helper.rb</span><br><span class="line">invoke  test_unit</span><br><span class="line">create    <span class="built_in">test</span>/application_system_test_case.rb</span><br><span class="line">create    <span class="built_in">test</span>/system/articles_test.rb</span><br><span class="line">invoke  assets</span><br><span class="line">invoke    js</span><br><span class="line">create      app/assets/javascripts/blorgh/articles.js</span><br><span class="line">invoke    css</span><br><span class="line">create      app/assets/stylesheets/blorgh/articles.css</span><br><span class="line">invoke  css</span><br><span class="line">create    app/assets/stylesheets/scaffold.css</span><br></pre></td></tr></table></figure>

<p>鷹架產生器所做的第一件事是呼叫 <code>active_record</code> 產生器，它為資源產生遷移和模型。但是請注意，遷移被命名為 <code>create_blorgh_articles</code>，而不是常見的 <code>create_articles</code>。這是由於 <code>Blorgh::Engine</code> 類別的定義中呼叫 <code>isolate_namespace</code> 方法造成的。這裡的模型也具有命名空間，由於 <code>Engine</code> 類別中呼叫 <code>isolate_namespace</code>，所以放在 <code>app/models/blorgh/article.rb</code> 而不是 <code>app/models/article.rb</code>。</p>
<p>接下來，為此模型呼叫 <code>test_unit</code> 產生器，在 <code>test/models/blorgh/article_test.rb</code>（而不是 <code>test/models/article_test.rb</code>）產生一個模型測試，並在 <code>test/fixtures/blorgh/articles.yml</code>（而不是 <code>test/fixtures/articles.yml</code>）產生測試資料。</p>
<p>然後，插入一行資源路由到引擎的 <code>config/routes.rb</code> 檔案。這一行只是 <code>resources :articles</code>，將引擎的 <code>config/routes.rb</code> 檔案變成這樣：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Blorgh::Engine.routes.draw <span class="keyword">do</span></span><br><span class="line">  resources <span class="symbol">:articles</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>這裡請注意，路由是被定義在 <code>Blorgh::Engine</code> 物件上，而不是 <code>YourApp::Application</code> 類別。這是為了使引擎路由被限制在引擎本身，並且如<a href="http://guides.rubyonrails.org/engines.html#test-directory" target="_blank" rel="noopener">測試目錄</a>部分所示可以掛載在特定點上。它還會使引擎的路由與應用程式內的路由隔離。本指南的<a href="http://guides.rubyonrails.org/engines.html#routes" target="_blank" rel="noopener">路由</a>部分有詳細的說明。</p>
<p>接下來，<code>scaffold_controller</code> 產生器被呼叫，產生一個名為 <code>Blorgh::ArticlesController</code>（在 <code>app/controllers/blorgh/articles_controller.rb</code>）的控制器及其相關視圖在 <code>app/views/blorgh/articles</code>。此產生器還為控制器產生測試（<code>test/controllers/blorgh/articles_controller_test.rb</code>）和輔助方法（<code>app/helpers/blorgh/articles_helper.rb</code>）。</p>
<p>這個產生器建立的所有東西都具有命名空間。控制器的類別被定義在 <code>Blorgh</code> 模組：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Blorgh</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ArticlesController</span> &lt; ApplicationController</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ArticlesController</code> 類別繼承自 <code>Blorgh::ApplicationController</code>，而不是應用程式的 <code>ApplicationController</code>。</p>
</blockquote>
<p><code>app/helpers/blorgh/articles_helper.rb</code> 中的輔助方法也具有命名空間：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Blorgh</span></span></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">ArticlesHelper</span></span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>這有助於防止與任何其它可能具有文章資源的引擎或應用程式發生衝突。</p>
<p>最後，產生了兩個靜態資源檔案：<code>app/assets/javascripts/blorgh/articles.js</code> 和 <code>app/assets/stylesheets/blorgh/articles.css</code>。稍後你會看到如何使用這些東西。</p>
<p>你可以透過在引擎的根目錄執行 <code>bin/rails db:migrate</code> 來執行由鷹架產生器產生的遷移，然後在 <code>test/dummy</code> 中執行 <code>rails server</code> 來查看引擎的內容。當你開啟 <code>http://localhost:3000/blorgh/articles</code> 時，將看到已產生的預設鷹架。點看看吧！你剛剛產生了你的第一個引擎的第一個功能。</p>
<p>如果你更喜歡使用主控台，也可以像 Rails 應用程式一樣使用 <code>rails console</code>。記住：<code>Article</code> 模型是具有命名空間的，因此要引用它，你必須稱呼它為 <code>Blorgh::Article</code>。</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span> Blorgh::Article.find(<span class="number">1</span>)</span><br><span class="line">=&gt; #&lt;Blorgh::Article id: 1 ...&gt;</span><br></pre></td></tr></table></figure>

<p>最後一件事是這個引擎的 <code>articles</code> 資源應該是引擎的根。每當有人進入掛載引擎的根路徑時，應該顯示文章列表。如果將此行插入引擎內的 <code>config/routes.rb</code> 檔案中，便可以實現這一點：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root <span class="symbol">to:</span> <span class="string">"articles#index"</span></span><br></pre></td></tr></table></figure>

<p>現在人們只需要到引擎的根目錄來查看所有文章，而不是訪問 <code>/articles</code>。意思是現在你只需要去 <code>http://localhost:3000/blorgh</code>，而不是 <code>http://localhost:3000/blorgh/articles</code>。</p>
<h4 id="3-2-產生-Comments-資源"><a href="#3-2-產生-Comments-資源" class="headerlink" title="3.2 產生 Comments 資源"></a>3.2 產生 Comments 資源</h4><p>現在，引擎可以建立新的文章，那麼加上評論功能也是有意義的。為此，你需要建立評論模型、評論控制器，然後修改文章鷹架以顯示評論並允許人們建立新評論。</p>
<p>從應用程式根目錄執行模型產生器。告訴它產生一個 <code>Comment</code> 模型，資料表有兩欄：integer 型別的 <code>article_id</code> 和 text 型別的 <code>text</code> 欄位。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/rails generate model Comment article_id:<span class="built_in">integer</span> text:text</span><br></pre></td></tr></table></figure>

<p>這將輸出以下內容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">invoke  active_record</span><br><span class="line">create    db/migrate/[timestamp]_create_blorgh_comments.rb</span><br><span class="line">create    app/models/blorgh/comment.rb</span><br><span class="line">invoke    test_unit</span><br><span class="line">create      <span class="built_in">test</span>/models/blorgh/comment_test.rb</span><br><span class="line">create      <span class="built_in">test</span>/fixtures/blorgh/comments.yml</span><br></pre></td></tr></table></figure>

<p>該產生器呼叫將產生它所需的必要模型檔案，將檔案放在命名空間 <code>blorgh</code> 目錄下，並建立一個名為 <code>Blorgh::Comment</code> 的模型類別。現在執行遷移來建立我們的 blorgh_comments 資料表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/rails db:migrate</span><br></pre></td></tr></table></figure>

<p>要在文章上顯示評論，編輯 <code>app/views/blorgh/articles/show.html.erb</code> 並在「編輯」連結前加上此行：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Comments<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> render @article.comments </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>這一行需要在 <code>Blorgh::Article</code> 模型中定義一個 <code>has_many</code> 關聯的評論，不過現在還沒有。要定義它，開啟 <code>app/models/blorgh/article.rb</code> 並將這一行加到模型中：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">has_many <span class="symbol">:comments</span></span><br></pre></td></tr></table></figure>

<p>將模型變成：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Blorgh</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Article</span> &lt; ApplicationRecord</span></span><br><span class="line">    has_many <span class="symbol">:comments</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因為 <code>has_many</code> 是在 <code>Blorgh</code> 模組的一個類別中定義的，Rails 會知道你想為這些物件使用 <code>Blorgh::Comment</code> 模型，所以不需要在這裡指定使用 <code>:class_name</code> 選項。</p>
</blockquote>
<p>接下來，需要有一個表單，以便可以在文章上建立評論。要加上它，在 <code>app/views/blorgh/articles/show.html.erb</code> 中呼叫呈現 <code>@article.comments</code> 的下方加上這一行：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> render <span class="string">"blorgh/comments/form"</span> </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>接下來，這一行將呈現的部分視圖需要存在。建立一個新目錄在 <code>app/views/blorgh/comments</code>，並且建立一個名為 <code>_form.html.erb</code> 的新檔案，該檔案包含這些內容以便建立所需的部分視圖：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>New comment<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> form_with(<span class="symbol">model:</span> [@article, @article.comments.build], <span class="symbol">local:</span> <span class="literal">true</span>) <span class="keyword">do</span> <span class="params">|form|</span> </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> form.label <span class="symbol">:text</span> </span><span class="xml"><span class="tag">%&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> form.text_area <span class="symbol">:text</span> </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> form.submit </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> <span class="keyword">end</span> </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>送交此表單時，它將嘗試對引擎內的 <code>/articles/:article_id/comments</code> 路由執行 <code>POST</code> 請求。此路由目前不存在，但是可以透過將 <code>config/routes.rb</code> 中的 <code>resources :articles</code> 更改為以下幾行來建立：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resources <span class="symbol">:articles</span> <span class="keyword">do</span></span><br><span class="line">  resources <span class="symbol">:comments</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>這會為評論建立一個表單所需要的巢狀路由。</p>
<p>路由現在已經存在了，但是此路由所去的控制器還不存在。要建立它，從應用程式根目錄執行這個指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/rails g controller comments</span><br></pre></td></tr></table></figure>

<p>該指令會輸出以下資訊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create  app/controllers/blorgh/comments_controller.rb</span><br><span class="line">invoke  erb</span><br><span class="line"> exist    app/views/blorgh/comments</span><br><span class="line">invoke  test_unit</span><br><span class="line">create    <span class="built_in">test</span>/controllers/blorgh/comments_controller_test.rb</span><br><span class="line">invoke  helper</span><br><span class="line">create    app/helpers/blorgh/comments_helper.rb</span><br><span class="line">invoke  assets</span><br><span class="line">invoke    js</span><br><span class="line">create      app/assets/javascripts/blorgh/comments.js</span><br><span class="line">invoke    css</span><br><span class="line">create      app/assets/stylesheets/blorgh/comments.css</span><br></pre></td></tr></table></figure>

<p>該表單會向 <code>/articles/:article_id/comments</code> 發出 <code>POST</code> 請求，對應到 <code>Blorgh::CommentsController</code> 中的 <code>create</code> 動作。這個動作需要被建立，可以透過在 <code>app/controllers/blorgh/comments_controller.rb</code> 的類別定義中放入以下幾行來完成：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span></span></span><br><span class="line">  @article = Article.find(params[<span class="symbol">:article_id</span>])</span><br><span class="line">  @comment = @article.comments.create(comment_params)</span><br><span class="line">  flash[<span class="symbol">:notice</span>] = <span class="string">"Comment has been created!"</span></span><br><span class="line">  redirect_to articles_path</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">private</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">comment_params</span></span></span><br><span class="line">    params.<span class="keyword">require</span>(<span class="symbol">:comment</span>).permit(<span class="symbol">:text</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>這是讓新評論表單運作所需的最後一步。然而，顯示評論還不太正確。如果你現在要建立評論，則會看到此錯誤：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Missing partial blorgh/comments/_comment with &#123;<span class="symbol">:handlers=&gt;</span>[<span class="symbol">:erb</span>, <span class="symbol">:builder</span>],</span><br><span class="line"><span class="symbol">:formats=&gt;</span>[<span class="symbol">:html</span>], <span class="symbol">:locale=&gt;</span>[<span class="symbol">:en</span>, <span class="symbol">:en</span>]&#125;. Searched <span class="symbol">in:</span>   *</span><br><span class="line"><span class="string">"/Users/ryan/Sites/side_projects/blorgh/test/dummy/app/views"</span>   *</span><br><span class="line"><span class="string">"/Users/ryan/Sites/side_projects/blorgh/app/views"</span></span><br></pre></td></tr></table></figure>

<p>引擎無法找到呈現評論所需的部分視圖。Rails 會先尋找應用程式的（<code>test/dummy</code>）<code>app/views</code>目錄，然後在引擎的 <code>app/views</code> 目錄中尋找。當找不到它時，便會拋出這個錯誤。引擎知道要尋找 <code>blorgh/comments/_comment</code>，因為它接收的模型物件是來自 <code>Blorgh::Comment</code> 類別。</p>
<p>目前，這個部分視圖僅負責呈現評論文字。在 <code>app/views/blorgh/comments/_comment.html.erb</code> 建立新一個檔案，並將此行放入其中：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> comment_counter + <span class="number">1</span> </span><span class="xml"><span class="tag">%&gt;</span>. <span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> comment.text </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><code>comment_counter</code> 區域變數是由呼叫 <code>&lt;%= render @article.comments %&gt;</code> 給我們的，它會自動定義並在迭代每個評論時遞增計數器。在這個例子中，它用於在每個評論建立時顯示一個小數字。</p>
<p>完成了部落格引擎的評論功能。現在是時候在應用程式中使用它了。</p>
<h3 id="4-安裝到應用程式"><a href="#4-安裝到應用程式" class="headerlink" title="4. 安裝到應用程式"></a>4. 安裝到應用程式</h3><p>在應用程式中使用引擎非常簡單。本節會介紹如何將引擎掛載到應用程式和所需的初始設定，以及將引擎連結到由應用程式提供的 <code>User</code> 類別，以便為引擎中的文章和評論提供所有權。</p>
<h4 id="4-1-掛載引擎"><a href="#4-1-掛載引擎" class="headerlink" title="4.1 掛載引擎"></a>4.1 掛載引擎</h4><p>首先，需要在應用程式的 <code>Gemfile</code> 中指定引擎。如果沒有應用程式可以方便地進行測試，可以像這樣在引擎目錄外使用 <code>rails new</code> 指令產生一個：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rails new unicorn</span><br></pre></td></tr></table></figure>

<p>通常，可以像一般的 gem 一樣，透過在 <code>Gemfile</code> 內將引擎指定在內來完成。</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="string">'devise'</span></span><br></pre></td></tr></table></figure>

<p>但是，因為你正在本機上開發 <code>blorgh</code> 引擎，你需要在 <code>Gemfile</code> 指定 <code>:path</code> 選項：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="string">'blorgh'</span>, <span class="symbol">path:</span> <span class="string">'engines/blorgh'</span></span><br></pre></td></tr></table></figure>

<p>然後執行 <code>bundle</code> 來安裝 gem。</p>
<p>如先前所述，透過將 gem 放在 <code>Gemfile</code> 中，它將會在 Rails 載入時被載入。它會先從引擎載入 <code>lib/blorgh.rb</code>，然後是 <code>lib/blorgh/engine.rb</code>，它是定義引擎主要功能的檔案。</p>
<p>要讓引擎的功能可以從應用程式存取，需要將它掛載到應用程式的 <code>config/routes.rb</code> 檔案：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount Blorgh::Engine, <span class="symbol">at:</span> <span class="string">"/blog"</span></span><br></pre></td></tr></table></figure>

<p>這一行會將引擎掛載到應用程式中的 <code>/blog</code>。當應用程式以 <code>rails server</code> 執行時，可以在 <code>http://localhost:3000/blog</code> 上訪問它。</p>
<blockquote>
<p>其他引擎，如 Devise，透過讓你在路由中指定自訂輔助方法（例如 <code>devise_for</code>）來處理這一點。這些輔助方法完成相同的事，將引擎的部分功能掛載到預先定義可客製化的路徑上。</p>
</blockquote>
<h4 id="4-2-安裝引擎"><a href="#4-2-安裝引擎" class="headerlink" title="4.2 安裝引擎"></a>4.2 安裝引擎</h4><p>引擎包含需要在應用程式資料庫中建立的 <code>blorgh_articles</code> 和 <code>blorgh_comments</code> 資料表的遷移，以便引擎的模型可以正確查詢它們。要將這些遷移複製到應用程式中，請從 Rails 引擎的 <code>test/dummy</code> 目錄執行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/rails blorgh:install:migrations</span><br></pre></td></tr></table></figure>

<p>如果你有多個需要複製遷移的引擎，請改用 <code>railties:install:migrations</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/rails railties:install:migrations</span><br></pre></td></tr></table></figure>

<p>第一次執行這個指令時，將複製引擎中的所有遷移。下次執行時，它只會複製尚未被複製的遷移。第一次執行指令會輸出以下資訊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copied migration [timestamp_1]_create_blorgh_articles.blorgh.rb from blorgh</span><br><span class="line">Copied migration [timestamp_2]_create_blorgh_comments.blorgh.rb from blorgh</span><br></pre></td></tr></table></figure>

<p>第一個時間戳記（<code>[timestamp_1]</code>）將是目前時間，第二個時間戳記（<code>[timestamp_2]</code>）將是目前時間加上一秒。之所以這樣做是為了在應用程式中任何現有的遷移之後執行引擎的遷移。</p>
<p>要在應用程式中執行這些遷移，只需執行：<code>bin/rails db:migrate</code>。當透過 <code>http://localhost:3000/blog</code> 訪問引擎時，文章會是空的。這是因為在應用程式建立的資料表與引擎內建立的資料表不同。繼續，玩玩新掛載的引擎吧。你會發現它和只有一個引擎時是相同的。</p>
<p>如果你只想從一個引擎執行遷移，可以透過指定 <code>SCOPE</code> 來完成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/rails db:migrate SCOPE=blorgh</span><br></pre></td></tr></table></figure>

<p>如果你想在刪除引擎之前還原引擎的遷移，這可能很有用。要還原 blorgh 引擎的所有遷移，你可以執行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/rails db:migrate SCOPE=blorgh VERSION=0</span><br></pre></td></tr></table></figure>

<h4 id="4-3-使用應用程式提供的類別"><a href="#4-3-使用應用程式提供的類別" class="headerlink" title="4.3 使用應用程式提供的類別"></a>4.3 使用應用程式提供的類別</h4><h5 id="4-3-1-使用應用程式提供的模型"><a href="#4-3-1-使用應用程式提供的模型" class="headerlink" title="4.3.1 使用應用程式提供的模型"></a>4.3.1 使用應用程式提供的模型</h5><p>引擎建立後，可能需要使用應用程式中的特定類別來提供引擎和應用程式之間的連結。以 <code>blorgh</code> 引擎的情況來說，讓文章和評論有作者會很有意義。</p>
<p>一個典型的應用程式可能有一個 <code>User</code> 類別，用於表示文章或評論的作者。但可能會出現這樣的情況，應用程式以不同名稱命名此類別，如 <code>Person</code>。因此，引擎不應該明確的為 <code>User</code> 類別寫死關聯。</p>
<p>為了在這種情況下保持簡單，應用程式將有一個名為 <code>User</code> 的類別，來表示應用程式的使用者（我們將進一步進行配置）。它可以在應用程式中使用這個指令產生：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/rails g model user name:string</span><br></pre></td></tr></table></figure>

<p>需要在這裡執行 <code>bin/rails db:migrate</code> 指令，以確保我們的應用程式有 <code>users</code> 資料表供將來使用。</p>
<p>同樣地，為了簡單起見，文章表單會有一個名為 <code>author_name</code> 的新文字欄位，使用者可以選擇放置他們的名字。引擎將使用這個名稱建立一個新的 <code>User</code> 物件或者尋找一個擁有該名稱的物件。引擎會將文章與找到或建立的 <code>User</code> 物件建立關聯。</p>
<p>首先，<code>author_name</code> 文字欄位需要被加到引擎內的 <code>app/views/blorgh/articles/_form.html.erb</code> 部分視圖。可以在 <code>title</code> 欄位上方加入以下程式碼：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"field"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> form.label <span class="symbol">:author_name</span> </span><span class="xml"><span class="tag">%&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> form.text_field <span class="symbol">:author_name</span> </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>接下來，我們需要更新 <code>Blorgh::ArticleController#article_params</code> 方法來允許新的表單參數：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">article_params</span></span></span><br><span class="line">  params.<span class="keyword">require</span>(<span class="symbol">:article</span>).permit(<span class="symbol">:title</span>, <span class="symbol">:text</span>, <span class="symbol">:author_name</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><code>Blorgh::Article</code> 模型應該有一些程式碼將 <code>author_name</code> 欄位轉換為一個實際的 <code>User</code> 物件，並在儲存文章前將其關聯為該文章的 <code>author</code>。它還需要為此欄位設定一個 <code>attr_accessor</code>，以便為其定義設值（setter）方法和取值（getter）方法。</p>
<p>為此，你需要在 <code>app/models/blorgh/article.rb</code> 為 <code>author_name</code> 加上 <code>attr_accessor</code>、作者的關聯和 <code>before_validation</code> 呼叫。<code>author</code> 關聯會暫時寫死到 <code>User</code> 類別。</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attr_accessor</span> <span class="symbol">:author_name</span></span><br><span class="line">belongs_to <span class="symbol">:author</span>, <span class="symbol">class_name:</span> <span class="string">"User"</span></span><br><span class="line"></span><br><span class="line">before_validation <span class="symbol">:set_author</span></span><br><span class="line"></span><br><span class="line">private</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set_author</span></span></span><br><span class="line">    <span class="keyword">self</span>.author = User.find_or_create_by(<span class="symbol">name:</span> author_name)</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>透過用 <code>User</code> 類別表示 <code>author</code> 關聯的物件，在引擎和應用程式之間建立了一個連結。需要有一種方法將 <code>blorgh_articles</code> 資料表中的記錄與 <code>users</code> 資料表中的記錄關聯起來。因為該關聯名為 <code>author</code>，所以應該在 <code>blorgh_articles</code> 資料表中加上 <code>author_id</code> 欄位。</p>
<p>要產生這個新欄位，請在引擎中執行這個指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/rails g migration add_author_id_to_blorgh_articles author_id:<span class="built_in">integer</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由於遷移的名稱和後面的欄位說明，Rails 會自動知道你想要將欄位加到特定資料表，並將其寫入遷移中。因此不用手動編寫遷移。</p>
</blockquote>
<p>這個遷移需要在應用程式上執行。為此，首先必須使用這個指令複製它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/rails blorgh:install:migrations</span><br></pre></td></tr></table></figure>

<p>請注意，這裡只複製了一個遷移。這是因為前兩次遷移已經在第一次執行這個指令時被複製了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NOTE Migration [timestamp]_create_blorgh_articles.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.</span><br><span class="line">NOTE Migration [timestamp]_create_blorgh_comments.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.</span><br><span class="line">Copied migration [timestamp]_add_author_id_to_blorgh_articles.blorgh.rb from blorgh</span><br></pre></td></tr></table></figure>

<p>使用以下指令執行遷移：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/rails db:migrate</span><br></pre></td></tr></table></figure>

<p>現在，一切都已經到位，我們完成了作者（用 <code>users</code> 資料表中的記錄表示）與文章（用引擎的 <code>blorgh_articles</code> 資料表中的記錄表示）的關聯。</p>
<p>最後，作者的名稱應該會顯示在文章頁面。在 <code>app/views/blorgh/articles/show.html.erb</code> 內的「標題」輸出上方加上以下程式碼：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">b</span>&gt;</span>Author:<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> @article.author.name </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="4-3-2-使用應用程式提供的控制器"><a href="#4-3-2-使用應用程式提供的控制器" class="headerlink" title="4.3.2 使用應用程式提供的控制器"></a>4.3.2 使用應用程式提供的控制器</h5><p>預設情況下，由於 Rails 控制器通常會透過繼承 <code>ApplicationController</code> 共享程式碼，例如身份驗證和存取 session 變數。然而，Rails 引擎的作用域與主應用程式是隔離的，因此每個引擎的 <code>ApplicationController</code> 都具有獨立的命名空間。獨立的命名空間可避免程式碼衝突，但是引擎的控制器常常需要存取主應用程式的 <code>ApplicationController</code> 中的方法。提供存取的簡單方法是讓引擎具有命名空間的 <code>ApplicationController</code> 繼承自主應用程式的 <code>ApplicationController</code>。對於我們的 Blorgh 引擎，可以透過以下改變 <code>app/controllers/blorgh/application_controller.rb</code> 來完成：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Blorgh</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ApplicationController</span> &lt; ::<span class="title">ApplicationController</span></span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>所以，在做出這個改變之後，他們可以訪問主應用程序的<code>ApplicationController</code>，就好像它們是主應用程序的一部分。<br>預設情況下，引擎的控制器繼承自 <code>Blorgh::ApplicationController</code>。因此透過上述修改，它們將能夠存取主應用程式的 <code>ApplicationController</code>，就好像它們是主應用程式的一部分。</p>
<p>此修改的前提是，引擎需要執行在具有 <code>ApplicationController</code> 的 Rails 應用程式。</p>
<h4 id="4-4-設定引擎"><a href="#4-4-設定引擎" class="headerlink" title="4.4 設定引擎"></a>4.4 設定引擎</h4><p>本節介紹如何讓 <code>User</code> 類別成為可配置的，然後介紹引擎的基本配置注意事項。</p>
<h5 id="4-4-1-在應用程式中設定配置"><a href="#4-4-1-在應用程式中設定配置" class="headerlink" title="4.4.1 在應用程式中設定配置"></a>4.4.1 在應用程式中設定配置</h5><p>下一步是讓引擎可以客製化在應用程式中所使用的 <code>User</code> 類別。如先前所述，該類別並非總是 <code>User</code>。為了使這個配置可客製化，引擎將有一個名為 <code>author_class</code> 的配置，它將用於指定哪個類別代表應用程式中的使用者。</p>
<p>要定義此配置，你應該在引擎的 <code>Blorgh</code> 模組中使用 <code>mattr_accessor</code>。將此行加到引擎內的 <code>lib/blorgh.rb</code> 中：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mattr_accessor <span class="symbol">:author_class</span></span><br></pre></td></tr></table></figure>

<p>這個方法的工作原理與 <code>attr_accessor</code> 和 <code>cattr_accessor</code> 類似，會根據指定名稱為模組提供設值（setter）方法和取值（getter）方法。使用時直接呼叫 <code>Blorgh.author_class</code> 即可。</p>
<p>下一步是將 <code>Blorgh::Article</code> 模型切換到這個新設定。修改這個模型（<code>app/models/blorgh/article.rb</code>）的 <code>belongs_to</code> 關聯：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">belongs_to <span class="symbol">:author</span>, <span class="symbol">class_name:</span> Blorgh.author_class</span><br></pre></td></tr></table></figure>

<p><code>Blorgh::Article</code> 模型中的 <code>set_author</code> 方法也應該使用此類別：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.author = Blorgh.author_class.constantize.find_or_create_by(<span class="symbol">name:</span> author_name)</span><br></pre></td></tr></table></figure>

<p>為了避免每次都要對 <code>author_class</code> 結果呼叫 <code>constantize</code>，我們可以在 <code>lib/blorgh.rb</code> 檔案中覆寫 <code>Blorgh</code> 模組的 <code>author_class</code> 取值（getter）方法，在回傳結果之前呼叫 <code>constantize</code>：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">author_class</span></span></span><br><span class="line">  @@author_class.constantize</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>此時，上述的 <code>set_author</code> 程式碼將變為：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.author = Blorgh.author_class.find_or_create_by(<span class="symbol">name:</span> author_name)</span><br></pre></td></tr></table></figure>
<p>修改後的結果更為簡短，行為更加明確。<code>author_class</code> 方法應該總是回傳 <code>Class</code> 物件。</p>
<p>因為修改後的 <code>author_class</code> 方法回傳 <code>Class</code> 而不是 <code>String</code>，我們還需要修改 <code>Blorgh::Article</code> 模型中的 <code>belongs_to</code> 定義：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">belongs_to <span class="symbol">:author</span>, <span class="symbol">class_name:</span> Blorgh.author_class.to_s</span><br></pre></td></tr></table></figure>

<p>要在應用程式設定此配置，應該使用初始化程式。透過初始化程式，配置會在應用程式啟動且呼叫引擎的模型前完成設定，這可能取決於現有的配置設定。</p>
<p>在安裝 <code>blorgh</code> 引擎的應用程式中，建立一個新的初始化程式在 <code>config/initializers/blorgh.rb</code>，並放入以下內容：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blorgh.author_class = <span class="string">"User"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重要的是這裡使用<strong>字串</strong>版本的類別，而不是直接使用類別。如果我們直接使用類別，Rails 會嘗試載入該類別並引用相關資料表。如果資料表不存在，可能會導致問題產生。因此，應該使用<strong>字串</strong>，然後在引擎中透過 <code>constantize</code> 將其轉換為類別。</p>
</blockquote>
<p>接下來嘗試新增一篇文章。你會發現過程和之前相同，不過這次引擎使用的是 <code>config/initializers/blorgh.rb</code> 內配置設定的類別。</p>
<p>現在，不用在意使用者類別到底是什麼，只需要確認使用者類別是否實作所需的 API。引擎只要求使用者類別實作了 <code>find_or_create_by</code> 方法，此方法回傳了使用者類別的物件，以便在建立文章時與其相關聯。當然，這個物件應該有某種可以被引用的識別碼。</p>
<h5 id="4-4-2-引擎基本配置"><a href="#4-4-2-引擎基本配置" class="headerlink" title="4.4.2 引擎基本配置"></a>4.4.2 引擎基本配置</h5><p>有時候你可能會想在引擎中使用初始化程式、國際化或其它配置選項。這些事情是可以的，因為 Rails 引擎和 Rails 應用程式共享很多相同的功能。事實上，Rails 應用程式的功能實際上是由引擎提供的功能的超集合！</p>
<p>如果你希望使用初始化程式（載入引擎前應該執行的程式碼），儲存的位置是在它的 <code>config/initializers</code> 資料夾。此目錄的功能在配置指南的<a href="http://guides.rubyonrails.org/configuring.html#initializers" target="_blank" rel="noopener">初始化程式章節</a>有說明，並且與應用程式中的 <code>config/initializers</code> 目錄完全相同。如果你想使用標準的初始化程式，也是一樣的。</p>
<p>對於語系設定，只需將語系檔案放在 <code>config/locales</code> 目錄，如同在應用程式中一樣。</p>
<h3 id="5-測試引擎"><a href="#5-測試引擎" class="headerlink" title="5. 測試引擎"></a>5. 測試引擎</h3><p>當引擎建立後，會在 <code>test/dummy</code> 中建立一個小型的虛擬應用程式。這個應用程式被用作引擎的裝載點，使引擎測試非常簡單。你可以透過在目錄中產生控制器、模型或視圖來擴充此應用程式，然後用它們來測試你的引擎。</p>
<p><code>test</code> 目錄和典型的 Rails 測試環境一樣，支援單元測試、功能測試和整合測試。</p>
<h4 id="5-1-功能測試"><a href="#5-1-功能測試" class="headerlink" title="5.1 功能測試"></a>5.1 功能測試</h4><p>在編寫功能測試時，一件值得考慮的事是測試會在 <code>test/dummy</code> 應用程式上執行，而不是引擎。這是由測試環境的設定決定的，引擎需要裝載在應用程式才能測試其主要功能，尤其是控制器。也就是說，如果你在控制器的功能測試中像這樣為控制器編寫一個典型的 <code>GET</code> 請求：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Blorgh</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">FooControllerTest</span> &lt; ActionDispatch::IntegrationTest</span></span><br><span class="line">    <span class="keyword">include</span> Engine.routes.url_helpers</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_index</span></span></span><br><span class="line">      get foos_url</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>它的功能還無法正確運作。這是因為應用程式不知道如何將這些請求傳遞到引擎，除非你明確的告訴它<strong>如何</strong>處理。為此，你必須在程式中將 <code>@routes</code> 實例變數設定為引擎的路由：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Blorgh</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">FooControllerTest</span> &lt; ActionDispatch::IntegrationTest</span></span><br><span class="line">    <span class="keyword">include</span> Engine.routes.url_helpers</span><br><span class="line"></span><br><span class="line">    setup <span class="keyword">do</span></span><br><span class="line">      @routes = Engine.routes</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_index</span></span></span><br><span class="line">      get foos_url</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>這告訴應用程式你想對此控制器的 <code>index</code> 動作執行一個 <code>GET</code> 請求，但你想使用引擎的路由，而不是應用程式的路由。</p>
<p>這也確保了引擎的 URL 輔助方法能夠在測試中正常運作。</p>
<h3 id="6-改進引擎功能"><a href="#6-改進引擎功能" class="headerlink" title="6. 改進引擎功能"></a>6. 改進引擎功能</h3><p>本節介紹如何在 Rails 主應用程式中加入或覆寫引擎的 MVC 功能。</p>
<h4 id="6-1-覆寫模型和控制器"><a href="#6-1-覆寫模型和控制器" class="headerlink" title="6.1 覆寫模型和控制器"></a>6.1 覆寫模型和控制器</h4><p>在 Rails 主應用程式中，可以透過打開類別來擴充引擎模型和控制器類別（因為模型和控制器類別只是繼承 Rails 特定功能的 Ruby 類別）。透過打開類別，可以根據主應用程式的需求重新定義引擎的類別。通常會透過裝飾器模式來實作。</p>
<p>對於簡單的類別修改，可以使用 <code>Class#class_eval</code>。對於複雜的類別修改，可以考慮使用 <code>ActiveSupport::Concern</code>。</p>
<h5 id="6-1-1-使用裝飾器和載入代碼時的注意事項"><a href="#6-1-1-使用裝飾器和載入代碼時的注意事項" class="headerlink" title="6.1.1 使用裝飾器和載入代碼時的注意事項"></a>6.1.1 使用裝飾器和載入代碼時的注意事項</h5><p>因為這些裝飾器沒有被 Rails 應用程式本身引用，Rails 的自動載入系統不會載入你的裝飾器。也就是說，你需要自己載入它們。</p>
<p>以下是執行此操作的一些範例程式碼：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lib/blorgh/engine.rb</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Blorgh</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> &lt; ::<span class="title">Rails::Engine</span></span></span><br><span class="line">    isolate_namespace Blorgh</span><br><span class="line"></span><br><span class="line">    config.to_prepare <span class="keyword">do</span></span><br><span class="line">      Dir.glob(Rails.root + <span class="string">"app/decorators/**/*_decorator*.rb"</span>).each <span class="keyword">do</span> <span class="params">|c|</span></span><br><span class="line">        require_dependency(c)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>這不僅適用於裝飾器，也適用於任何加入到引擎中但未被主應用程式引用的東西。</p>
<h5 id="6-1-2-使用-Class-class-eval-實作裝飾器模式"><a href="#6-1-2-使用-Class-class-eval-實作裝飾器模式" class="headerlink" title="6.1.2 使用 Class#class_eval 實作裝飾器模式"></a>6.1.2 使用 Class#class_eval 實作裝飾器模式</h5><p><strong>加入</strong> <code>Article#time_since_created</code>：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MyApp/app/decorators/models/blorgh/article_decorator.rb</span></span><br><span class="line"></span><br><span class="line">Blorgh::Article.class_eval <span class="keyword">do</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">time_since_created</span></span></span><br><span class="line">    Time.current - created_at</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Blorgh/app/models/article.rb</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span> &lt; ApplicationRecord</span></span><br><span class="line">  has_many <span class="symbol">:comments</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>覆寫</strong> <code>Article#summary</code>：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MyApp/app/decorators/models/blorgh/article_decorator.rb</span></span><br><span class="line"></span><br><span class="line">Blorgh::Article.class_eval <span class="keyword">do</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">summary</span></span></span><br><span class="line">    <span class="string">"<span class="subst">#&#123;title&#125;</span> - <span class="subst">#&#123;truncate(text)&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Blorgh/app/models/article.rb</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span> &lt; ApplicationRecord</span></span><br><span class="line">  has_many <span class="symbol">:comments</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">summary</span></span></span><br><span class="line">    <span class="string">"<span class="subst">#&#123;title&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="6-1-3-使用-ActiveSupport-Concern-實作裝飾器模式"><a href="#6-1-3-使用-ActiveSupport-Concern-實作裝飾器模式" class="headerlink" title="6.1.3 使用 ActiveSupport::Concern 實作裝飾器模式"></a>6.1.3 使用 ActiveSupport::Concern 實作裝飾器模式</h5><p>使您可以顯著模塊化您的代碼。<br>使用 <code>Class#class_eval</code> 非常適合簡單的調整，但是對於更複雜的類別修改，你可能需要考慮使用 <a href="http://api.rubyonrails.org/v5.2.0/classes/ActiveSupport/Concern.html" target="_blank" rel="noopener">ActiveSupport::Concern</a>。ActiveSupport::Concern 能管理互相關聯相依模組和類別執行時的載入順序，讓你可以放心模組化你的程式碼。</p>
<p><strong>加入</strong> <code>Article#time_since_created</code> 並<strong>覆寫</strong> <code>Article#summary</code>：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MyApp/app/models/blorgh/article.rb</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blorgh::Article</span> &lt; ApplicationRecord</span></span><br><span class="line">  <span class="keyword">include</span> Blorgh::Concerns::Models::Article</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">time_since_created</span></span></span><br><span class="line">    Time.current - created_at</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">summary</span></span></span><br><span class="line">    <span class="string">"<span class="subst">#&#123;title&#125;</span> - <span class="subst">#&#123;truncate(text)&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Blorgh/app/models/article.rb</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span> &lt; ApplicationRecord</span></span><br><span class="line">  <span class="keyword">include</span> Blorgh::Concerns::Models::Article</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Blorgh/lib/concerns/models/article.rb</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Blorgh::Concerns::Models::Article</span></span></span><br><span class="line">  extend ActiveSupport::Concern</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 'included do' 內的程式碼可以在被載入的地方（article.rb）執行，而不是在</span></span><br><span class="line">  <span class="comment"># 模組內（blorgh/concerns/models/article）被執行。</span></span><br><span class="line">  included <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">attr_accessor</span> <span class="symbol">:author_name</span></span><br><span class="line">    belongs_to <span class="symbol">:author</span>, <span class="symbol">class_name:</span> <span class="string">"User"</span></span><br><span class="line"></span><br><span class="line">    before_validation <span class="symbol">:set_author</span></span><br><span class="line"></span><br><span class="line">    private</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">set_author</span></span></span><br><span class="line">        <span class="keyword">self</span>.author = User.find_or_create_by(<span class="symbol">name:</span> author_name)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">summary</span></span></span><br><span class="line">    <span class="string">"<span class="subst">#&#123;title&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">ClassMethods</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_class_method</span></span></span><br><span class="line">      <span class="string">'some class method string'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-覆寫視圖"><a href="#6-2-覆寫視圖" class="headerlink" title="6.2 覆寫視圖"></a>6.2 覆寫視圖</h4><p>當 Rails 在尋找要呈現的視圖時，它首先會在應用程式的 <code>app/views</code> 目錄中尋找。如果找不到，接著就會在所有引擎的 <code>app/views</code>目錄中尋找。</p>
<p>當應用程式要呈現 <code>Blorgh::ArticlesController</code> 的 index 動作的視圖時，它會先在應用程式中尋找 <code>app/views/blorgh/articles/index.html.erb</code> 檔案。如果找不到，接著會在引擎中尋找。</p>
<p>你可以透過在應用程式中建立 <code>app/views/blorgh/articles/index.html.erb</code> 檔案來覆寫這個視圖。然後可以完全改變這個視圖輸出的內容。</p>
<p>現在試著建立 <code>app/views/blorgh/articles/index.html.erb</code> 檔案並放入以下內容：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Articles<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> link_to <span class="string">"New Article"</span>, new_article_path </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> @articles.each <span class="keyword">do</span> <span class="params">|article|</span> </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> article.title </span><span class="xml"><span class="tag">%&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">small</span>&gt;</span>By <span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> article.author </span><span class="xml"><span class="tag">%&gt;</span><span class="tag">&lt;/<span class="name">small</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> simple_format(article.text) </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> <span class="keyword">end</span> </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="6-3-路由"><a href="#6-3-路由" class="headerlink" title="6.3 路由"></a>6.3 路由</h4><p>預設情況下，引擎與應用程式的路由是隔離的。這是透過在 <code>Engine</code> 類別中呼叫 <code>isolate_namespace</code> 完成的。也就是說，應用程式及其引擎可以具有相同名稱的路由，並且它們不會發生衝突。</p>
<p>在 <code>config/routes.rb</code> 檔案中，可以在 <code>Engine</code> 類別上定義引擎的路由：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Blorgh::Engine.routes.draw <span class="keyword">do</span></span><br><span class="line">  resources <span class="symbol">:articles</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>因為路由是隔離的，如果你想從應用程式中連結到引擎的某個位置時，必須使用引擎的路由代理方法。呼叫一般路由方法如 <code>articles_path</code> 可能會產生非預期的連結，因為應用程式和引擎可能都定義了這個輔助方法。</p>
<p>例如，就以下範例來說，如果是從應用程式呈現樣板，就會指向應用程式的 <code>articles_path</code>，如果是從引擎呈現樣板，則會指向引擎的 <code>articles_path</code>：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> link_to <span class="string">"Blog articles"</span>, articles_path </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>要確保使用的是引擎的 <code>articles_path</code> 路由輔助方法，我們必須透過與引擎相同名稱的路由代理方法來呼叫這個輔助方法。</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> link_to <span class="string">"Blog articles"</span>, blorgh.articles_path </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>如果你想用類似的方式在引擎內引用應用程式，可以使用 <code>main_app</code> 輔助方法：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> link_to <span class="string">"Home"</span>, main_app.root_path </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>如果你在引擎中使用上述程式碼，它會<strong>總是</strong>指向應用程式的根目錄。若不使用 <code>main_app</code> 「路由代理」方法，它可能會指向引擎或應用程式的根目錄，取決於從何處呼叫它。</p>
<p>如果嘗試從引擎中呈現的樣板使用應用程式的路由輔助方法，可能會導致呼叫未定義的方法。如果遇到此類問題，請確保你沒有嘗試在引擎內沒有 <code>main_app</code> 前綴的情況下呼叫應用程式的路由輔助方法。</p>
<h4 id="6-4-靜態資源"><a href="#6-4-靜態資源" class="headerlink" title="6.4 靜態資源"></a>6.4 靜態資源</h4><p>引擎內的資源與完整應用程式的工作方式相同。由於引擎類別繼承自 <code>Rails::Engine</code>，應用程式會知道在引擎的 <code>app/assets</code> 和 <code>lib/assets</code> 目錄中尋找靜態資源。</p>
<p>和引擎的所有其它元件一樣，靜態資源應該具有命名空間。也就是說，如果你有一個名為 <code>style.css</code> 的靜態資源，它應該被放在 <code>app/assets/stylesheets/[engine name]/style.css</code>，而不是 <code>app/assets/stylesheets/style.css</code>。如果靜態資源不具有命名空間，主應用程式可能會有一個相同名稱的靜態資源，在這種情況下，應用程式的靜態資源會具有較高的優先權，引擎的靜態資源將被忽略。</p>
<p>想像一下，你有一個靜態資源位於 <code>app/assets/stylesheets/blorgh/style.css</code>，要在應用程式中載入此檔案，只需使用 <code>stylesheet_link_tag</code> 並引用靜態資源即可：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> stylesheet_link_tag <span class="string">"blorgh/style.css"</span> </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>你也可以使用 Asset Pipeline 的 require 語法來載入引擎中的靜態資源：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *= require blorgh/style</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>記住，若要使用 Sass 或 CoffeeScript 等語言，你應該將相關函式庫加到引擎的 <code>.gemspec</code>。</p>
</blockquote>
<h4 id="6-5-獨立的靜態資源和預先編譯"><a href="#6-5-獨立的靜態資源和預先編譯" class="headerlink" title="6.5 獨立的靜態資源和預先編譯"></a>6.5 獨立的靜態資源和預先編譯</h4><p>有時候，主應用程式不需要載入引擎的靜態資源。例如，你建立了僅存在於引擎中的管理功能。在這種情況下，主應用程式不需要載入 <code>admin.css</code> 或 <code>admin.js</code>。只有 gem 的管理後台才需要這些靜態資源。主應用程式在其樣式表中載入 <code>blorgh/admin.css</code> 是沒有意義的。在這種情況下，你應該明確定義這些需要預先編譯的靜態資源。這會告訴 Sprockets 在觸發 <code>bin/rails assets:precompile</code> 時加入你的引擎靜態資源。</p>
<p>你可以在 <code>engine.rb</code> 定義需要預先編譯的靜態資源：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initializer <span class="string">"blorgh.assets.precompile"</span> <span class="keyword">do</span> <span class="params">|app|</span></span><br><span class="line">  app.config.assets.precompile += <span class="string">%w( admin.js admin.css )</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>更多相關資訊，請參閱 <a href="http://guides.rubyonrails.org/asset_pipeline.html" target="_blank" rel="noopener">Asset Pipeline</a> 指南。</p>
<h4 id="6-6-其它相依-Gem"><a href="#6-6-其它相依-Gem" class="headerlink" title="6.6 其它相依 Gem"></a>6.6 其它相依 Gem</h4><p>引擎的相依套件應該在引擎跟目錄下的 <code>.gemspec</code> 檔案中指定。因為我們可能會以 gem 的方式安裝引擎。如果在引擎的 <code>Gemfile</code> 指定相依套件，那麼 gem install 將無法識別這些相依關係，因此它們不會被安裝，從而導致引擎發生故障。</p>
<p>要指定當 <code>gem install</code> 時應該和引擎一起安裝的相依套件，只需要在引擎中 <code>.gemspec</code> 檔案的 <code>Gem::Specification</code> 區塊內指定：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.add_dependency <span class="string">"moo"</span></span><br></pre></td></tr></table></figure>
<p>還可以像這樣指定僅用於開發環境的相依套件：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.add_development_dependency <span class="string">"moo"</span></span><br></pre></td></tr></table></figure>

<p>在應用程式內執行 <code>bundle install</code> 時，這兩種相依套件都會被安裝。用於開發環境的相依套件只有在執行引擎測試時才會使用。</p>
<p>注意，如果要在引擎載入時立即載入相依套件，你應該在引擎初始化前就載入它們。例如：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'other_engine/engine'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'yet_another_engine/engine'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">MyEngine</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> &lt; ::<span class="title">Rails::Engine</span></span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>所以當你過早載入某些框架時（例如，ActiveRecord::Base），你就違反了使用 Rails 應用程式的使用慣例</p>
<h3 id="7-Active-Support-的-on-load-Hook"><a href="#7-Active-Support-的-on-load-Hook" class="headerlink" title="7. Active Support 的 on_load Hook"></a>7. Active Support 的 on_load Hook</h3><p>Active Support 是 Ruby on Rails 元件，負責提供 Ruby 語言擴充套件和公用程式。</p>
<p>Rails 程式碼通常可以在應用程式載入時引用。Rails 負責這些框架的載入順序，所以當你過早載入某些框架時（例如 <code>ActiveRecord::Base</code>），就違反了 Rails 應用程式的使用慣例。此外，透過在應用程式啟動時載入如 <code>ActiveRecord::Base</code> 等程式碼，你正在載入整個框架，這可能會降低啟動時間，並可能導致載入順序與應用程式啟動發生衝突。</p>
<p><code>on_load</code> API 能夠讓我們在初始化的流程中掛載你所需要的功能，而不違反 Rails 所制定的規則。這也將緩解啟動效能下降並避免衝突。</p>
<h3 id="8-什麼是-on-load-Hook？"><a href="#8-什麼是-on-load-Hook？" class="headerlink" title="8. 什麼是 on_load Hook？"></a>8. 什麼是 on_load Hook？</h3><p>由於 Ruby 是動態語言，因此某些程式碼會導致載入相關的 Rails 元件。以此程式碼片段為例：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActiveRecord::Base.<span class="keyword">include</span>(MyActiveRecordHelper)</span><br></pre></td></tr></table></figure>

<p>當這段程式碼片段被載入時，發現有 <code>ActiveRecord::Base</code>，因此 Ruby 會去尋找該常數的定義並載入它。這將導致整個 Active Record 框架在啟動時被載入。</p>
<p><code>ActiveSupport.on_load</code> 是一種延遲載入程式碼的機制，直到真正需要時才載入。上述代碼可以修改為：</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActiveSupport.on_load(<span class="symbol">:active_record</span>) &#123; <span class="keyword">include</span> MyActiveRecordHelper &#125;</span><br></pre></td></tr></table></figure>

<p>新的程式碼片段會在 <code>ActiveRecord::Base</code> 載入後才載入 <code>MyActiveRecordHelper</code>。</p>
<h3 id="9-它是如何運作的？"><a href="#9-它是如何運作的？" class="headerlink" title="9. 它是如何運作的？"></a>9. 它是如何運作的？</h3><p>在 Rails 框架中，載入特定函式庫時會呼叫這些 hook。例如，當 <code>ActionController::Base</code> 被載入時，會呼叫 <code>:action_controller_base</code> hook。也就是說，<code>ActiveSupport.on_load</code> 呼叫設定用的 <code>:action_controller_base</code> hook 會在 <code>ActionController::Base</code> 環境中被呼叫。（因此 <code>self</code> 是 <code>ActionController::Base</code> 的實例變數）。</p>
<h3 id="10-修改程式碼，使用-on-load-Hook"><a href="#10-修改程式碼，使用-on-load-Hook" class="headerlink" title="10. 修改程式碼，使用 on_load Hook"></a>10. 修改程式碼，使用 on_load Hook</h3><p>修改程式碼很簡單。如果你有一行引用 Rails 框架的程式碼，例如 <code>ActiveRecord::Base</code>，你可以將該程式碼包裝在 <code>on_load</code> hook 中。</p>
<h4 id="10-1-範例-1"><a href="#10-1-範例-1" class="headerlink" title="10.1 範例 1"></a>10.1 範例 1</h4><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActiveRecord::Base.<span class="keyword">include</span>(MyActiveRecordHelper)</span><br></pre></td></tr></table></figure>

<p>改為</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActiveSupport.on_load(<span class="symbol">:active_record</span>) &#123; <span class="keyword">include</span> MyActiveRecordHelper &#125; <span class="comment"># self 在這裡指的是 ActiveRecord::Base，所以可以直接呼叫 #include</span></span><br></pre></td></tr></table></figure>

<h4 id="10-2-範例-2"><a href="#10-2-範例-2" class="headerlink" title="10.2 範例 2"></a>10.2 範例 2</h4><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActionController::Base.prepend(MyActionControllerHelper)</span><br></pre></td></tr></table></figure>

<p>改為</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActiveSupport.on_load(<span class="symbol">:action_controller_base</span>) &#123; prepend MyActionControllerHelper &#125; <span class="comment"># self 在這裡指的是 ActionController::Base，所以可以直接呼叫 #prepend</span></span><br></pre></td></tr></table></figure>

<h4 id="10-3-範例-3"><a href="#10-3-範例-3" class="headerlink" title="10.3 範例 3"></a>10.3 範例 3</h4><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActiveRecord::Base.include_root_in_json = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>改為</p>
<figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActiveSupport.on_load(<span class="symbol">:active_record</span>) &#123; <span class="keyword">self</span>.include_root_in_json = <span class="literal">true</span> &#125; <span class="comment"># self 在這裡指的是 ActiveRecord::Base</span></span><br></pre></td></tr></table></figure>

<h3 id="11-可用的-Hook"><a href="#11-可用的-Hook" class="headerlink" title="11. 可用的 Hook"></a>11. 可用的 Hook</h3><p>這些是可以在程式碼中使用的 hook。</p>
<p>要接上以下某個類別的初始化過程，請使用可用的 hook。</p>
<table>
<thead>
<tr>
<th>類別</th>
<th>可用的 Hook</th>
</tr>
</thead>
<tbody><tr>
<td><code>ActionCable</code></td>
<td><code>action_cable</code></td>
</tr>
<tr>
<td><code>ActionController::API</code></td>
<td><code>action_controller_api</code></td>
</tr>
<tr>
<td><code>ActionController::API</code></td>
<td><code>action_controller</code></td>
</tr>
<tr>
<td><code>ActionController::Base</code></td>
<td><code>action_controller_base</code></td>
</tr>
<tr>
<td><code>ActionController::Base</code></td>
<td><code>action_controller</code></td>
</tr>
<tr>
<td><code>ActionController::TestCase</code></td>
<td><code>action_controller_test_case</code></td>
</tr>
<tr>
<td><code>ActionDispatch::IntegrationTest</code></td>
<td><code>action_dispatch_integration_test</code></td>
</tr>
<tr>
<td><code>ActionDispatch::SystemTestCase</code></td>
<td><code>action_dispatch_system_test_case</code></td>
</tr>
<tr>
<td><code>ActionMailer::Base</code></td>
<td><code>action_mailer</code></td>
</tr>
<tr>
<td><code>ActionMailer::TestCase</code></td>
<td><code>action_mailer_test_case</code></td>
</tr>
<tr>
<td><code>ActionView::Base</code></td>
<td><code>action_view</code></td>
</tr>
<tr>
<td><code>ActionView::TestCase</code></td>
<td><code>action_view_test_case</code></td>
</tr>
<tr>
<td><code>ActiveJob::Base</code></td>
<td><code>active_job</code></td>
</tr>
<tr>
<td><code>ActiveJob::TestCase</code></td>
<td><code>active_job_test_case</code></td>
</tr>
<tr>
<td><code>ActiveRecord::Base</code></td>
<td><code>active_record</code></td>
</tr>
<tr>
<td><code>ActiveSupport::TestCase</code></td>
<td><code>active_support_test_case</code></td>
</tr>
<tr>
<td><code>i18n</code></td>
<td><code>i18n</code></td>
</tr>
</tbody></table>
<h3 id="12-配置-Hook"><a href="#12-配置-Hook" class="headerlink" title="12. 配置 Hook"></a>12. 配置 Hook</h3><p>這些是可用的配置 hook。它們並沒有涉及到任何特定的框架，而是在整個應用程式中執行。</p>
<table>
<thead>
<tr>
<th>Hook</th>
<th>使用案例</th>
</tr>
</thead>
<tbody><tr>
<td><code>before_configuration</code></td>
<td>第一個執行的配置區塊。在所有初始化程式執行前呼叫。</td>
</tr>
<tr>
<td><code>before_initialize</code></td>
<td>第二個執行的配置區塊。框架初始化前呼叫。</td>
</tr>
<tr>
<td><code>before_eager_load</code></td>
<td>第三個執行的配置區塊。<code>config.eager_load</code> 設為 false 時不執行。</td>
</tr>
<tr>
<td><code>after_initialize</code></td>
<td>最後執行的配置區塊。框架初始化完成後呼叫。</td>
</tr>
</tbody></table>
<h4 id="12-1-範例"><a href="#12-1-範例" class="headerlink" title="12.1 範例"></a>12.1 範例</h4><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.before_configuration &#123; puts <span class="string">'I am called before any initializers'</span> &#125;</span><br></pre></td></tr></table></figure>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Ruby-on-Rails" >
    <span class="tag-code">Ruby on Rails</span>
  </a>

  <a href="/tags#Rails-Engine" >
    <span class="tag-code">Rails Engine</span>
  </a>


      </div>
    
    <!-- Tags END -->
    <!-- UpdatedDate Start -->
     
       <p class="post-date">最後更新時間：2019-11-15</p>
     
   <!-- UpdatedDate END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2018/05/22/active-storage-on-heroku/">
        <span class="nav-arrow">&larr; </span>
        
          在 Heroku 使用 Active Storage
        
      </a>
    
    
      <a class="nav-right" href="/2018/07/31/when-should-you-use-self-in-your-classes/">
        
          什麼時候應該在類別內使用 self
        
        <span class="nav-arrow"> &rarr;</span>
      </a>
    
  </div>


    <!-- NAV END -->
    <!-- 打賞 START -->
    
    <!-- 打賞 END -->
    <!-- 二維條碼 START -->
    
      <div class="qrcode">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <g id="share-qrcode"/>
        </svg>
        <p class="notice">掃描二維條碼，分享此文章</p>
      </div>
    
    <!-- 二維條碼 END -->
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">目錄</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-什麼是引擎？"><span class="toc-nav-text">1. 什麼是引擎？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-產生一個引擎"><span class="toc-nav-text">2. 產生一個引擎</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-引擎內部"><span class="toc-nav-text">2.1 引擎內部</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#2-1-1-關鍵檔案"><span class="toc-nav-text">2.1.1 關鍵檔案</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#2-1-2-app-目錄"><span class="toc-nav-text">2.1.2 app 目錄</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#2-1-3-bin-目錄"><span class="toc-nav-text">2.1.3 bin 目錄</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#2-1-4-test-目錄"><span class="toc-nav-text">2.1.4 test 目錄</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-提供引擎功能"><span class="toc-nav-text">3. 提供引擎功能</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-產生-Article-資源"><span class="toc-nav-text">3.1 產生 Article 資源</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-產生-Comments-資源"><span class="toc-nav-text">3.2 產生 Comments 資源</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-安裝到應用程式"><span class="toc-nav-text">4. 安裝到應用程式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-1-掛載引擎"><span class="toc-nav-text">4.1 掛載引擎</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-2-安裝引擎"><span class="toc-nav-text">4.2 安裝引擎</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-3-使用應用程式提供的類別"><span class="toc-nav-text">4.3 使用應用程式提供的類別</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#4-3-1-使用應用程式提供的模型"><span class="toc-nav-text">4.3.1 使用應用程式提供的模型</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#4-3-2-使用應用程式提供的控制器"><span class="toc-nav-text">4.3.2 使用應用程式提供的控制器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-4-設定引擎"><span class="toc-nav-text">4.4 設定引擎</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#4-4-1-在應用程式中設定配置"><span class="toc-nav-text">4.4.1 在應用程式中設定配置</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#4-4-2-引擎基本配置"><span class="toc-nav-text">4.4.2 引擎基本配置</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-測試引擎"><span class="toc-nav-text">5. 測試引擎</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-1-功能測試"><span class="toc-nav-text">5.1 功能測試</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-改進引擎功能"><span class="toc-nav-text">6. 改進引擎功能</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-1-覆寫模型和控制器"><span class="toc-nav-text">6.1 覆寫模型和控制器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#6-1-1-使用裝飾器和載入代碼時的注意事項"><span class="toc-nav-text">6.1.1 使用裝飾器和載入代碼時的注意事項</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#6-1-2-使用-Class-class-eval-實作裝飾器模式"><span class="toc-nav-text">6.1.2 使用 Class#class_eval 實作裝飾器模式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#6-1-3-使用-ActiveSupport-Concern-實作裝飾器模式"><span class="toc-nav-text">6.1.3 使用 ActiveSupport::Concern 實作裝飾器模式</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-2-覆寫視圖"><span class="toc-nav-text">6.2 覆寫視圖</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-3-路由"><span class="toc-nav-text">6.3 路由</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-4-靜態資源"><span class="toc-nav-text">6.4 靜態資源</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-5-獨立的靜態資源和預先編譯"><span class="toc-nav-text">6.5 獨立的靜態資源和預先編譯</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#6-6-其它相依-Gem"><span class="toc-nav-text">6.6 其它相依 Gem</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-Active-Support-的-on-load-Hook"><span class="toc-nav-text">7. Active Support 的 on_load Hook</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-什麼是-on-load-Hook？"><span class="toc-nav-text">8. 什麼是 on_load Hook？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9-它是如何運作的？"><span class="toc-nav-text">9. 它是如何運作的？</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#10-修改程式碼，使用-on-load-Hook"><span class="toc-nav-text">10. 修改程式碼，使用 on_load Hook</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#10-1-範例-1"><span class="toc-nav-text">10.1 範例 1</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#10-2-範例-2"><span class="toc-nav-text">10.2 範例 2</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#10-3-範例-3"><span class="toc-nav-text">10.3 範例 3</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#11-可用的-Hook"><span class="toc-nav-text">11. 可用的 Hook</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#12-配置-Hook"><span class="toc-nav-text">12. 配置 Hook</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#12-1-範例"><span class="toc-nav-text">12.1 範例</span></a></li></ol></li></ol>
    
  </div>
</aside>

  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://calvertyang.github.io/2018/06/11/getting-started-with-engines/';
    var banner = '';
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      });
    } else {
      $('#article-banner').geopattern(url);
    }
    $('.header').removeClass('fixed-header');

     // error image
    $('.markdown-content img').on('error', function() {
      $(this).attr('src', '/css/images/error-img.png');
      $(this).css({
        'cursor': 'default'
      });
    });

    // 若圖片放在連結內，則將游標改為 pointer 並將圖片靠左
    $('.markdown-content img').each(function() {
      if ($(this).parents().is('a')) {
        $(this).css({
          'cursor': 'pointer',
          'display': 'inline-block'
        });
      }
    });

    // zoom image
    $('.markdown-content img').on('click', function(e) {
      var src = $(this).attr('src');
      if (src !== '/css/images/error-img.png' && !$(this).parents().is('a')) {
        var imageW = $(this).width();
        var imageH = $(this).height();

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2);
        zoom = zoom < 1 ? 1 : zoom;
        zoom = zoom > 2 ? 2 : zoom;
        var transY = (($(window).height() - imageH) / 2).toFixed(2);

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>');
        $('.image-view-wrap').addClass('wrap-active');
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        });
        $('html').css('overflow', 'hidden');

        $('.image-view-wrap').on('click', function() {
          $(this).remove();
          $('html').attr('style', '');
        });
      }
    });

    // qrcode
    var qrcode = new QRCode(document.getElementById('share-qrcode'), {
      text: document.location.href,
      width: 100,
      height: 100,
      colorDark: '#000000',
    	colorLight: '#ffffff',
      correctLevel: QRCode.CorrectLevel.L,
      useSVG: true
    });
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; Calvert 2020 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng" target="_blank" rel="noopener">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>

<script>
  async('//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js', function() {
    FastClick.attach(document.body);
  })
</script>

<script>
  $('figure').each(function(i, block) {
    let lang = this.classList[1] || 'codeblock';
    this.dataset.lang = lang.toUpperCase();
  });
</script>
<script src="/js/script.js"></script>

  </body>
</html>